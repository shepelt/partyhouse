---
url: /api/accounts.md
---
# Accounts

## Accounts-base {#accounts-base}

The Meteor Accounts system builds on top of the `userId` support in
[`publish`](./meteor#Subscription-userId) and [`methods`](./meteor#methods-userId). The core
packages add the concept of user documents stored in the database, and
additional packages add [secure password authentication](#passwords),
[integration with third party login services](#Meteor-loginWith%3CExternalService%3E),
and a [pre-built userinterface](/packages/accounts-ui.html).

The basic Accounts system is in the `accounts-base` package, but
applications typically include this automatically by adding one of the
login provider packages: `accounts-password`, `accounts-facebook`,
`accounts-github`, `accounts-google`, `accounts-meetup`,
`accounts-twitter`, or `accounts-weibo`.

Read more about customizing user accounts in the [Accounts](http://guide.meteor.com/accounts.html) article in the Meteor Guide.

### Accounts with Session Storage {#accounts-session-storage}

By default, Meteor uses Local Storage to store, among other things, login tokens in your browser session. But, for some applications, it makes sense to use Session Storage instead. Session Storage will not persist across client sessions. You can achieve this by adding this to your settings:

```json
{
  // ... all other settings,
  "public": {
    // ... all your public settings
    "packages": {
      "accounts": {
        "clientStorage": "session"
      }
    }
  }
}
```

<ApiBox name="Meteor.user" hasCustomExample/>

Retrieves the user record for the current user from
the [`Meteor.users`](#Meteor-users) collection.

On the client, the available fields will be those that
are published from the server (other fields won't be available on the
client). By default the server publishes `username`, `emails`, and
`profile` (writable by user). See [`Meteor.users`](#Meteor-users) for more on
the fields used in user documents.

On the server, this will fetch the record from the database. To improve the
latency of a method that uses the user document multiple times, save the
returned record to a variable instead of re-calling `Meteor.user()`.

Fetching the full user document can cause unnecessary database usage on the
server and over-reactivity on the client, particularly if you store lots of
custom data on it. Therefore it is recommended to use the `options`
parameter to only fetch the fields you need:

```js
import { Meteor } from "meteor/meteor";
const userName = Meteor.user({ fields: { "profile.name": 1 } }).profile.name;
```

<ApiBox name="Meteor.userAsync" hasCustomExample/>

Same as [`Meteor.user`](#Meteor-user), but returns a promise and is available on the server.

```js
import { Meteor } from "meteor/meteor";
const user = await Meteor.userAsync();
```

<ApiBox name="Meteor.userId" />

<ApiBox name="Meteor.users" />

This collection contains one document per registered user. Here's an example
user document:

```js
{
  _id: 'QwkSmTCZiw5KDx3L6',  // Meteor.userId()
  username: 'cool_kid_13', // Unique name
  emails: [
    // Each email address can only belong to one user.
    { address: 'cool@example.com', verified: true },
    { address: 'another@different.com', verified: false }
  ],
  createdAt: new Date('Wed Aug 21 2013 15:16:52 GMT-0700 (PDT)'),
  profile: {
    // The profile is writable by the user by default.
    name: 'Joe Schmoe'
  },
  services: {
    facebook: {
      id: '709050', // Facebook ID
      accessToken: 'AAACCgdX7G2...AbV9AZDZD'
    },
    resume: {
      loginTokens: [
        { token: '97e8c205-c7e4-47c9-9bea-8e2ccc0694cd',
          when: 1349761684048 }
      ]
    }
  }
}
```

A user document can contain any data you want to store about a user. Meteor
treats the following fields specially:

- `username`: a unique String identifying the user.
- `emails`: an Array of Objects with keys `address` and `verified`;
  an email address may belong to at most one user. `verified` is
  a Boolean which is true if the user has [verified the address](#Accounts-verifyEmail) with a token sent over email.
- `createdAt`: the Date at which the user document was created.
- `profile`: an Object which the user can create and update with any data.
  Do not store anything on `profile` that you wouldn't want the user to edit
  unless you have a deny rule on the `Meteor.users` collection.
- `services`: an Object containing data used by particular
  login services. For example, its `reset` field contains
  tokens used by [forgot password](#Accounts-forgotPassword) links,
  and its `resume` field contains tokens used to keep you
  logged in between sessions.

Like all [Mongo.Collection](./collections.md)s, you can access all
documents on the server, but only those specifically published by the server are
available on the client. You can also use all Collection methods, for instance
`Meteor.users.remove` on the server to delete a user.

By default, the current user's `username`, `emails` and `profile` are
published to the client. You can publish additional fields for the
current user with:

::: code-group

```js [server.js]
Meteor.publish("userData", function () {
  if (this.userId) {
    return Meteor.users.find(
      { _id: this.userId },
      {
        fields: { other: 1, things: 1 },
      }
    );
  } else {
    this.ready();
  }
});
```

```js [client.js]
Meteor.subscribe("userData");
```

:::
If the autopublish package is installed, information about all users
on the system is published to all clients. This includes `username`,
`profile`, and any fields in `services` that are meant to be public
(eg `services.facebook.id`,
`services.twitter.screenName`). Additionally, when using autopublish
more information is published for the currently logged in user,
including access tokens. This allows making API calls directly from
the client for services that allow this.

Users are by default allowed to specify their own `profile` field with
[`Accounts.createUser`](#Accounts-createUser) and modify it with
`Meteor.users.update`. To allow users to edit additional fields, use
[`Meteor.users.allow`](./collections.md#Mongo-Collection-allow). To forbid users from making any modifications to
their user document:

```js
import { Meteor } from "meteor/meteor";
Meteor.users.deny({ update: () => true });
```

<ApiBox name="Meteor.loggingIn" />

For example, [the `accounts-ui` package](../packages/accounts-ui.md) uses this to display an
animation while the login request is being processed.

<ApiBox name="Meteor.loggingOut" />

<ApiBox name="Meteor.logout" />

<ApiBox name="Meteor.logoutOtherClients" />

For example, when called in a user's browser, connections in that browser
remain logged in, but any other browsers or DDP clients logged in as that user
will be logged out.

<ApiBox name="Meteor.loginWithPassword" />

If there are multiple users with a username or email only differing in case, a case sensitive match is required. Although `createUser` won't let you create users with ambiguous usernames or emails, this could happen with existing databases or if you modify the users collection directly.

This method can fail throwing one of the following errors:

- "Unrecognized options for login request [400]" if `user` or `password` is undefined.
- "Match failed [400]" if `user` isn't an Object or String, or `password` isn't a String.
- "User not found [403]" if the email or username provided in `user` doesn't belong to a registered user.
- "Incorrect password [403]" if the password provided is incorrect.
- "User has no password set [403]" if `user` doesn't have a password.

This function is provided by the `accounts-password` package. See the
[Passwords](#passwords) section below.

<ApiBox name="Meteor.loginWith<ExternalService>" />

Available functions are:

- `Meteor.loginWithMeteorDeveloperAccount`
- `Meteor.loginWithFacebook`
  - `options` may also include [Facebook's `auth_type` parameter](https://developers.facebook.com/docs/facebook-login/manually-build-a-login-flow#reaskperms)
- `Meteor.loginWithGithub`
- `Meteor.loginWithGoogle`
  - `options` may also include [Google's additional URI parameters](https://developers.google.com/identity/protocols/OpenIDConnect#authenticationuriparameters)
- `Meteor.loginWithMeetup`
- `Meteor.loginWithTwitter`
  - `options` may also include [Twitter's `force_login` parameter](https://dev.twitter.com/oauth/reference/get/oauth/authenticate)
- `Meteor.loginWithWeibo`

These functions initiate the login process with an external
service (eg: Facebook, Google, etc), using OAuth. When called they open a new pop-up
window that loads the provider's login page. Once the user has logged in
with the provider, the pop-up window is closed and the Meteor client
logs in to the Meteor server with the information provided by the external
service.

<h3 id="requestpermissions" name="requestpermissions">Requesting Permissions</h3>

In addition to identifying the user to your application, some services
have APIs that allow you to take action on behalf of the user. To
request specific permissions from the user, pass the
`requestPermissions` option the login function. This will cause the user
to be presented with an additional page in the pop-up dialog to permit
access to their data. The user's `accessToken` &mdash; with permissions
to access the service's API &mdash; is stored in the `services` field of
the user document. The supported values for `requestPermissions` differ
for each login service and are documented on their respective developer
sites:

- Facebook: <http://developers.facebook.com/docs/authentication/permissions/>
- GitHub: <http://developer.github.com/v3/oauth/#scopes>
- Google: <https://developers.google.com/identity/protocols/googlescopes>
- Meetup: <http://www.meetup.com/meetup_api/auth/#oauth2-scopes>
- Twitter, Weibo, Meteor developer accounts: `requestPermissions` currently not supported

External login services typically require registering and configuring
your application before use. The easiest way to do this is with the
[`accounts-ui` package](../packages/accounts-ui.md) which presents a step-by-step guide
to configuring each service. However, the data can be also be entered
manually in the `ServiceConfiguration.configurations` collection, which
is exported by the `service-configuration` package.

## Configuring Services {#service-configuration}

First, add the service configuration package:

```bash
meteor add service-configuration
```

Then, inside the server of your app (this example is for the Weebo service), import `ServiceConfiguration`:

```js
import { ServiceConfiguration } from "meteor/service-configuration";
ServiceConfiguration.configurations.upsert(
  { service: "weibo" },
  {
    $set: {
      loginStyle: "popup",
      clientId: "1292962797", // See table below for correct property name!
      secret: "75a730b58f5691de5522789070c319bc",
    },
  }
);
```

Since Meteor 2.7 you no longer need to manually set the configuration and instead can use Meteor settings by setting your services under `Meteor.settings.packages.service-configuration.<service>`. All the properties can be set under the service and will be added to the database as is, so make sure that they are correct. For the example above, the settings would look like:

```json
{
  "packages": {
    "service-configuration": {
      "weibo": {
        "loginStyle": "popup",
        "clientId": "1292962797",
        "secret": "75a730b58f5691de5522789070c319bc"
      }
    }
  }
}
```

The correct property name to use for the API identifier (i.e. `clientId` in the above example) depends on the login service being used, so be sure to use the correct one:

| Property Name | Services                                                 |
| ------------- | -------------------------------------------------------- |
| `appId`       | Facebook                                                 |
| `clientId`    | Github, Google, Meetup, Meteor Developer Accounts, Weibo |
| `consumerKey` | Twitter                                                  |

Additionally, each external service has its own login provider package and login function. For
example, to support GitHub login, run the following in your terminal:

```bash
meteor add accounts-github
```

and use the `Meteor.loginWithGithub` function:

```js
import { Meteor } from "meteor/meteor";
Meteor.loginWithGithub(
  {
    requestPermissions: ["user", "public_repo"],
  },
  (error) => {
    if (error) {
      Session.set("errorMessage", error.reason || "Unknown error");
    }
  }
);
```

Login service configuration is sent from the server to the client over DDP when
your app starts up; you may not call the login function until the configuration
is loaded. The function `Accounts.loginServicesConfigured()` is a reactive data
source that will return true once the login service is configured; you should
not make login buttons visible or active until it is true.

Ensure that your [`$ROOT_URL`](./meteor.md#Meteor-absoluteUrl) matches the authorized
domain and callback URL that you configure with the external service (for
instance, if you are running Meteor behind a proxy server, `$ROOT_URL` should be
the externally-accessible URL, not the URL inside your proxy).

## Manual service configuration {#manual-service-configuration}

You can use `Accounts.loginServiceConfiguration` to view and edit the settings collection:

```js
import { Accounts } from "meteor/accounts-base";
Accounts.loginServiceConfiguration.find();
```

## Popup versus redirect flow {#popup-vs-redirect-flow}

When configuring OAuth login with a provider (such as Facebook or Google), Meteor lets you choose a popup- or redirect-based flow. In a popup-based flow, when a user logs in, they will be prompted to login at the provider in a popup window. In a redirect-based flow, the user's whole browser window will be redirected to the login provider, and the window will redirect back to your app when the login is completed.

You can also pick which type of login to do by passing an option to [`Meteor.loginWith<ExternalService>`](#Meteor-loginWith%3CExternalService%3E)

Usually, the popup-based flow is preferable because the user will not have to reload your whole app at the end of the login flow. However, the popup-based flow requires browser features such as `window.close` and `window.opener` that are not available in all mobile environments. In particular, we recommend using `Meteor.loginWith<ExternalService>({ loginStyle: 'redirect' })` in the following environments:

- Inside UIWebViews (when your app is loaded inside a mobile app)
- In Safari on iOS8 (`window.close` is not supported due to a bug)

<ApiBox name="currentUser" />

<ApiBox name="loggingIn" />

<ApiBox name="Accounts.ui.config" hasCustomExample/>

Example:

```js
import { Accounts } from "meteor/accounts-base";

Accounts.ui.config({
  requestPermissions: {
    facebook: ["user_likes"],
    github: ["user", "repo"],
  },
  requestOfflineToken: {
    google: true,
  },
  passwordSignupFields: "USERNAME_AND_OPTIONAL_EMAIL",
});
```

Since Meteor 2.7 you can configure these in your Meteor settings under `Meteor.settings.public.packages.accounts-ui-unstyled`.

## Multi-server {#multi-server}

The `accounts-base` package exports two constructors, called
`AccountsClient` and `AccountsServer`, which are used to create the
`Accounts` object that is available on the client and the server,
respectively.

This predefined `Accounts` object (along with similar convenience methods
of `Meteor`, such as [`Meteor.logout`](#Meteor-logout)) is sufficient to
implement most accounts-related logic in Meteor apps. Nevertheless, these
two constructors can be instantiated more than once, to create multiple
independent connections between different accounts servers and their
clients, in more complicated authentication situations.

<ApiBox name="AccountsCommon"/>

The `AccountsClient` and `AccountsServer` classes share a common
superclass, `AccountsCommon`. Methods defined on
`AccountsCommon.prototype` will be available on both the client and the
server, via the predefined `Accounts` object (most common) or any custom
`accountsClientOrServer` object created using the `AccountsClient` or
`AccountsServer` constructors (less common).

Here are a few of those methods:

<ApiBox name="AccountsCommon#userId" instanceName="accountsCommon"/>

<ApiBox name="AccountsCommon#user" instanceName="accountsCommon"/>

<ApiBox name="AccountsCommon#config" instanceName="accountsCommon"/>

From Meteor 2.5 you can set these in your Meteor settings under `Meteor.settings.packages.accounts-base`. Note that due to the nature of settings file you won't be able to set parameters that require functions.

<ApiBox name="AccountsCommon#onLogin" instanceName="accountsCommon"/>

See description of [AccountsCommon#onLoginFailure](#AccountsCommon-onLoginFailure)
for details.

<ApiBox name="AccountsCommon#onLoginFailure" instanceName="accountsCommon"/>

Either the `onLogin` or the `onLoginFailure` callbacks will be called
for each login attempt. The `onLogin` callbacks are called after the
user has been successfully logged in. The `onLoginFailure` callbacks are
called after a login attempt is denied.

These functions return an object with a single method, `stop`. Calling
`stop()` unregisters the callback.

On the server, the callbacks get a single argument, the same attempt info
object as [`validateLoginAttempt`](#AccountsServer-validateLoginAttempt). On the
client, the callback argument is an object containing a single `error`
property set to the `Error`-object which was received from the failed login
attempt.

<ApiBox name="AccountsCommon#onLogout" instanceName="accountsCommon" hasCustomExample/>

On the server, the `func` callback receives a single argument with the object below. On the
client, no arguments are passed.

```js
import { AccountsCommon } from "meteor/accounts-base";
const options = {
  //...
};
const accountsCommon = new AccountsCommon(options);

accountsCommon.onLogout(({ user, connection, collection }) => {
  console.log(user);
  //        ˆˆˆˆˆˆ The Meteor user object of the user which just logged out
  console.log(connection);
  //        ˆˆˆˆˆˆ The connection object the request came in on. See
  //               `Meteor.onConnection` for details.

  console.log(collection);
  //        ˆˆˆˆˆˆ The `collection` The name of the Mongo.Collection or the
  //               Mongo.Collection object to hold the users.
});
```

<ApiBox name="AccountsClient"/>

At most one of `options.connection` and `options.ddpUrl` should be
provided in any instantiation of `AccountsClient`. If neither is provided,
`Meteor.connection` will be used as the `.connection` property of the
`AccountsClient` instance.

Note that `AccountsClient` is currently available only on the client, due
to its use of browser APIs such as `window.localStorage`. In principle,
though, it might make sense to establish a client connection from one
server to another remote accounts server. Please [let us
know](https://github.com/meteor/meteor/wiki/Contributing-to-Meteor#feature-requests)
if you find yourself needing this server-to-server functionality.

These methods are defined on `AccountsClient.prototype`, and are thus
available only on the client:

<ApiBox name="AccountsClient#loggingIn" instanceName="accountsClient"/>

<ApiBox name="AccountsClient#logout" instanceName="accountsClient"/>

<ApiBox name="AccountsClient#logoutOtherClients" instanceName="accountsClient"/>

<ApiBox name="AccountsServer"/>

These methods are defined on `AccountsServer.prototype`, and are thus
available only on the server:

<ApiBox name="AccountsServer#validateNewUser" instanceName="accountsServer"/>

This can be called multiple times. If any of the functions return `false` or
throw an error, the new user creation is aborted. To set a specific error
message (which will be displayed by [`accounts-ui`](../packages/accounts-ui.md)), throw a new
[`Meteor.Error`](./meteor#meteor-api).

Example:

```js
import { Accounts } from "meteor/accounts-base";

// Validate username, sending a specific error message on failure.
Accounts.validateNewUser((user) => {
  if (user.username && user.username.length >= 3) {
    return true;
  } else {
    throw new Meteor.Error(403, "Username must have at least 3 characters");
  }
});

// Validate username, without a specific error message.
Accounts.validateNewUser((user) => {
  return user.username !== "root";
});
```

If the user is being created as part of a login attempt from a client (eg,
calling [`Accounts.createUser`](#Accounts-createUser) from the client, or
[logging in for the first time with an external
service](#meteor_loginwithexternalservice)), these callbacks are called _before_
the [`Accounts.validateLoginAttempt`](#Accounts-validateLoginAttempt)
callbacks. If these callbacks succeed but those fail, the user will still be
created but the connection will not be logged in as that user.

<ApiBox name="AccountsServer#onCreateUser" instanceName="accountsServer" hasCustomExample/>

Use this when you need to do more than simply accept or reject new user
creation. With this function you can programatically control the
contents of new user documents.

The function you pass will be called with two arguments: `options` and
`user`. The `options` argument comes
from [`Accounts.createUser`](#Accounts-createUser) for
password-based users or from an external service login flow. `options` may come
from an untrusted client so make sure to validate any values you read from
it. The `user` argument is created on the server and contains a
proposed user object with all the automatically generated fields
required for the user to log in, including a temporary `_id` (the final _id is
generated upon document insertion and not available in this function).

The function should return the user document (either the one passed in or a
newly-created object) with whatever modifications are desired. The returned
document is inserted directly into the [`Meteor.users`](#Meteor-users) collection.

The default create user function simply copies `options.profile` into
the new user document. Calling `onCreateUser` overrides the default
hook. This can only be called once.

Example:

```js
import { Accounts } from "meteor/accounts-base";
// Support for playing D&D: Roll 3d6 for dexterity.
Accounts.onCreateUser((options, user) => {
  const customizedUser = Object.assign(
    {
      dexterity: _.random(1, 6) + _.random(1, 6) + _.random(1, 6),
    },
    user
  );

  // We still want the default hook's 'profile' behavior.
  if (options.profile) {
    customizedUser.profile = options.profile;
  }

  return customizedUser;
});
```

<ApiBox name="AccountsServer#validateLoginAttempt" instanceName="accountsServer" hasCustomExample/>

Call `validateLoginAttempt` with a callback to be called on login
attempts. It returns an object with a single method, `stop`. Calling
`stop()` unregisters the callback.

When a login attempt is made, the registered validate login callbacks
are called with a single argument, you can check the example:

```js
import { AccountsServer } from "meteor/accounts-base";
const options = {
  //...
};
const accountsServer = new AccountsServer(options);

accountsServer.validateLoginAttempt(
  ({
    type, // String
    allowed, // Boolean
    error, // Error
    user, // Object
    connection, // Object
    collection, // Object
    methodName, // String
    methodArguments, // Array<String>
  }) => {
    console.log(type);
    //        ˆˆˆˆˆˆ   The service name, such as "password" or "twitter".

    console.log(allowed);
    //        ˆˆˆˆˆˆ   Whether this login is allowed and will be successful (if not aborted
    //                 by any of the validateLoginAttempt callbacks). False if the login
    //                 will not succeed (for example, an invalid password or the login was
    //                 aborted by a previous validateLoginAttempt callback).

    console.log(error);
    //        ˆˆˆˆˆˆ   When `allowed` is false, the exception describing why the login
    //                 failed. It will be a `Meteor.Error` for failures reported to the
    //                 user (such as invalid password), and can be a another kind of
    //                 exception for internal errors.

    console.log(user);
    //        ˆˆˆˆˆˆ   When it is known which user was attempting to login,
    //                 the Meteor user object. This will always be present for successful logins.

    console.log(connection);
    //            ˆˆˆˆˆˆ The `connection` object the request came in on. See
    //                   [`Meteor.onConnection`](#meteor_onconnection) for details.

    console.log(collection);
    //            ˆˆˆˆˆˆ The `collection` The name of the Mongo.Collection or the
    //                   Mongo.Collection object to hold the users.

    console.log(methodName);
    //            ˆˆˆˆˆˆ The name of the Meteor method being used to login.
    //                   For example, "login", "loginWithPassword", or "loginWith<ExternalService>".

    console.log(methodArguments);
    //            ˆˆˆˆˆˆ An array of the arguments passed to the login method.
    //                   For example, `["username", "password"]`
  }
);
```

A validate login callback must return a truthy value for the login to
proceed. If the callback returns a falsy value or throws an
exception, the login is aborted. Throwing a `Meteor.Error` will
report the error reason to the user.

All registered validate login callbacks are called, even if one of the callbacks
aborts the login. The later callbacks will see the `allowed` field set to
`false` since the login will now not be successful. This allows later callbacks
to override an error from a previous callback; for example, you could override
the "Incorrect password" error with a different message.

Validate login callbacks that aren't explicitly trying to override a previous
error generally have no need to run if the attempt has already been determined
to fail, and should start with

```js
if (!attempt.allowed) {
  return false;
}
```

<ApiBox name="AccountsServer#beforeExternalLogin" instanceName="accountsServer"  hasCustomExample/>

Use this hook if you need to validate that user from an external service should
be allowed to login or create account.

```js
import { AccountsServer } from "meteor/accounts-base";
const options = {
  //...
};
const accountsServer = new AccountsServer(options);

accountsServer.beforeExternalLogin(({ type, data, user }) => {
  console.log(type);
  //       ˆˆˆˆˆˆ The service name, such as "google" or "twitter". Is a String

  console.log(data);
  //       ˆˆˆˆˆˆ Data retrieved from the service (eg: email, name, etc)
  //              Is an Object.

  console.log(user);
  //       ˆˆˆˆˆˆ If user was found in the database that matches the criteria from the service,
  //              their data will be provided here. Is an Object.
});
```

You should return a `Boolean` value, `true` if the login/registration should
proceed or `false` if it should terminate. In case of termination
the login attempt will throw an error `403`, with the message: `Login forbidden`.

<ApiBox name="AccountsServer#setAdditionalFindUserOnExternalLogin" hasCustomExample instanceName="accountsServer"/>

When allowing your users to authenticate with an external service, the process will
eventually call `Accounts.updateOrCreateUserFromExternalService`. By default, this
will search for a user with the `service.<servicename>.id`, and if not found will
create a new user. As that is not always desirable, you can use this hook as an
escape hatch to look up a user with a different selector, probably by `emails.address` or `username`. Note the function will only be called if no user was found with the
`service.<servicename>.id` selector.

The function will be called with a single argument, the info object:

```js
import { AccountsServer } from "meteor/accounts-base";
const options = {
  //...
};
const accountsServer = new AccountsServer(options);

accountsServer.setAdditionalFindUserOnExternalLogin(
  ({ serviceName, serviceData, options }) => {
    // serviceName: String
    //   The external service name, such as "google" or "twitter".
    // serviceData: Object
    //   The data returned by the service oauth request.
    // options: Object
    //   An optional arugment passed down from the oauth service that may contain
    //   additional user profile information. As the data in `options` comes from an
    //   external source, make sure you validate any values you read from it.
  }
);
```

The function should return either a user document or `undefined`. Returning a user
will result in the populating the `service.<servicename>` in your user document,
while returning `undefined` will result in a new user account being created.
If you would prefer that a new account not be created, you could throw an error
instead of returning.

Example:

```js
// If a user has already been created, and used their Google email, this will
// allow them to sign in with the Meteor.loginWithGoogle method later, without
// creating a new user.
Accounts.setAdditionalFindUserOnExternalLogin(
  ({ serviceName, serviceData }) => {
    if (serviceName === "google") {
      // Note: Consider security implications. If someone other than the owner
      // gains access to the account on the third-party service they could use
      // the e-mail set there to access the account on your app.
      // Most often this is not an issue, but as a developer you should be aware
      // of how bad actors could play.
      return Accounts.findUserByEmail(serviceData.email);
    }
  }
);
```

<ApiBox name="AccountsServer#registerLoginHandler" instanceName="accountsServer"/>

Use this to register your own custom authentication method. This is also used by all of the other inbuilt accounts packages to integrate with the accounts system.

There can be multiple login handlers that are registered. When a login request is made, it will go through all these handlers to find its own handler.

The registered handler callback is called with a single argument, the `options` object which comes from the login method. For example, if you want to login with a plaintext password, `options` could be `{ user: { username: <username> }, password: <password> }`,or `{ user: { email: <email> }, password: <password> }`.

The login handler should return `undefined` if it's not going to handle the login request or else the login result object.

<h2 id="accounts_rate_limit">Rate Limiting</h2>

By default, there are rules added to the [`DDPRateLimiter`](./DDPRateLimiter.md)
that rate limit logins, new user registration and password reset calls to a
limit of 5 requests per 10 seconds per session. These are a basic solution
to dictionary attacks where a malicious user attempts to guess the passwords
of legitimate users by attempting all possible passwords.

These rate limiting rules can be removed by calling
`Accounts.removeDefaultRateLimit()`. Please see the
[`DDPRateLimiter`](./DDPRateLimiter.md) docs for more information.

<ApiBox name="AccountsServer#addDefaultRateLimit" instanceName="accountsServer"/>

<ApiBox name="AccountsServer#removeDefaultRateLimit" instanceName="accountsServer"/>

## Passwords {#passwords}

The `accounts-password` package contains a full system for password-based
authentication. In addition to the basic username and password-based
sign-in process, it also supports email-based sign-in including
address verification and password recovery emails.

### Password encryption and security

Starting from `accounts-passwords:4.0.0`, you can choose which algorithm is used by the Meteor server to store passwords : either [bcrypt](http://en.wikipedia.org/wiki/Bcrypt) or
[Argon2](http://en.wikipedia.org/wiki/Argon2) algorithm. Both are robust and contribute to
protect against embarrassing password leaks if the server's database is
compromised.

Before version 4.0.0, `bcrypt` was the only available option. argon2 has been introduced because it is  considered the most secure option. This algorithm is specifically designed to resist GPU-based brute force attacks. For more details, see the [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html).

As of January 2025, **`bcrypt` is still the default option** to enable a smooth transition. In the future, `argon2` will replace `bcrypt` as default and `bcrypt` option will be deprecated.

Passwords are hashed on the client using **SHA-256** algorithm before being sent to the server. This ensures that sensitive data is never transmitted in plain text. Once received by the server, the hashed value is further encrypted and securely stored in the `Meteor.users` collection.


**About the migration process from `bcrypt` to `argon2`**

The transition from `bcrypt` to `argon2` happens automatically upon user login. If Argon2 encryption is enabled in an existing application, each user's password is re-encrypted during their next successful login.
- Step 1: The password is first validated against the existing `bcrypt` hash.
- Step 2: If authentication succeeds, the password is re-encrypted using `Argon2`.
- Step 3: The new `Argon2` hash replaces the old `bcrypt` hash in the database.


To monitor the migration progress, you can count users still using bcrypt:
```js
const bcryptUsers = await Meteor.users.find({ "services.password.bcrypt": { $exists: true } }).countAsync();
const totalUsers = await Meteor.users.find({ "services.password": { $exists: true } }).countAsync();
console.log("Remaining users to migrate:", bcryptUsers, "/", totalUsers);
```
Once `bcryptUsers` reaches 0, the migration is complete.

**Enabling Argon2 encryption**

To enable Argon2 encryption, you need a small configuration change on the server: 

```js
Accounts.config({
    argon2Enabled: true,
});
```

**Configuring `argon2` parameters**

One enabled, the `accounts-password` package allows customization of Argon2's parameters. The configurable options include:

- `type`: `argon2id` (provides a blend of resistance against GPU and side-channel attacks)
- `timeCost` (default: 2) – This controls the computational cost of the hashing process, affecting both the security level and performance.
- `memoryCost`: 19456 (19 MiB) - The amount of memory used by the algorithm in KiB per thread
- `parallelism`: 1 - The number of threads used by the algorithm

To update the values, use the following configuration:
```js
Accounts.config({
    argon2Enabled: true,
    argon2Type: "argon2id",
    argon2TimeCost: 2,
    argon2MemoryCost: 19456,
    argon2Parallelism: 1,
});
```

Other Argon2 parameters, such as `hashLength`, are kept to default values:
- `hashLength`: 32 bytes - The length of the hash output in bytes

The default values are the minimum [OWASP recommendations for Argon2 parameters](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html#introduction). When updating these values, consider the trade-offs between security and performance on the target infrastructure.

For more information about Argon2's parameters, refer to the [argon2 options documentation](https://github.com/ranisalt/node-argon2/wiki/Options).


### Using passwords

To add password support to your application, run this command in your terminal:

```bash
meteor add accounts-password
```

> In addition to configuring the [`email`](./email.md) package's `MAIL_URL`, it is critical that you set proper values (specifically the `from` address) in [`Accounts.emailTemplates`](#Accounts-emailTemplates) to ensure proper delivery of e-mails!

You can construct your own user interface using the
functions below, or use the [`accounts-ui` package](../packages/accounts-ui.md) to
include a turn-key user interface for password-based sign-in.

<ApiBox name="Accounts.createUser" />

On the client, this function logs in as the newly created user on
successful completion. On the server, it returns the newly created user
id.

On the client, you must pass `password` and at least one of `username` or `email` &mdash; enough information for the user to be able to log in again later. If there are existing users with a username or email only differing in case, `createUser` will fail. The callback's `error.reason` will be `'Username already exists.'` or `'Email already exists.'` In the latter case, the user can then either [login](accounts.html#Meteor-loginWithPassword) or [reset their password](#Accounts-resetPassword).

On the server, you do not need to specify `password`, but the user will not be able to log in until it has a password (eg, set with [`Accounts.setPasswordAsync`](#Accounts-setPasswordAsync)). To create an account without a password on the server and still let the user pick their own password, call `createUser` with the `email` option and then call [`Accounts.sendEnrollmentEmail`](#Accounts-sendEnrollmentEmail). This will send the user an email with a link to set their initial password.

By default the `profile` option is added directly to the new user document. To
override this behavior, use [`Accounts.onCreateUser`](#Accounts-onCreateUser).

This function is only used for creating users with passwords. The external
service login flows do not use this function.

Instead of modifying documents in the [`Meteor.users`](#Meteor-users) collection
directly, use these convenience functions which correctly check for case
insensitive duplicates before updates.

<ApiBox name="Accounts.createUserAsync" />

<ApiBox name="Accounts.createUserVerifyingEmail" />

<ApiBox name="Accounts.setUsername" />

<ApiBox name="Accounts.addEmailAsync" />

By default, an email address is added with `{ verified: false }`. Use
[`Accounts.sendVerificationEmail`](#Accounts-sendVerificationEmail) to send an
email with a link the user can use to verify their email address.

<ApiBox name="Accounts.removeEmail" />

<ApiBox name="Accounts.replaceEmailAsync" />

<ApiBox name="Accounts.verifyEmail" />

If the user trying to verify the email has 2FA enabled, this error will be thrown:

- "Email verified, but user not logged in because 2FA is enabled [2fa-enabled]": No longer signing in the user automatically if the user has 2FA enabled.

This function accepts tokens passed into the callback registered with
[`Accounts.onEmailVerificationLink`](#Accounts-onEmailVerificationLink).

<ApiBox name="Accounts.findUserByUsername" />

<ApiBox name="Accounts.findUserByEmail" />

Use the below functions to initiate password changes or resets from the server
or the client.

<ApiBox name="Accounts.changePassword" />

<ApiBox name="Accounts.forgotPassword" />

This triggers a call
to [`Accounts.sendResetPasswordEmail`](#Accounts-sendResetPasswordEmail)
on the server. When the user visits the link in this email, the callback
registered with [`Accounts.onResetPasswordLink`](#Accounts-onResetPasswordLink)
will be called.

If you are using the [`accounts-ui` package](../packages/accounts-ui.md), this is handled
automatically. Otherwise, it is your responsibility to prompt the user for the
new password and call `resetPassword`.

<ApiBox name="Accounts.resetPassword" />

This function accepts tokens passed into the callbacks registered with
[`AccountsClient#onResetPasswordLink`](#Accounts-onResetPasswordLink) and
[`Accounts.onEnrollmentLink`](#Accounts-onEnrollmentLink).

If the user trying to reset the password has 2FA enabled, this error will be thrown:

- "Changed password, but user not logged in because 2FA is enabled [2fa-enabled]": No longer signing in the user automatically if the user has 2FA enabled.

<ApiBox name="Accounts.setPasswordAsync" />

<ApiBox name="Accounts.sendResetPasswordEmail" />

When the user visits the link in this email, the callback registered with
[`AccountsClient#onResetPasswordLink`](#Accounts-onResetPasswordLink) will be called.

To customize the contents of the email, see
[`Accounts.emailTemplates`](#Accounts-emailTemplates).

<ApiBox name="Accounts.sendEnrollmentEmail" />

When the user visits the link in this email, the callback registered with
[`Accounts.onEnrollmentLink`](#Accounts-onEnrollmentLink) will be called.

To customize the contents of the email, see
[`Accounts.emailTemplates`](#Accounts-emailTemplates).

<ApiBox name="Accounts.sendVerificationEmail" />

When the user visits the link in this email, the callback registered with
[`Accounts.onEmailVerificationLink`](#Accounts-onEmailVerificationLink) will
be called.

To customize the contents of the email, see
[`Accounts.emailTemplates`](#Accounts-emailTemplates).

<ApiBox name="Accounts.onResetPasswordLink" />

<ApiBox name="Accounts.onEnrollmentLink" />

<ApiBox name="Accounts.onEmailVerificationLink" />

<ApiBox name="Accounts.emailTemplates" />

This is an `Object` with several fields that are used to generate text/html
for the emails sent by `sendResetPasswordEmail`, `sendEnrollmentEmail`,
and `sendVerificationEmail`.

Set the fields of the object by assigning to them:

- `from`: (**required**) A `String` with an [RFC5322](http://tools.ietf.org/html/rfc5322) From
  address. By default, the email is sent from `no-reply@example.com`. **If you
  want e-mails to send correctly, this should be changed to your own domain
  as most e-mail providers will reject mail sent from `example.com`.**
- `siteName`: The public name of your application. Defaults to the DNS name of
  the application (eg: `awesome.meteor.com`).
- `headers`: An `Object` for custom email headers as described in
  [`Email.send`](./email.md#Email-send).
- `resetPassword`: An `Object` with the fields:
- `from`: A `Function` used to override the `from` address defined
  by the `emailTemplates.from` field.
- `subject`: A `Function` that takes a user object and returns
  a `String` for the subject line of a reset password email.
- `text`: An optional `Function` that takes a user object and a url, and
  returns the body text for a reset password email.
- `html`: An optional `Function` that takes a user object and a
  url, and returns the body html for a reset password email.
- `enrollAccount`: Same as `resetPassword`, but for initial password setup for
  new accounts.
- `verifyEmail`: Same as `resetPassword`, but for verifying the users email
  address.

Example:

```js
import { Accounts } from "meteor/accounts-base";

Accounts.emailTemplates.siteName = "AwesomeSite";
Accounts.emailTemplates.from = "AwesomeSite Admin <accounts@example.com>";

Accounts.emailTemplates.enrollAccount.subject = (user) => {
  return `Welcome to Awesome Town, ${user.profile.name}`;
};

Accounts.emailTemplates.enrollAccount.text = (user, url) => {
  return (
    "You have been selected to participate in building a better future!" +
    " To activate your account, simply click the link below:\n\n" +
    url
  );
};

Accounts.emailTemplates.resetPassword.from = () => {
  // Overrides the value set in `Accounts.emailTemplates.from` when resetting
  // passwords.
  return "AwesomeSite Password Reset <no-reply@example.com>";
};
Accounts.emailTemplates.verifyEmail = {
  subject() {
    return "Activate your account now!";
  },
  text(user, url) {
    return `Hey ${user}! Verify your e-mail by following this link: ${url}`;
  },
};
```

<h3 id="enabling-2fa">Enable 2FA for this package</h3>

You can add 2FA to your login flow by
using the package [accounts-2fa](../packages/accounts-2fa.md).
You can find an example showing how this would look like [here](../packages/accounts-2fa.md#working-with-accounts-password).

---

---
url: /packages/accounts-2fa.md
---
# accounts-2fa

This package allows you to provide a way for your users to enable 2FA on their accounts, using an authenticator app such as Google Authenticator, or 1Password. When the user is logged in on your app, they will be able to generate a new QR code and read this code on the app they prefer. After that, they'll start receiving their codes. Then, they can finish enabling 2FA on your app, and every time they try to log in to your app, you can redirect them to a place where they can provide a code they received from the authenticator.

To provide codes that are exactly compatible with all other Authenticator apps and services that implements TOTP, this package uses [node-2fa](https://www.npmjs.com/package/node-2fa) which works on top of [notp](https://github.com/guyht/notp), **that** implements TOTP ([RFC 6238](https://www.ietf.org/rfc/rfc6238.txt)) (the Authenticator standard), which is based on HOTP ([RFC 4226](https://www.ietf.org/rfc/rfc4226.txt)).

> This package is meant to be used with [`accounts-password`](../api/accounts.md#passwords) or [`accounts-passwordless`](./accounts-passwordless.md), so if you don't have either of those in your project, you'll need to add one of them. In the future, we want to enable the use of this package with other login methods, our oauth methods (Google, GitHub, etc...).

## 2FA Activation Flow {#activating-2fa}

The first step, in order to enable 2FA, is to generate a QR code so that the user can scan it in an authenticator app and start receiving codes.

<ApiBox name="Accounts.generate2faActivationQrCode" from="accounts-base"/>

Receives an `appName` which is the name of your app that will show up when the user scans the QR code. Also, a callback called, on success, with a QR code in SVG format, a QR secret, and the URI that can be used to activate the 2FA in an authenticator app,
or a single `Error` argument on failure.

On success, this function will also add an object to the logged user's services object containing the QR secret:

```js
services: {
  ...
  twoFactorAuthentication: {
    secret: "***"
  }
}
```

Here it's an example on how to call this function:

```js
import { Buffer } from "buffer";
import { Accounts } from 'meteor/accounts-base';


// component
const [qrCode, setQrCode] = useState(null);


<button
  onClick={() => {
    Accounts.generate2faActivationQrCode("My app name", (err, result) => {
      if (err) {console.error("...", err);return;}
      const { svg, secret, uri } = result;
      /*
        the svg can be converted to base64, then be used like:
         <img
            width="200"
            src={`data:image/svg+xml;base64,${qrCode}`}
         />
      */
      setQrCode(Buffer.from(svg).toString('base64'));
    })
  }}
>
  Generate a new code
</button>
```

This method can fail throwing the following error:

- "The 2FA is activated. You need to disable the 2FA first before trying to generate a new activation code [2fa-activated]" if trying to generate an activation when the user already have 2FA enabled.

At this point, the 2FA won't be activated just yet. Now that the user has access to the codes generated by their authenticator app, you can call the function `Accounts.enableUser2fa`:

<ApiBox name="Accounts.enableUser2fa" from="accounts-base"/>

It should be called with a code that the users will receive from the authenticator app once they read the QR code. The callback is called with a single `Error` argument on failure. If the code provided is correct, a `type` will be added to the user's `twoFactorAuthentication` object and now 2FA is considered enabled:

```js
services: {
  ...
  twoFactorAuthentication: {
    type: "otp",
    secret: "***",
  }
}
```

To verify whether or not a user has 2FA enabled, you can call the function `Accounts.has2faEnabled`:

<ApiBox name="Accounts.has2faEnabled" from="accounts-base"/>

This function must be called when the user is logged in.


## Disabling 2FA {#disabling-2fa}

To disable 2FA for a user use this method:

<ApiBox name="Accounts.disableUser2fa" from="accounts-base"/>

To call this function the user must be already logged in.

## Log in with 2FA {#log-in-with-2fa}

Now that you have a way to allow your users to enable 2FA on their accounts, you can create a login flow based on that.

As said at the beginning of this guide, this package is currently working with two other packages: `accounts-password` and `accounts-passwordless`. Below there is an explanation on how to use this package with them.


## Working with accounts-password {#working-with-accounts-password}

When calling the function `Meteor.loginWithPassword`, if the 2FA is enabled for the user, an error will be returned to the callback, so you can redirect the user to a place where they can provide a code.

As an example:

```js
<button
  onClick={() => {
    Meteor.loginWithPassword(username, password, (error) => {
      if (error) {
        if (error.error === "no-2fa-code") {
          // send user to a page or show a component
          // where they can provide a 2FA code
          setShouldAskCode(true);
          return;
        }
        console.error("Error trying to log in (user without 2fa)", error);
      }
    });
  }}
>
  Login
</button>
```

If the 2FA is not enabled, the user will be logged in normally.

The function you will need to call now to allow the user to login is `Meteor.loginWithPasswordAnd2faCode`:

<ApiBox name="Meteor.loginWithPasswordAnd2faCode"/>

Now you will be able to receive a code from the user and this function will verify if the code is valid. If it is, the user will be logged in.

So the call of this function should look something like this:

```js
<button
  onClick={() => {
    Meteor.loginWithPasswordAnd2faCode(username, password, code, (error) => {
      if (error) {
        console.error("Error trying to log in (user with 2fa)", error);
      }
    });
  }}
>
  Validate and log in
</button>
```

This method can fail throwing one of the following errors:

- "2FA code must be informed [no-2fa-code]" if a 2FA code was not provided.
- "Invalid 2FA code [invalid-2fa-code]" if the provided 2FA code is invalid.


## Working with accounts-passwordless {#working-with-accounts-passwordless}

Following the same logic from the previous package, if the 2FA is enabled, an error will be returned to the callback of the function
[`Meteor.passwordlessLoginWithToken`](./accounts-passwordless.md#Meteor-passwordlessLoginWithToken),
 then you can redirect the user to a place where they can provide a code.

Here is an example:

```js
<button
  onClick={() => {
    // logging in just with token
    Meteor.passwordlessLoginWithToken(email, token, (error) => {
      if (error) {
        if (error.error === "no-2fa-code") {
          // send user to a page or show a component
          // where they can provide a 2FA code
          setShouldAskCode(true);
          return;
        }
        console.error("Error verifying token", error);
      }
    });
  }}
>
  Validate token
</button>
```

Now you can call the function `Meteor.passwordlessLoginWithTokenAnd2faCode` that will allow you to provide a selector, token, and 2FA code:

<ApiBox name="Meteor.passwordlessLoginWithTokenAnd2faCode"/>

This method can fail throwing one of the following errors:

- "2FA code must be informed [no-2fa-code]" if a 2FA code was not provided.
- "Invalid 2FA code [invalid-2fa-code]" if the provided 2FA code is invalid.

## Integrating an Authentication Package with accounts-2fa {#integrating-auth-package}

To integrate this package with any other existing Login method, it's necessary following two steps:

1 - For the client, create a new method from your current login method. So for example, from the method `Meteor.loginWithPassword` we created a new one called `Meteor.loginWithPasswordAnd2faCode`, and the only difference between them is that the latest one receives one additional parameter, the 2FA code, but we call the same function on the server side.

2 - For the server, inside the function that will log the user in, you verify if the function `Accounts._check2faEnabled` exists, and if yes, you call it providing the user object you want to check if the 2FA is enabled, and if either of these statements are false, you proceed with the login flow. This function exists only when the package `accounts-2fa` is added to the project.

If both statements are true, and the login validation succeeds, you verify if a code was provided: if not, throw an error; if it was provided, verify if the code is valid by calling the function `Accounts._isTokenValid`. if `Accounts._isTokenValid` returns false, throw an error.

Here it's an example:

```js
const result = validateLogin();
if (!result.error && Accounts._check2faEnabled?.(user)) {
  if (!code) {
    Accounts._handleError("2FA code must be informed.");
  }
  if (
    !Accounts._isTokenValid(user.services.twoFactorAuthentication.secret, code)
  ) {
    Accounts._handleError("Invalid 2FA code.");
  }
}

return result;
```

---

---
url: /packages/accounts-ui.md
---
# accounts-ui

A turn-key user interface for Meteor Accounts.

To add Accounts and a set of login controls to an application, add the
`accounts-ui` package and at least one login provider package:
`accounts-password`, `accounts-facebook`, `accounts-github`,
`accounts-google`, `accounts-twitter`, or `accounts-weibo`.

Then simply add the <span v-pre>`{{> loginButtons}}`</span> helper to an HTML file. This
will place a login widget on the page. If there is only one provider configured
and it is an external service, this will add a login/logout button. If you use
`accounts-password` or use multiple external login services, this will add
a "Sign in" link which opens a dropdown menu with login options. If you plan to
position the login dropdown in the right edge of the screen, use
<span v-pre>`{{> loginButtons align="right"}}`</span> in order to get the dropdown to lay
itself out without expanding off the edge of the screen.

To configure the behavior of <span v-pre>`{{> loginButtons}}`</span>, use
[`Accounts.ui.config`](../api/accounts.md#loggingIn).

`accounts-ui` also includes modal popup dialogs to handle links from
[`sendResetPasswordEmail`](../api/accounts.md#Accounts-sendResetPasswordEmail),
[`sendVerificationEmail`](../api/accounts.md#Accounts-sendVerificationEmail),
and [`sendEnrollmentEmail`](../api/accounts.md#Accounts-sendEnrollmentEmail). These
do not have to be manually placed in HTML: they are automatically activated
when the URLs are loaded.

If you want to control the look and feel of your accounts system a little more, we recommend reading the [useraccounts](http://guide.meteor.com/accounts.html#useraccounts) section of the Meteor Guide.

---

---
url: /packages/appcache.md
---
# AppCache

> This package has been deprecated since [applicationCache](https://developer.mozilla.org/en-US/docs/Web/API/Window/applicationCache), which this package relies on, has been deprecated and is not available on the latest browsers. Plaese consider using [Service Worker](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API) as an replacement.

The `appcache` package stores the static parts of a Meteor application
(the client side Javascript, HTML, CSS, and images) in the browser's
[application cache](https://en.wikipedia.org/wiki/AppCache). To enable
caching simply add the `appcache` package to your project.

* Once a user has visited a Meteor application for the first time and
  the application has been cached, on subsequent visits the web page
  loads faster because the browser can load the application out of the
  cache without contacting the server first.

* Hot code pushes are loaded by the browser in the background while the
  app continues to run.  Once the new code has been fully loaded the
  browser is able to switch over to the new code quickly.

* The application cache allows the application to be loaded even when
  the browser doesn't have an Internet connection, and so enables using
  the app offline.

(Note however that the `appcache` package by itself doesn't make
*data* available offline: in an application loaded offline, a Meteor
Collection will appear to be empty in the client until the Internet
becomes available and the browser is able to establish a DDP
connection).

To turn AppCache off for specific browsers use:

```js
Meteor.AppCache.config({
  chrome: false,
  firefox: false
});
```

The supported browsers that can be enabled or disabled include, but are
not limited to, `android`, `chrome`, `chromium`, `chromeMobileIOS`,
`firefox`, `ie`, `mobileSafari` and `safari`.

Browsers limit the amount of data they will put in the application
cache, which can vary due to factors such as how much disk space is
free.  Unfortunately if your application goes over the limit rather
than disabling the application cache altogether and running the
application online, the browser will instead fail that particular
*update* of the cache, leaving your users running old code.

Thus it's best to keep the size of the cache below 5MB.  The
`appcache` package will print a warning on the Meteor server console
if the total size of the resources being cached is over 5MB.

Starting from `appcache@1.2.5`, if you need more advanced logic
to enable/disable the cache, you can use the `enableCallback` option
that is evaluated on a per-request basis. For example:

```js
// Enable offline mode using a value from database and certificate validation
Meteor.AppCache.config({
  // This option is available starting from appcache@1.2.4
  enableCallback: () => {
    if (!getSettingsFromDb("public.appcache_enabled")) {
      return false;
    }

    const validation = validateClientCert({
      clientCertPayload: req.headers["x-client-cert"],
      url: req.url.href,
    });

    return validation.passed;
  },
});
```

If you have files too large to fit in the cache you can disable
caching by URL prefix.  For example,

```js
Meteor.AppCache.config({ onlineOnly: ['/online/'] });
```

causes files in your `public/online` directory to not be cached, and
so they will only be available online.  You can then move your large
files into that directory and refer to them at the new URL:

```html
<img src="/online/bigimage.jpg">
```

If you'd prefer not to move your files, you can use the file names
themselves as the URL prefix:

```js
Meteor.AppCache.config({
  onlineOnly: [
    '/bigimage.jpg',
    '/largedata.json'
  ]
});
```

though keep in mind that since the exclusion is by prefix (this is a
limitation of the application cache manifest), excluding
`/largedata.json` will also exclude such URLs as
`/largedata.json.orig` and `/largedata.json/file1`.

For more information about how Meteor interacts with the application
cache, see the
[AppCache page](https://github.com/meteor/meteor/wiki/AppCache)
in the Meteor wiki.

---

---
url: /tutorials/application-structure/index.md
---
# Application Structure

After reading this article, you'll know:

1. How a Meteor application compares to other types of applications in terms of file structure.
2. How to organize your application both for small and larger applications.
3. How to format your code and name the parts of your application in consistent and maintainable ways.

[[toc]]

## Universal JavaScript

Meteor is a *full-stack* framework for building JavaScript applications. This means Meteor applications differ from most applications in that they include code that runs on the client, inside a web browser or Cordova mobile app, code that runs on the server, inside a [Node.js](http://nodejs.org/) container, and _common_ code that runs in both environments. The [Meteor build tool](https://guide.meteor.com/build-tool) allows you to specify what JavaScript code, including any supporting UI templates, CSS rules, and static assets, to run in each environment using a combination of ES2015 `import` and `export` and the Meteor build system [default file load order](#default-file-load-order) rules.

### ES2015 modules

As of version 1.3, Meteor ships with full support for [ES2015 modules](https://developer.mozilla.org/en/docs/web/javascript/reference/statements/import). The ES2015 module standard is the replacement for [CommonJS](http://requirejs.org/docs/commonjs.html) and [AMD](https://github.com/amdjs/amdjs-api), which are commonly used JavaScript module format and loading systems.

In ES2015, you can make variables available outside a file using the `export` keyword. To use the variables somewhere else, you must `import` them using the path to the source. Files that export some variables are called "modules", because they represent a unit of reusable code. Explicitly importing the modules and packages you use helps you write your code in a modular way, avoiding the introduction of global symbols and "action at a distance".

You can read about the module system in detail in the [`modules` package README](https://docs.meteor.com/#/full/modules). This package is automatically included in every new Meteor app as part of the [`ecmascript` meta-package](https://docs.meteor.com/#/full/ecmascript), so most apps won't need to do anything to start using modules right away.

### Introduction to using `import` and `export`

Meteor allows you to `import` not only JavaScript in your application, but also CSS and HTML to control load order:

```js
import '../../api/lists/methods.js';  // import from relative path
import '/imports/startup/client';     // import module with index.js from absolute path
import './loading.html';              // import Blaze compiled HTML from relative path
import '/imports/ui/style.css';       // import CSS from absolute path
```

> For more ways to import styles, see the [Build System](https://guide.meteor.com/build-tool#css-importing) article.

Meteor also supports the standard ES2015 modules `export` syntax:

```js
export const listRenderHold = LaunchScreen.hold();  // named export
export { Todos };                                   // named export
export default Lists;                               // default export
export default new Collection('lists');             // default export
```

### Importing from packages

In Meteor, it is also simple and straightforward to use the `import` syntax to load npm packages on the client or server and access the package's exported symbols as you would with any other module. You can also import from Meteor Atmosphere packages, but the import path must be prefixed with `meteor/` to avoid conflict with the npm package namespace. For example, to import `moment` from npm and `HTTP` from Atmosphere:

```js
import moment from 'moment';          // default import from npm
import { HTTP } from 'meteor/http';   // named import from Atmosphere
```

For more details using `imports` with packages see [Using Packages](../../packages/#using-atmosphere-packages) tutorial.

### Using `require`

In Meteor, `import` statements compile to CommonJS `require` syntax. However, as a convention we encourage you to use `import`.

With that said, in some situations you may need to call out to `require` directly. One notable example is when requiring client or server-only code from a common file. As `import`s must be at the top-level scope, you may not place them within an `if` statement, so you'll need to write code like:

```js
if (Meteor.isClient) {
  require('./client-only-file.js');
}
```

Note that dynamic calls to `require()` (where the name being required can change at runtime) cannot be analyzed correctly and may result in broken client bundles.

If you need to `require` from an ES2015 module with a `default` export, you can grab the export with `require("package").default`.

### Using CoffeeScript

See the Docs: [CoffeeScript](https://docs.meteor.com/packages/coffeescript.html#coffeescript)

```cs
// lists.coffee

export Lists = new Collection 'lists'
```

```cs
import { Lists } from './lists.coffee'
```

## File structure

To fully use the module system and ensure that our code only runs when we ask it to, we recommend that all of your application code should be placed inside the `imports/` directory. This means that the Meteor build system will only bundle and include that file if it is referenced from another file using an `import` (also called "lazy evaluation or loading").

Meteor will load all files outside of any directory named `imports/` in the application using the [default file load order](#default-file-load-order) rules (also called "eager evaluation or loading"). It is recommended that you create exactly two eagerly loaded files, `client/main.js` and `server/main.js`, in order to define explicit entry points for both the client and the server. Meteor ensures that any file in any directory named `server/` will only be available on the server, and likewise for files in any directory named `client/`. This also precludes trying to `import` a file to be used on the server from any directory named `client/` even if it is nested in an `imports/` directory and vice versa for importing client files from `server/`.

These `main.js` files won't do anything themselves, but they should import some _startup_ modules which will run immediately, on client and server respectively, when the app loads. These modules should do any configuration necessary for the packages you are using in your app, and import the rest of your app's code.

### Example directory layout

To start, one can have a look to the [example applications](https://github.com/meteor/examples) provided. They are great examples to follow when structuring your app. 

Below is an overview of an exemple directory structure. You can generate a new app with this structure using the command `meteor create appName --full`. The default frontend is Blaze, but you can change it later. Or use [another create option](https://docs.meteor.com/cli/#meteorcreate)


```sh
imports/
  startup/
    both/
      index.js                 # single entry point to import isomorphic modules for client and server 
    client/
      index.js                 # import client startup through a single index entry point
      routes.js                # set up all routes in the app
    server/
      fixtures.js              # fill the DB with example data on startup
      index.js                 # import server startup through a single index entry point
      register-api.js          # dedicated file to import server code for api

  api/
    lists/                     # a unit of domain logic
      server/
        publications.js        # all list-related publications
        publications.tests.js  # tests for the list publications
      lists.js                 # definition of the Lists collection
      lists.tests.js           # tests for the behavior of that collection
      methods.js               # methods related to lists
      methods.tests.js         # tests for those methods

  ui/
    components/                # all reusable components in the application
                               # can be split by domain if there are many
    layouts/                   # wrapper components for behaviour and visuals
    pages/                     # entry points for rendering used by the router
    stylesheets/               # global stylesheets  

private/                       # to store private assets for the server 
public/                        # to store public assets (pictures)

client/
  main.js                      # client entry point, imports all client code

server/
  main.js                      # server entry point, imports all server code
```

### Structuring imports

Now that we have placed all files inside the `imports/` directory, let's think about how best to organize our code using modules. It makes sense to put all code that runs when your app starts in an `imports/startup` directory. Another good idea is splitting data and business logic from UI rendering code. We suggest using directories called `imports/api` and `imports/ui` for this logical split.

Within the `imports/api` directory, it's sensible to split the code into directories based on the domain that the code is providing an API for --- typically this corresponds to the collections you've defined in your app. For instance in the Todos example app, we have the `imports/api/lists` and `imports/api/todos` domains. Inside each directory we define the collections, publications and methods used to manipulate the relevant domain data. Each API folder typically has different files for isomorphic code and server-specific code. To ensure good isolation, server-specific code is put into a `server` folder. 

> Note: in a larger application, given that the todos themselves are a part of a list, it might make sense to group both of these domains into a single larger "list" module. The Todos example is small enough that we need to separate these only to demonstrate modularity.

Within the `imports/ui` directory it typically makes sense to group files into directories based on the type of UI side code they define, i.e. top level `pages`, wrapping `layouts`, or reusable `components`.

For each module defined above, it makes sense to co-locate the various auxiliary files with the base JavaScript file. For instance, a Blaze UI component should have its template HTML, JavaScript logic, and CSS rules in the same directory. A JavaScript module with some business logic should be co-located with the unit tests for that module.

### Startup files

Some of your code isn't going to be a unit of business logic or UI, it's some setup or configuration code that needs to run in the context of the app when it starts up. In the above example, the `imports/startup/client/routes.js` configures all the routes and then imports *all* other code that is required on the client:   

```js
import { FlowRouter } from 'meteor/ostrio:flow-router-extra';

// Import needed templates
import '../../ui/layouts/body/body.js';
import '../../ui/pages/home/home.js';
import '../../ui/pages/not-found/not-found.js';
```

We then import both of these files in `imports/startup/client/index.js`:

```js
import './routes.js';
```

This makes it easy to then import all the client startup code with a single import as a module from our main eagerly loaded client entry point `client/main.js`:

```js
import '/imports/startup/client';
```

On the server, we use the same technique of importing all the startup code in `imports/startup/server/index.js`:

```js
import './fixtures.js';
import './register-api.js';
```

Our main server entry point `server/main.js` then imports this startup module. You can see that here we don't actually import any variables from these files - we import them so that they execute in this order.

### Importing Meteor "pseudo-globals"

For backwards compatibility Meteor still provides Meteor's global namespacing for the Meteor core package as well as for other Meteor packages you include in your application. You can also still directly call functions such as [`Meteor.publish`](https://docs.meteor.com/api/Meteor#Meteor-publish), as in previous versions of Meteor, without first importing them. However, it is recommended best practice that you first load all the Meteor "pseudo-globals" using the `import { Name } from 'meteor/package'` syntax before using them. For instance:

```js
import { Meteor } from 'meteor/meteor';
import { EJSON } from 'meteor/ejson';
```

## Default file load order

Even though it is recommended that you write your application to use ES2015 modules and the `imports/` directory, Meteor continues to support eager evaluation of files, using these default load order rules, to provide backwards compatibility with applications written for Meteor 1.2 and earlier. For a description of the difference between eager evaluation, lazy evaluation, and lazy loading, please see this Stack Overflow [article](https://stackoverflow.com/a/51158735/219238).

You may combine both eager evaluation and lazy loading using `import` in a single app. Any import statements are evaluated in the order they are listed in a file when that file is loaded and evaluated using these rules.

There are several load order rules. They are *applied sequentially* to all applicable files in the application, in the priority given below:

1. HTML template files are **always** loaded before everything else
2. Files beginning with `main.` are loaded **last**
3. Files inside **any** `lib/` directory are loaded next
4. Files with deeper paths are loaded next
5. Files are then loaded in alphabetical order of the entire path

```js
  nav.html
  main.html
  client/lib/methods.js
  client/lib/styles.js
  lib/feature/styles.js
  lib/collections.js
  client/feature-y.js
  feature-x.js
  client/main.js
```

For example, the files above are arranged in the correct load order. `main.html` is loaded second because HTML templates are always loaded first, even if it begins with `main.`, since rule 1 has priority over rule 2. However, it will be loaded after `nav.html` because rule 2 has priority over rule 5.

`client/lib/styles.js` and `lib/feature/styles.js` have identical load order up to rule 4; however, since `client` comes before `lib` alphabetically, it will be loaded first.

> You can also use [Meteor.startup](https://docs.meteor.com/api/Meteor#Meteor-startup) to control when run code is run on both the server and the client.

### Special directories

By default, any JavaScript files in your Meteor application folder are bundled and loaded on both the client and the server. However, the names of the files and directories inside your project can affect their load order, where they are loaded, and some other characteristics. Here is a list of file and directory names that are treated specially by Meteor:

- **imports**

  Any directory named `imports/` is not loaded anywhere and files must be imported using `import`.

- **node_modules**

  Any directory named `node_modules/` is not loaded anywhere. node.js packages installed into `node_modules` directories must be imported using `import` or by using `Npm.depends` in `package.js`.

- **client**

  Any directory named `client/` is not loaded on the server. Similar to wrapping your code in `if (Meteor.isClient) { ... }`. All files loaded on the client are automatically concatenated and minified when in production mode. In development mode, JavaScript and CSS files are not minified, to make debugging easier. CSS files are still combined into a single file for consistency between production and development, because changing the CSS file's URL affects how URLs in it are processed.

  > HTML files in a Meteor application are treated quite a bit differently from a server-side framework.  Meteor scans all the HTML files in your directory for three top-level elements: `<head>`, `<body>`, and `<template>`.  The head and body sections are separately concatenated into a single head and body, which are transmitted to the client on initial page load.

- **server**

  Any directory named `server/` is not loaded on the client. Similar to wrapping your code in `if (Meteor.isServer) { ... }`, except the client never even receives the code. Any sensitive code that you don't want served to the client, such as code containing passwords or authentication mechanisms, should be kept in the `server/` directory.

  Meteor gathers all your JavaScript files, excluding anything under the `client`, `public`, and `private` subdirectories, and loads them into a Node.js server instance. In Meteor, your server code runs in a single thread per request, not in the asynchronous callback style typical of Node.

- **public**

  All files inside a top-level directory called `public/` are served as-is to the client. When referencing these assets, do not include `public/` in the URL, write the URL as if they were all in the top level. For example, reference `public/bg.png` as `<img src='/bg.png' />`. This is the best place for `favicon.ico`, `robots.txt`, and similar files.

- **private**

  All files inside a top-level directory called `private/` are only accessible from server code and can be loaded via the [`Assets`](https://docs.meteor.com/api/Assets#Assets-getTextAsync) API. This can be used for private data files and any files that are in your project directory that you don't want to be accessible from the outside.

- **client/compatibility**

  This folder is for compatibility with JavaScript libraries that rely on variables declared with var at the top level being exported as globals. Files in this  directory are executed without being wrapped in a new variable scope. These files are executed before other client-side JavaScript files.

  > It is recommended to use npm for 3rd party JavaScript libraries and use `import` to control when files are loaded.

- **tests**

  Any directory named `tests/` is not loaded anywhere. Use this for any test code you want to run using a test runner outside of [Meteor's built-in test tools](https://guide.meteor.com/testing.html).

The following directories are also not loaded as part of your app code:

- Files/directories whose names start with a dot, like `.meteor` and `.git`
- `packages/`: Used for local packages
- `cordova-build-override/`: Used for [advanced mobile build customizations](https://guide.meteor.com/mobile.html#advanced-build)
- `programs`: For legacy reasons

### Files outside special directories

All JavaScript files outside special directories are loaded on both the client and the server. Meteor provides the variables [`Meteor.isClient`](https://docs.meteor.com/api/Meteor#Meteor-isClient) and [`Meteor.isServer`](https://docs.meteor.com/api/Meteor#Meteor-isServer) so that your code can alter its behavior depending on whether it's running on the client or the server.

CSS and HTML files outside special directories are loaded on the client only and cannot be used from server code.

## Splitting into multiple apps

If you are writing a sufficiently complex system, there can come a time where it makes sense to split your code up into multiple applications. For example you may want to create a separate application for the administration UI (rather than checking permissions all through the admin part of your site, you can check once), or separate the code for the mobile and desktop versions of your app.

Another very common use case is splitting a worker process away from your main application so that expensive jobs do not impact the user experience of your visitors by locking up a single web server.

There are some advantages of splitting your application in this way:

- Your client JavaScript bundle can be significantly smaller if you separate out code that a specific type of user will never use.

- You can deploy the different applications with different scaling setups and secure them differently (for instance you might restrict access to your admin application to users behind a firewall).

- You can allow different teams at your organization to work on the different applications independently.

However there are some challenges to splitting your code in this way that should be considered before jumping in.

### Sharing code

The primary challenge is properly sharing code between the different applications you are building. The simplest approach to deal with this issue is to deploy the *same* application on different web servers, controlling the behavior via different [settings](https://guide.meteor.com/deployment.html#environment). This approach allows you to deploy different versions with different scaling behavior but doesn't enjoy most of the other advantages stated above.

If you want to create Meteor applications with separate code, you'll have some modules that you'd like to share between them. If those modules are something the wider world could use, you should consider [publishing them to a package system](../../packages/#writing-atmosphere-packages), either npm or Atmosphere, depending on whether the code is Meteor-specific or otherwise.

If the code is private, or of no interest to others, it typically makes sense to include the same module in both applications (you *can* do this with [private npm modules](https://docs.npmjs.com/about-private-packages)). There are several ways to do this:

- a straightforward approach is to include the common code as a [git submodule](https://git-scm.com/book/en/v2/Git-Tools-Submodules) of both applications.

- alternatively, if you include both applications in a single repository, you can use symbolic links to include the common module inside both apps.

### Sharing data

Another important consideration is how you'll share the data between your different applications.

The simplest approach is to point both applications at the same `MONGO_URL` and allow both applications to read and write from the database directly. This works well thanks to Meteor's support for reactivity through the database. When one app changes some data in MongoDB, users of any other app connected to the database will see the changes immediately thanks to Meteor's livequery.

However, in some cases it's better to allow one application to be the master and control access to the data for other applications via an API. This can help if you want to deploy the different applications on different schedules and need to be conservative about how the data changes.

The simplest way to provide a server-server API is to use Meteor's built-in DDP protocol directly. This is the same way your Meteor client gets data from your server, but you can also use it to communicate between different applications. You can use [`DDP.connect()`](https://docs.meteor.com/api/meteor#DDP-connect) to connect from a "client" server to the master server, and then use the connection object returned to make method calls and read from publications.

If you need a more traditional API, you can use the bundled `express` available in Meteor. See the [documentation of WebApp](https://docs.meteor.com/packages/webapp#webapp)

```js
import { Meteor } from "meteor/meteor";
import { WebApp } from "meteor/webapp";
import bodyParser from "body-parser";

const app = WebApp.handlers;
app.use(bodyParser.json());
app.use("/hello", (req, res, next) => {
  res.writeHead(200);
  res.end(`Hello world from: ${Meteor.release}`);
});
```

### Sharing accounts

If you have two servers that access the same database and you want authenticated users to make DDP calls across the both of them, you can use the *resume token* set on one connection to login on the other.

If your user has connected to server A, then you can use `DDP.connect()` to open a connection to server B, and pass in server A's resume token to authenticate on server B. As both servers are using the same DB, the same server token will work in both cases. The code to authenticate looks like this:

```js
// This is server A's token as the default `Accounts` points at our server
const token = Accounts._storedLoginToken();

// We create a *second* accounts client pointing at server B
const app2 = DDP.connect('url://of.server.b');
const accounts2 = new AccountsClient({ connection: app2 });

// Now we can login with the token. Further calls to `accounts2` will be authenticated
accounts2.loginWithToken(token);
```

You can see a proof of concept of this architecture in an [example repository](https://github.com/tmeasday/multi-app-accounts).


Another pattern is to have another app which acts as identity provider for your apps. The [leaonline:oauth2-server](https://atmospherejs.com/leaonline/oauth2-server) package can be used to create an OAuth2 server in one Meteor app, and then other apps can use the standard `accounts-oauth` packages to authenticate users against it.

---

---
url: /community-packages/archive.md
---
# Archive

- `Who maintains the package` – [Jam](https://github.com/jamauro)

[[toc]]

## What is this package?

Archive is an easy way to add an archive mechanism to your Meteor app. When a document is archived, it's removed from its original collection and placed in an archive collection so that it can be restored if needed. Its key features are:

* Zero config needed (though you can customize)
* Isomorphic so that it works with Optimistic UI
* Automatically overrides `removeAsync` to perform an archive (can be turned off)
* Explicitly archive with `archiveAsync` collection method (optional)
* Restore archived docs with `restoreAsync` collection method
* Optionally exclude specific collections
* Compatible with Meteor `3.0.2+`

> **Note:** Alternative to archive is soft deletion. You can use [`jam:soft-delete`](./soft-delete.md) package for that. Be sure to compare those two approaches to pick the solution best suited for your application.

## How to download it?

Add the package to your app
```bash
meteor add jam:archive
```

### Sources

* [GitHub repository](https://github.com/jamauro/archive)

## How to use it?

### Create your Archives collection
Create an Archives collection in your app just as you would any other collection.
```js
const Archives = new Mongo.Collection('archives');
```

Documents in the Archives collection will have this shape:
```js
{
  _id, // auto-generated by Meteor as with other collection _ids
  _collection, // the name of the collection, e.g. 'todos', that the doc belonged to originally
  archivedAt, // the timestamp when the document was removed from its original collection and inserted into the archive
  id, // the original doc _id renamed to prevent conflict with the auto-generated one above. when restored, it will be renamed back to _id automatically by this package
  /*
  ...rest of original doc
  */
}
```

### Deleting permanently
By default, this package overrides the `removeAsync` collection method so that it archives the document(s) rather that removing them from the database. To delete permanently, pass in the option `forever: true`, e.g.:
```js
Collection.removeAsync(/* your filter */, { forever: true })
```

If you prefer, you can prevent overriding the `removeAsync` by setting `overrideRemove: false`. See [Configuring](#configuring-optional) for more details.

### Explicitly archiving
If you prefer, you can explicity use `archiveAsync`, e.g.:
```js
Collection.archiveAsync(/* your filter */)
```

### Restoring a document
To restore an archived document, use `restoreAsync`, e.g.:
```js
Collection.restoreAsync(/* your filter */)
```

## Configuring (optional)
If you like the defaults, then you won't need to configure anything. But there is some flexibility in how you use this package.

Here are the global defaults:
```js
const config = {
  name: 'archives', // if your Archives collection uses a different name, you'll want to change this
  overrideRemove: true, // overrides the Collection.removeAsync method to make it an archive instead
  exclude: ['roles', 'role-assignment'] // exclude specific collections from using archive so that when they are removed, the are permanently removed from the db. defaults to excluding the collections created by the meteor roles package
};
```

To change the global defaults, use:
```js
// put this in a file that's imported on both the client and server
import { Archive } from 'meteor/jam:archive';

Archive.configure({
  // ... change the defaults here ... //
});
```

---

---
url: /api/assets.md
---
# Assets

> Currently, it is not possible to import `Assets` as an ES6 module.  Any of the `Assets` methods below can simply be called directly in any Meteor server code.

`Assets` allows server code in a Meteor application to access static server
assets, which are located in the `private` subdirectory of an application's
tree. Assets are not processed as source files and are copied directly
into your application's bundle.

<ApiBox name="Assets.getTextAsync"/>
<ApiBox name="Assets.getBinaryAsync"/>
<ApiBox name="Assets.absoluteFilePath"/>

Static server assets are included by placing them in the application's `private`
subdirectory. For example, if an application's `private` subdirectory includes a
directory called `nested` with a file called `data.txt` inside it, then server
code can read `data.txt` by running:

```js
const data = await Assets.getTextAsync('nested/data.txt');
```

Note: Packages can only access their own assets. If you need to read the assets of a different package, or of the enclosing app, you need to get a reference to that package's `Assets` object.

---

---
url: /packages/audit-argument-checks.md
---
# Audit Argument Checks


This package causes Meteor to require that all arguments passed to methods and
publish functions are [checked](../api/check.md). Any method that does not pass each
one of its arguments to `check` will throw an error, which will be logged on the
server and which will appear to the client as a
`500 Internal server error`. This is a simple way to help ensure that your
app has complete check coverage.

Methods and publish functions that do not need to validate their arguments can
simply run `check(arguments, [Match.Any])` to satisfy the
`audit-argument-checks` coverage checker.

---

---
url: /packages/autoupdate.md
---
# Autoupdate

This is the Meteor package that provides hot code push (HCP) functionality.

Every Meteor application that wasn't created with the `--minimal` option
has this package already through `meteor-base` and HCP should work out of the
box. For those running `--minimal` applications and want to benefit from this
package, just add it with `meteor add autoupdate`.

> `autoupdate` adds up to 30KB on your client's production bundle.

With this package Meteor will use DDP to publish a collection called
_'meteor_autoupdate_clientVersions'_. This collection will be subscribed by the
user's client and every time the client identifies a change in the published
version it will refresh itself.

## Browser Client

The refresh will happen in the browser in two different ways: a _soft update_,
and a _hard update_. If Meteor identifies that only stylesheets were changed, then it
will verify if the user's browser is capable of reloading CSS on the fly, and a
soft update will take place. The soft update will replace the old stylesheet
with the new stylesheet without triggering a full page reload.

In cases where a change in a server's or client's compiled file happens, the hard
update will take place: Meteor will force a complete browser reload using the
`reload` package.

> Among other things, the `reload` package tries do reload the application
> preserving some unchanged cached files.

## Cordova Client

There is no soft update with Cordova apps, the client is always fully refreshed
once a change is detected.

### `usesCleartextTraffic`
Starting with Android 9 (API level 28), [cleartext support is disabled](https://developer.android.com/training/articles/security-config) by default.
During development `autoupdate` uses cleartext to publish new client versions.
If your app targets Android 9 or greater, it will be necessary to create a
`mobile-config.js` file enabling the use of cleartext in order to have HCP working:

```js
App.appendToConfig(`<edit-config file="app/src/main/AndroidManifest.xml"
                     mode="merge"
                     target="/manifest/application"
                     xmlns:android="http://schemas.android.com/apk/res/android">
        <application android:usesCleartextTraffic="true"></application>
    </edit-config>
`);
```

### `--mobile-server`
Additionally, for the HCP functionality to work it is also mandatory to provide
the address for the application server with `--mobile-server` option. If you're
testing your app on an emulator you should run it with `meteor run android --mobile-server 10.0.2.2:3000`.
If you're running it on a real device, the application server and the device
should be on the same network, and you should run your app with `meteor run android --mobile-server XXX.XXX.XXX.XXX`
where *XXX.XXX.XXX.XXX* is your local development address, _e.g. 192.168.1.4_.

> To have a better understanding of how HCP works for mobile apps already
> published to production refer to [Hot code push on mobile](https://guide.meteor.com/cordova.html#hot-code-push)

---

---
url: /api/blaze.md
---

# Blaze

How to use Blaze, Meteor's reactive rendering engine.

This documentation has moved to the [Blaze Community Site](http://blazejs.org/api/templates).

---

---
url: /packages/browser-policy.md
---
# Browser Policy

The `browser-policy` family of packages, part of
[Webapp](https://github.com/meteor/meteor/tree/master/packages/webapp), lets you
set security-related policies that will be enforced by newer browsers. These
policies help you prevent and mitigate common attacks like cross-site scripting
and clickjacking.

## Details

When you add `browser-policy` to your app, you get default configurations for
the HTTP headers X-Frame-Options and Content-Security-Policy. X-Frame-Options
tells the browser which websites are allowed to frame your app. You should only
let trusted websites frame your app, because malicious sites could harm your
users with [clickjacking attacks](https://www.owasp.org/index.php/Clickjacking).
[Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Security/CSP/Introducing_Content_Security_Policy)
tells the browser where your app can load content from, which encourages safe
practices and mitigates the damage of a cross-site-scripting attack.
`browser-policy` also provides functions for you to configure these policies if
the defaults are not suitable.

If you only want to use Content-Security-Policy or X-Frame-Options but not both,
you can add the individual packages `browser-policy-content` or
`browser-policy-framing` instead of `browser-policy`.

For most apps, we recommend that you take the following steps:

- Add `browser-policy` to your app to enable a starter policy. With this starter
  policy, your app's client code will be able to load content (images, scripts,
  fonts, etc.) only from its own origin, except that XMLHttpRequests and WebSocket
  connections can go to any origin. Further, your app's client code will not be
  able to use functions such as `eval()` that convert strings to code. Users'
  browsers will only let your app be framed by web pages on the same origin as
  your app.
- You can use the functions described below to customize the policies. If your
  app does not need any inline Javascript such as inline `<script>` tags, we
  recommend that you modify the policy by calling
  `BrowserPolicy.content.disallowInlineScripts()` in server code. This will result
  in one extra round trip when your app is loaded, but will help prevent
  cross-site scripting attacks by disabling all scripts except those loaded from a
  `script src` attribute.

Meteor determines the browser policy when the server starts up, so you should
call `BrowserPolicy` functions on the server in top-level application code or in
`Meteor.startup`. `BrowserPolicy` functions cannot be used in client code.

## Usage

### Frame options

By default, if you add `browser-policy` or `browser-policy-framing`, only web
pages on the same origin as your app are allowed to frame your app. You can use
the following functions to modify this policy.

## BrowserPolicy.framing.disallow()

Your app will never render inside a frame or iframe.

## BrowserPolicy.framing.restrictToOrigin(origin)

Your app will only render inside frames loaded by `origin`. You can only call
this function once with a single origin, and cannot use wildcards or specify
multiple origins that are allowed to frame your app. (This is a limitation of
the X-Frame-Options header.) Example values of `origin` include
`"http://example.com"` and `"https://foo.example.com"`. **This value of the
X-Frame-Options header is not yet supported in Chrome or Safari and will be
ignored in those browsers. If you need Chrome and/or Safari support, or need to
allow multiple domains to frame your application, you can use the frame-ancestors
CSP option via the BrowserPolicy.content.allowFrameAncestorsOrigin() function.**

## BrowserPolicy.framing.allowAll()

This unsets the X-Frame-Options header, so that your app can be framed by any
webpage.

### Content options

You can use the functions in this section to control how different types of
content can be loaded on your site.

You can use the following functions to adjust policies on where Javascript and
CSS can be run:

## BrowserPolicy.content.allowInlineScripts()

Allows inline `<script>` tags, `javascript:` URLs, and inline event handlers.
The default policy already allows inline scripts.

## BrowserPolicy.content.disallowInlineScripts()

Disallows inline Javascript. Calling this function results in an extra round-trip
on page load to retrieve Meteor runtime configuration that is usually part of an
inline script tag.

## BrowserPolicy.content.allowEval()

Allows the creation of Javascript code from strings using function such as `eval()`.

## BrowserPolicy.content.disallowEval()

Disallows eval and related functions. Note: The default policy disallows eval,
though for almost all Meteor apps it is enabled by the `dynamic-imports` package

## BrowserPolicy.content.allowInlineStyles()

Allows inline style tags and style attributes. The default policy already allows
inline styles.

## BrowserPolicy.content.disallowInlineStyles()

Disallows inline CSS.

Finally, you can configure a whitelist of allowed requests that various types of
content can make. The following functions are defined for the content types
script, object, image, media, font, frame, frame-ancestors, style, and connect.

## BrowserPolicy.content.allowContentTypeOrigin(origin)

Allows this type of content to be loaded from the given origin. `origin` is a
string and can include an optional scheme (such as `http` or `https`), an
optional wildcard at the beginning, and an optional port which can be a
wildcard. Examples include `example.com`, `https://*.example.com`, and
`example.com:*`. You can call these functions multiple times with different
origins to specify a whitelist of allowed origins. Origins that don't specify a
protocol will allow content over both HTTP and HTTPS: passing `example.com` will
allow content from both `http://example.com` and `https://example.com`.

## BrowserPolicy.content.allowContentTypeDataUrl()

Allows this type of content to be loaded from a `data:` URL.

## BrowserPolicy.content.allowContentTypeSameOrigin()

Allows this type of content to be loaded from the same origin as your app.

## BrowserPolicy.content.disallowContentType()

Disallows this type of content on your app.

You can also set policies for all these types of content at once, using these
functions:

- `BrowserPolicy.content.allowSameOriginForAll()`,
- `BrowserPolicy.content.allowDataUrlForAll()`,
- `BrowserPolicy.content.allowOriginForAll(origin)`
- `BrowserPolicy.content.disallowAll()`

For example, if you want to allow the
origin `https://foo.com` for all types of content but you want to disable
`<object>` tags, you can call
`BrowserPolicy.content.allowOriginForAll("https://foo.com")` followed by
`BrowserPolicy.content.disallowObject()`.

Other examples of using the `BrowserPolicy.content` API:

- `BrowserPolicy.content.disallowFont()` causes the browser to disallow all
  `<font>` tags.
- `BrowserPolicy.content.allowImageOrigin("https://example.com")`
  allows images to have their `src` attributes point to images served from
  `https://example.com`.
- `BrowserPolicy.content.allowConnectOrigin("https://example.com")` allows XMLHttpRequest
  and WebSocket connections to `https://example.com`.
- `BrowserPolicy.content.allowFrameOrigin("https://example.com")` allows
  your site to load the origin `https://example.com` in a frame or
  iframe. The `BrowserPolicy.framing` API allows you to control which
  sites can frame your site, while
  `BrowserPolicy.content.allowFrameOrigin` allows you to control which
  sites can be loaded inside frames on your site.

Adding `browser-policy-content` to your app also tells certain
browsers to avoid sniffing content types away from the declared type
(for example, interpreting a text file as JavaScript), using the
[X-Content-Type-Options](http://msdn.microsoft.com/en-us/library/ie/gg622941%28v=vs.85%29.aspx)
header. To re-enable content sniffing, you can call
`BrowserPolicy.content.allowContentTypeSniffing()`.

---

---
url: /packages/bundle-visualizer.md
---
# Bundle Visualizer

The `bundle-visualizer` package is an analysis tool which provides a visual
representation within the web browser showing what is included in the initial
client bundle.  The initial client bundle is the primary package of code
downloaded and executed by the browser to run a Meteor application and includes
packages which have been added via `meteor add <package>` or Node modules
included in the `node_modules` directory and used in an application.

This visualization can uncover details about which files or packages are
occupying space within the initial client bundle.  This can be useful in
determining which imports might be candidates for being converted to dynamic
`import()` statements (which are excluded from the initial client bundle), or
for identifying packages which have been inadvertently included in a project.

## How it works

This package utilizes the `<hash>.stats.json` files which are written alongside
file bundles when the application is ran with the `--production` flag.  The
specific details for the minified file sizes is added by the minifier package
and therefore it's important to review the minifier requirements below.

## Requirements

This package requires data provided by the project's minifier.  For this reason,
it is necessary to use the official `standard-minifier-js` package or a minifier
which includes file-size details obtained during minification.

## Usage

Since bundle analysis is only truly accurate on a minified bundle and
minification does not take place during development (as it is a complex and
CPU-intensive process which would substantially slow down normal development)
this package must be used in conjunction with the `--production` flag to the
`meteor` tool to simulate production bundling and enable minification.

> **IMPORTANT:** Since this package is active in production mode, it is critical
> to only add this package temporarily.  This can be easily accomplished using
> the `--extra-packages` option to `meteor`.

### Enabling
```sh
$ cd app/
$ meteor --extra-packages bundle-visualizer --production
```

### Viewing

Once enabled, view the application in a web-browser as usual
(e.g. `http://localhost:3000/`) and the chart will be displayed on top of the
application.

### Disabling

If you used `--extra-packages`, simply remove `bundle-visualizer` from the list
of included packages and run `meteor` as normal.

> If you've added `bundle-visualizer` permanently with `meteor add`, it is
> important to remove this package prior to bundling or deploying to
> production with `meteor remove bundle-visualizer`.

---

---
url: /about/modern-build-stack/bundler.md
---
# Bundler

Meteor handles linking all project files into the final bundle. While we'd like to offload more of this to a modern bundler, we're still focused on keeping what's left in the Meteor context as fast as possible.

Integration with a modern bundler is in progress for Meteor 3.4. Meanwhile, we've optimized existing processes for better performance.

## Web Arch

:::info
Starting with Meteor 3.3
:::

> Web archs are the builds Meteor generates for modern browsers, legacy browsers, and Cordova.

New apps skip `web.browser.legacy` and `web.cordova` by default in development mode (unless developing for native). This results on getting a faster build process on development mode.

For existing apps, enable this by adding to `package.json`:

```json
"meteor": {
  "modern": true
}
```

This works like using `--exclude-archs web.browser.legacy,web.cordova` with `meteor run`.

By default, `"modern": true` enables all build stack upgrades. To opt out of web arch-only compilation, set `"webArchOnly": false` in your `package.json`.

```json
"meteor": {
  "modern": {
    "webArchOnly": false
  }
}
```

This setting doesn’t affect production; legacy builds are still included by default on Meteor apps.

To exclude legacy builds in production, add "modern" to the `.meteor/platforms` file.

```sh
server
browser
modern
```

## Minifier

:::info
Starting with Meteor 3.3
:::

> The minifier reduces and obfuscates your app’s production bundle for security and efficiency.

New apps use an SWC-based minifier, replacing the legacy [Terser](https://github.com/terser/terser) minifier. This speeds up production builds and deployments.

For existing apps, enable this by adding to `package.json`:

```json
"meteor": {
  "modern": true
}
```

By default, `"modern": true` enables all build stack upgrades. To opt out of the new minifier, set `"minifier": false` in your `package.json`.

```json
"meteor": {
  "modern": {
    "minifier": false
  }
}
```

---

---
url: /generators/changelog/versions/99999-generated-code-warning.md
---
# Changelog

This is a complete history of changes for Meteor releases.

[//]: # (Do not edit this file by hand.)

[//]: # (This is a generated file.)

[//]: # (If you want to change something in this file)

[//]: # (go to meteor/docs/generators/changelog/docs)




---

---
url: /history.md
---
# Changelog

This is a complete history of changes for Meteor releases.

[//]: # (Do not edit this file by hand.)

[//]: # (This is a generated file.)

[//]: # (If you want to change something in this file)

[//]: # (go to meteor/docs/generators/changelog/docs)



## v3.3.2, 01-09-2025

### Highlights

- Async-compatible account URLs and email-sending coverage [#13740](https://github.com/meteor/meteor/pull/13740)
- Move `findUserByEmail` method from `accounts-password` to `accounts-base` [#13859](https://github.com/meteor/meteor/pull/13859)
- Return `insertedId` on client `upsert` to match Meteor 2.x behavior [#13891](https://github.com/meteor/meteor/pull/13891)
- Unrecognized operator bug fixed [#13895](https://github.com/meteor/meteor/pull/13895)
- Security fix for `sha.js` [#13908](https://github.com/meteor/meteor/pull/13908)


All Merged PRs@[GitHub PRs 3.3.2](https://github.com/meteor/meteor/pulls?q=is%3Apr+is%3Amerged+base%3Arelease-3.3.2)

#### Breaking Changes

N/A

##### Cordova Upgrade

- Enable modern browser support for Cordova unless explicitly disabled [#13896](https://github.com/meteor/meteor/pull/13896)

####  Internal API changes

- lodash.template dependency was removed [#13898](https://github.com/meteor/meteor/pull/13898)

#### Migration Steps

Please run the following command to update your project:

```bash
meteor update --release 3.3.2
```

---

If you find any issues, please report them to the [Meteor issues tracker](https://github.com/meteor/meteor).

#### Bumped Meteor Packages

- accounts-base@3.1.2
- accounts-password@3.2.1
- accounts-passwordless@3.0.2
- meteor-node-stubs@1.2.24
- babel-compiler@7.12.2
- boilerplate-generator@2.0.2
- ecmascript@0.16.13
- minifier@3.0.4
- minimongo@2.0.4
- mongo@2.1.4
- coffeescript-compiler@2.4.3
- npm-mongo@6.16.1
- shell-server@0.6.2
- typescript@5.6.6

#### Bumped NPM Packages

- meteor-node-stubs@1.2.23

#### Special thanks to

✨✨✨

- [@italojs](https://github.com/italojs)
- [@nachocodoner](https://github.com/nachocodoner)
- [@graemian](https://github.com/graemian)
- [@Grubba27](https://github.com/Grubba27)
- [@copleykj](https://github.com/copleykj)

✨✨✨
## v3.3.1, 05-08-2025

### Highlights

- **MongoDB Driver Upgrades**
  - Upgraded core MongoDB driver to `6.16.0` to address latest issues reported [#13710](https://github.com/meteor/meteor/pull/13710)
  - Introduced `npm-mongo-legacy` to maintain compatibility with MongoDB 3.6 via `mongodb@6.9.0` [#13736](https://github.com/meteor/meteor/pull/13736)
  - Mitigated a cursor leak issue by synchronizing `next()` and `close()` operations [#13786](https://github.com/meteor/meteor/pull/13786)

- **Improved SWC integration**
  - Fixed edge cases in config cache invalidation [#13809](https://github.com/meteor/meteor/pull/13809)
  - Ensured `@swc/helpers` is consistently used for better bundle size and performance [#13820](https://github.com/meteor/meteor/pull/13820)
  - Updated to SWC `1.12.14` [#13851](https://github.com/meteor/meteor/pull/13851)

- **Tooling and Build System**
  - Fixed regression affecting rebuild behavior [#13810](https://github.com/meteor/meteor/pull/13810)
  - Addressed issues getting performance profiles in mounted volumes [#13827](https://github.com/meteor/meteor/pull/13827)
  - Fallback to Babel parser when Acorn fails to parse source code [#13844](https://github.com/meteor/meteor/pull/13844)

- **Mobile Support**
  - Upgraded Cordova platform to version 14 [#13837](https://github.com/meteor/meteor/pull/13837)

- **Developer Experience**
  - Added TypeScript types for `isModern` and `getMinimumBrowserVersions` functions [#13704](https://github.com/meteor/meteor/pull/13704)
  - Enhanced CLI help output and documented admin commands [#13826](https://github.com/meteor/meteor/pull/13826)

- **Vite Tooling**
  - Updated official Meteor + Vite skeletons [#13835](https://github.com/meteor/meteor/pull/13835)

- **Runtime & Dependencies**
  - Updated to Node.js `22.18.0` and NPM `10.9.3` [#13877](https://github.com/meteor/meteor/pull/13877)
  - Bumped `meteor-node-stubs` to `1.2.21` [#13825](https://github.com/meteor/meteor/pull/13825)

All Merged PRs@[GitHub PRs 3.3.1](https://github.com/meteor/meteor/pulls?q=is%3Apr+is%3Amerged+base%3Arelease-3.3.1)

#### Breaking Changes

##### MongoDB Driver Upgrades

If you're using MongoDB 3.6 or earlier, install the new legacy package:

```bash
meteor add npm-mongo-legacy
```
This will pin the MongoDB driver to 6.9.0 for compatibility.

If you’re on MongoDB 4+, the default [MongoDB driver 6.16.0](https://github.com/mongodb/node-mongodb-native/releases/tag/v6.16.0) is applied automatically.

Please migrate your database as soon as possible to MongoDB 5 onward, as [MongoDB driver 6.17.0](https://github.com/mongodb/node-mongodb-native/releases/tag/v6.17.0) will drop MongoDB 4 support. We’ll keep offering `npm-mongo-legacy` so you can keep getting Meteor updates with your existing MongoDB legacy version.

##### Cordova Upgrade

The Cordova platform has been upgraded to version 14. Refer to the [Cordova Changelog](https://cordova.apache.org/announcements/2025/03/26/cordova-android-14.0.0.html) for more details on the changes and migration steps.

####  Internal API changes

N/A

#### Migration Steps

Please run the following command to update your project:

```bash
meteor update --release 3.3.1
```

---

While this is a patch release, Meteor 3.3, a recent minor update, introduced a modern build stack that’s now the default for new apps. Here’s how you can migrate to it.

**Add this to your `package.json` to enable the new modern build stack:**

```json
"meteor": {
  "modern": true
}
```

Check the docs for help with the SWC migration, especially if your project uses many Babel plugins.

[Modern Transpiler: SWC docs](https://docs.meteor.com/about/modern-build-stack/transpiler-swc.html)

If you find any issues, please report them to the [Meteor issues tracker](https://github.com/meteor/meteor).

#### Bumped Meteor Packages

- babel-compiler@7.12.1
- callback-hook@1.6.1
- ecmascript@0.16.12
- minifier-js@3.0.3
- minimongo@2.0.3
- modern-browsers@0.2.3
- mongo@2.1.3
- npm-mongo-legacy@6.9.0
- npm-mongo@6.16.0
- standard-minifier-js@3.1.1
- tinytest@1.3.2
- typescript@5.6.5
- meteor-tool@3.3.1

#### Bumped NPM Packages

- meteor-node-stubs@1.2.21

#### Special thanks to

✨✨✨

- [@nachocodoner](https://github.com/nachocodoner)
- [@italojs](https://github.com/italojs)
- [@StorytellerCZ](https://github.com/StorytellerCZ)
- [@JorgenVatle](https://github.com/JorgenVatle)
- [@welkinwong](https://github.com/welkinwong)
- [@Saksham-Goel1107](https://github.com/Saksham-Goel1107)

✨✨✨ 
## v3.3.0, 2025-06-11

### Highlights

- Support SWC transpiler and minifier for faster dev and builds [PR#13657](https://github.com/meteor/meteor/pull/13657),  [PR#13715](https://github.com/meteor/meteor/pull/13715)
- Switch to `@parcel/watcher` for improved native file watching [PR#13699](https://github.com/meteor/meteor/pull/13699), [#13707](https://github.com/meteor/meteor/pull/13707)
- Default to modern architecture, skip legacy processing [PR#13665](https://github.com/meteor/meteor/pull/13665), [PR#13698](https://github.com/meteor/meteor/pull/13698)
- Optimize SQLite for faster startup and better performance [PR#13702](https://github.com/meteor/meteor/pull/13702)
- Support CPU profiling in Meteor 3 bundler [PR#13650](https://github.com/meteor/meteor/pull/13650)
- Improve `meteor profile`: show rebuild steps and total, support `--build` [PR#16](https://github.com/meteor/performance/pull/16), [PR#13694](https://github.com/meteor/meteor/pull/13694)
- Improve `useFind` and `useSubscribe` React hooks
- Add `replaceEmailAsync` helper to Accounts [PR#13677](https://github.com/meteor/meteor/pull/13677)
- Fix user agent detection and oplog collection filtering
- Refine type definitions for Meteor methods and SSR's ServerSink
- Allow opting out of usage stats with `DO_NOT_TRACK`
- Update Node to 22.16.0 and Express to 5.1.0

All Merged PRs@[GitHub PRs 3.3](https://github.com/meteor/meteor/pulls?q=is%3Apr+is%3Amerged+base%3Arelease-3.3)

React Packages Changelog: [react-meteor-data@4.0.0](https://github.com/meteor/react-packages/tree/master/packages/react-meteor-data/CHANGELOG.md#v400-2025-06-11)

#### Breaking Changes

- File watching strategy switched to `@parcel/watcher`
    - Most setups should be fine, but if issues appear, like when using WSL with host, volumes, or remote setups—switch to polling.
    - Set `METEOR_WATCH_FORCE_POLLING=true` to enable polling.
    - Set `METEOR_WATCH_POLLING_INTERVAL_MS=1000` to adjust the interval.

- `react-meteor-data@4.0.0`
  - Independent from the core, only applies if upgraded manually.
  - useFind describes no deps by default [PR#431](https://github.com/meteor/react-packages/pull/431)

####  Internal API changes

- `express@5.1.0` - Depends on Meteor’s `webapp` package.
  - Deprecates non-native promise usage [#154](https://github.com/pillarjs/router/pull/154)
  - Use `async/await` or `Promise.resolve` when defining endpoints to avoid deprecation warnings.

#### Migration Steps

Please run the following command to update your project:

```bash
meteor update --release 3.3
```

To apply react-meteor-data changes:

```bash
meteor add react-meteor-data@4.0.0
```

**Add this to your `package.json` to enable the new modern build stack:**

```json
"meteor": {
  "modern": true
}
```

> These settings are on by default for new apps.

On activate `modern` your app will be updated to use SWC transpiler. It will automatically fallback to Babel if your code can't be transpiled wit SWC.

Check the docs for help with the SWC migration, especially if your project uses many Babel plugins.

[Modern Transpiler: SWC docs](https://docs.meteor.com/about/modern-build-stack/transpiler-swc.html)

If you find any issues, please report them to the [Meteor issues tracker](https://github.com/meteor/meteor).

#### Bumped Meteor Packages

- accounts-base@3.1.1
- accounts-password@3.2.0
- autoupdate@2.0.1
- babel-compiler@7.12.0
- boilerplate-generator@2.0.1
- ddp-client@3.1.1
- ecmascript@0.16.11
- ejson@1.1.5
- meteor@2.1.1
- minifier-js@3.0.2
- modern-browsers@0.2.2
- mongo@2.1.2
- server-render@0.4.3
- socket-stream-client@0.6.1
- standard-minifier-js@3.1.0
- typescript@5.6.4
- webapp@2.0.7
- meteor-tool@3.3.0

#### Bumped NPM Packages

- meteor-node-stubs@1.2.17

#### Special thanks to

✨✨✨

- [@nachocodoner](https://github.com/nachocodoner)  
- [@italojs](https://github.com/italojs)
- [@Grubba27](https://github.com/Grubba27)  
- [@zodern](https://github.com/zodern)
- [@9Morello](https://github.com/9Morello)
- [@welkinwong](https://github.com/welkinwong)
- [@Poyoman39](https://github.com/Poyoman39)
- [@PedroMarianoAlmeida](https://github.com/PedroMarianoAlmeida)
- [@harryadel](https://github.com/harryadel)
- [@ericm546](https://github.com/ericm546)
- [@StorytellerCZ](https://github.com/StorytellerCZ)

✨✨✨ 
## v3.2.2, 2025-05-02

### Highlights

- Improved parsing of `x-forwarded-for` headers in Session._clientAddress:
  - Changed header splitting method to handle comma-separated values more reliably
  - Added explicit trimming of IP addresses with map function
  - Modified validation check to require exact match for httpForwardedCount


#### Breaking Changes

N/A

####  Internal API changes

N/A

#### Migration Steps

Please run the following command to update your project:

```bash

meteor update --release 3.2.2

```

#### Bumped Meteor Packages

- ddp-server@3.1.1

#### Bumped NPM Packages


#### Special thanks to

✨✨✨

- [@italojs](https://github.com/italojs)
- [@ShiyuBanzhou](https://github.com/ShiyuBanzhou)


✨✨✨
## v3.2.0, 2025-03-18

### Highlights

- Upgrade to Node 22.14.0 & Mongo 7.0.16.
- Implement `meteor profile` command to show performance metrics of Meteor apps.
- Fix Meteor profiler to handle promises and display metrics correctly.
- Support for argon2 to improve password security over bcrypt. [PR](https://github.com/meteor/meteor/pull/13554)(https://github.com/meteor/meteor/pull/13554)
- Improve and fix package resolution logic. [PR](https://github.com/meteor/meteor/pull/13604)(https://github.com/meteor/meteor/pull/13604)
- Fix rare oplog issue that could cause data loss for clients. [PR](https://github.com/meteor/meteor/pull/13603)(https://github.com/meteor/meteor/pull/13603) 

All detailed PRs can be found here: https://github.com/meteor/meteor/pulls?q=is%3Apr+is%3Amerged+base%3Arelease-3.2

#### Breaking Changes

N/A

####  Internal API changes

N/A

#### Migration Steps

Please run the following command to update your project:

```bash

meteor update --release 3.2

```

#### Bumped Meteor Packages

- accounts-base@3.1.0
- accounts-password@3.1.0
- ecmascript-runtime-client@0.12.3
- facebook-oauth@1.11.6
- fetch@0.1.6
- logging@1.3.6
- logic-solver@3.1.0
- minifier-css@2.0.1
- meteor-tool@3.2.0
- modern-browsers@0.2.1
- mongo@2.1.1
- oauth@3.0.2
- test-helpers@2.0.3

#### Bumped NPM Packages

- meteor-node-stubs@1.2.13

#### Special thanks to

✨✨✨

- [@nachocodoner](https://github.com/nachocodoner)
- [@Grubba27](https://github.com/Grubba27)
- [@vparpoil](https://github.com/vparpoil)
- [@cunneen](https://github.com/cunneen)
- [@gbuerk](https://github.com/gbuerk)
- [@julio-rocketchat](https://github.com/julio-rocketchat)
- [@StorytellerCZ](https://github.com/StorytellerCZ)
- [@dr-dimitru](https://github.com/dr-dimitru)
- [@Seb-Dion](https://github.com/Seb-Dion)

✨✨✨
## v3.1.2, 2025-02-06

### Highlights

- Node upgrade: v22.13.1
- Updated Meteor skeletons for Vue and Solid
- Improved browser detection and related documentation
- Security updates: nodemailer-openpgp and others in Meteor packages

#### Breaking Changes

N/A

####  Internal API changes

N/A

#### Migration Steps

Please run the following command to update your project:

```bash

meteor update --release 3.1.2

```

#### Bumped Meteor Packages

- email@3.1.2
- meteor-tool@3.1.2
- modern-browsers@0.2.0
- webapp@2.0.5

#### Bumped NPM Packages

N/A

#### Special thanks to

✨✨✨

- [@nachocodoner](https://github.com/nachocodoner)
- [@Grubba27](https://github.com/Grubba27)
- [@perbergland](https://github.com/perbergland)
- [@StorytellerCZ](https://github.com/StorytellerCZ)
- [@julio-rocketchat](https://github.com/julio-rocketchat)

✨✨✨
## v3.1.1, 2025-01-15

### Highlights

- Node upgrade: v22.13.0
- Real-time Performance Boost: Refactored AsynchronousQueue for parallel processing and optimized MongoDB observers for faster initial document handling.
- Allow/Deny Rules Update: Deprecated async rules and updated documentation and types.
- Mongo Driver Downgrade: Reverted to a stable version to prevent issues in Meteor.
- Support for Meteor.deprecate: Added deprecation warnings with stack trace for outdated code usage.
- OAuth Fixes: Resolved issues with cancel popup event and callback.
- Windows Fixes: Fixed issues with running from folders with spaces and post-npm install build errors on Windows.
- Security Updates: Upgraded json5 and semver from babel compiler.

#### Breaking Changes

N/A

####  Internal API changes

N/A

#### Migration Steps

Please run the following command to update your project:

```bash

meteor update --release 3.1.1

```

#### Bumped Meteor Packages

- accounts-base@3.0.4
- accounts-oauth@1.4.6
- accounts-passwordless@3.0.1
- allow-deny@2.1.0
- babel-compiler@7.11.3
- ddp-client@3.1.0
- ddp-server@3.1.0
- meteor-tool@3.1.1
- facebook-oauth@1.11.5
- meteor@2.1.0
- meteor-tool@3.1.1
- mongo@2.1.0
- npm-mongo@6.10.2
- oauth@3.0.1
- roles@@1.0.1
- socket-stream-client@0.6.0

#### Bumped NPM Packages

N/A

#### Special thanks to

✨✨✨

- [@leonardoventurini](https://github.com/leonardoventurini)
- [@nachocodoner](https://github.com/nachocodoner)
- [@Grubba27](https://github.com/Grubba27)
- [@9Morello](https://github.com/9Morello)
- [@perbergland](https://github.com/perbergland)
- [@StorytellerCZ](https://github.com/StorytellerCZ)
- [@MrSpark2591](https://github.com/MrSpark2591)
- [@jstarpl](https://github.com/jstarpl)
- [@minhna](https://github.com/minhna)
- [@svolkomorov](https://github.com/svolkomorov)
- [@quyetdgroup](https://github.com/quyetdgroup)

✨✨✨
## v3.1.0, 2024-11-20

### Highlights

- Upgrade to Node v22
- Upgrade Mongo Driver to v6
- Upgrade Express to v5
- HMR performance improvements
- Bring the `roles` package into the core
- Solve remaining issues with Top Level Await and Reify
- Refactor part of the real-time code in the `mongo` package into TypeScript
- Deprecate `underscore` and eliminate it from packages
- Fix Cordova dependency issues
- Simplify Meteor.EnvironmentVariable and make sure it works in all cases
- Stop using Rosetta for development MongoDB on Apple Silicon
- Test improvements
- Bump `http` package to 3.0.0

#### Breaking Changes

- Express is now at v5 and some it's APIs have changed.

####  Internal API changes

N/A

#### Migration Steps

Please run the following command to update your project:

```bash

meteor update --release 3.1

```

Make sure to migrate userland code to use the new Express APIs:

https://expressjs.com/en/guide/migrating-5.html

The MongoDB Node.js driver implemented a significant breaking change regarding operation handling. Applications leveraging `rawCollection()` or `rawDatabase()` methods must now utilize Promise-based syntax exclusively, as the callback-pattern API has been deprecated and removed. This modification affects all direct MongoDB operations previously using callback functions.


#### Bumped Meteor Packages

- accounts-password@3.0.3
- babel-compiler@7.11.2
- boilerplate-generator-tests@1.5.3
- ddp-client@3.0.3
- ddp-server@3.0.3
- http@3.0.0
- ecmascript@0.16.10
- email@3.1.1
- meteor-tool@3.1.0
- meteor@2.0.2
- minifier-js@3.0.1
- minimongo@2.0.2
- modules@0.20.3
- mongo@2.0.3
- coffeescript-compiler@2.4.2
- coffeescript@2.7.2
- mongo-decimal@0.2.0
- npm-mongo@6.10.0
- shell-server@0.6.1
- test-helpers@2.0.2
- test-in-console@2.0.1
- tinytest@1.3.1
- typescript@5.6.3
- url@1.3.5
- webapp@2.0.4


#### Bumped NPM Packages

- meteor-babel@7.20.1
- meteor-installer@3.1.0
- meteor-node-stubs@1.2.12


#### Special thanks to

✨✨✨

- [@denihs](https://github.com/denihs)
- [@nachocodoner](https://github.com/nachocodoner)
- [@leonardoventurini](https://github.com/leonardoventurini)
- [@StorytellerCZ](https://github.com/StorytellerCZ)
- [@zodern](https://github.com/zodern)
- [@harry97](https://github.com/harry97)
- [@permb](https://github.com/permb)
- [@9Morello](https://github.com/9Morello)
- [@wreiske](https://github.com/wreiske)
- [@MarcoTribuz](https://github.com/MarcoTribuz)
- [@MeteorCoder](https://forums.meteor.com/u/meteorcoder/summary)

✨✨✨
## v3.0.4, 2024-10-15

### Highlights

- Node 20.18.0 & Typescript 5.6.2
- Updated webapp dependencies.
- DDP-server and DDP-client removed underscore
- Remove dependencies on Blaze packages when using static-html
- Fix Cordova on Windows
- Fix Cordova build on using plugins describing dependencies
- Various Windows specific fixes

#### Breaking Changes

N/A

####  Internal API changes

N/A

#### Migration Steps

Please run the following command to update your project:

```bash

meteor update --release 3.0.4

```

#### Meteor Version Release

* `Bumped packages`:
  - accounts-base@3.0.3                
  - babel-compiler@7.11.1              
  - caching-compiler@2.0.1             
  - check@1.4.4                        
  - ddp-client@3.0.2                   
  - ddp-server@3.0.2                   
  - ecmascript-runtime@0.8.3           
  - modules@0.20.2                     
  - static-html-tools@1.0.0            
  - static-html@1.4.0                  
  - url@1.3.4                          
  - webapp@2.0.3                       
  - meteor-tool@3.0.4

#### Special thanks to
N/A
## v3.0.3, 2024-09-11

### Highlights

- Fixed `Meteor.userId` only being invoked with `bindEnvironment`.
- Updated to Node `20.17.x`.
- Fixed an issue where `meteor --open` opens the browser before the app is started.
- Investigated and addressed the error when installing the `jam:method` package.
- Improved the message for new available versions when running an app.
- Updated the documentation link inside `install.sh`.
- Resolved the issue where subscriptions stopped after a parameter change.
- Added MongoDB connection telemetry.
- Bumped the `email` package to prevent update errors.
- Cordova package updates

#### Breaking Changes

N/A

####  Internal API changes

- Some internal changes to how async contexts are handled, ensuring better performance and garbage collection.

#### Migration Steps

Please run the following command to update your project:

```bash

meteor update --release 3.0.3

```

If you've had your Meteor installation for over a year, we suggest reinstalling it to avoid any package installation issues. You can do this by running a few quick commands:

```bash
npx meteor uninstall // or rm -rf ~/.meteor
npx meteor
```



#### Meteor Version Release

* `Bumped packages`:
  - accounts-base@3.0.2
  - accounts-password@3.0.2
  - email@3.1.0
  - mongo@2.0.2


#### Special thanks to

- [@ayewo](https://github.com/ayewo).
- [@denihs](https://github.com/denihs).
- [@harryadel](https://github.com/harryadel).
- [@kbarr1212](https://github.com/kbarr1212).
- [@leonardoventurini](https://github.com/leonardoventurini).
- [@nachocodoner](https://github.com/nachocodoner).

## v3.0.2, 2024-08-14

### Highlights

* Bump the patch for some packages, so we publish them using Meteor 3 tooling. [PR](https://github.com/meteor/meteor/pull/13231)
* Fix subscription still resetting documents [PR](https://github.com/meteor/meteor/pull/13236)
* Fix auth sub sending ready twice on load [PR](https://github.com/meteor/meteor/pull/13247)
* Remove version constraints from http package in accounts-twitter [PR](https://github.com/meteor/meteor/pull/13268)
* Deprecate Meteor.user() usage on server side [PR](https://github.com/meteor/meteor/pull/13288)

#### Breaking Changes

N/A

####  Internal API changes

N/A

#### Migration Steps

Please run the following command to update your project:

```bash

meteor update --release 3.0.2

```


#### Meteor Version Release

* `Bumped packages`:
  - accounts-2fa@3.0.1
  - accounts-base@3.0.1
  - accounts-password@3.0.1
  - accounts-twitter@1.5.2
  - ddp-client@3.0.1
  - ddp-common@1.4.4
  - ddp-server@3.0.1
  - email@3.0.1
  - meteor@2.0.1
  - minimongo@2.0.1
  - mongo@2.0.1
  - npm-mongo@4.17.4
  - test-helpers@2.0.1
  - webapp@2.0.1



#### Special thanks to

- [@leonardoventurini](https://github.com/leonardoventurini).
- [@StorytellerCZ](https://github.com/StorytellerCZ).


For making this great framework even better!


## v3.0.1, 2024-07-16

### Highlights

* Bump the patch for some packages, so we publish them using Meteor 3 tooling. [PR](https://github.com/meteor/meteor/pull/13231)

#### Breaking Changes

N/A

####  Internal API changes

N/A

#### Migration Steps

Please run the following command to update your project:

```bash

meteor update --release 3.0.1

```


#### Meteor Version Release


* `Bumped packages`:
  - accounts-ui-unstyled@1.7.2
  - crosswalk@1.7.3
  - facebook-oauth@1.11.4
  - npm-mongo@4.17.3
  - package-version-parser@3.2.3
  - twitter-config-ui@1.0.2


#### Special thanks to

- [@denihs](https://github.com/denihs).


For making this great framework even better!


## v3.0, 2024-07-15

### Highlights

#### Breaking Changes

- Meteor tool
  - 'meteor reset' command only affects the local project cache. Use `--db` option to also remove the local database.

- `accounts-2fa@3.0.0`:

  - Some methods are now async. See below:
  - `Accounts._is2faEnabledForUser`
  - `(Meteor Method) - generate2faActivationQrCode`
  - `(Meteor Method) - enableUser2fa`
  - `(Meteor Method) - disableUser2fa`
  - `(Meteor Method) - has2faEnabled`

- `accounts-base@3.0.0`:

  - `methods.removeOtherTokens` is now async
  - `Accounts.destroyToken` is now async
  - `Accounts.insertUserDoc` is now async
  - `Accounts.updateOrCreateUserFromExternalService` is now async
  - `Accounts.expirePasswordToken` is now async
  - `Accounts.setupUsersCollection` is now async
  - `Meteor.user` is now async in server

- `accounts-facebook@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `accounts-github@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `accounts-google@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `accounts-meetup@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `accounts-meteor-developer@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `accounts-oauth@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `accounts-password@3.0.0`:

  - Some server methods are now async:
  - `Accounts.sendResetPasswordEmail`
  - `Accounts.sendEnrollmentEmail`
  - `Accounts.sendVerificationEmail`
  - `Accounts.addEmail`
  - `Accounts.removeEmail`
  - `Accounts.replaceEmailAsync`
  - `Accounts.verifyEmail`
  - `Accounts.createUserVerifyingEmail`
  - `Accounts.createUser`
  - `Accounts.generateVerificationToken`
  - `Accounts.generateResetToken`
  - `Accounts.forgotPassword`
  - `Accounts.setPassword` -- no longer exists, you should use Accounts.setPasswordAsync [PR](https://github.com/meteor/meteor/pull/13030)
  - `Accounts.changePassword`
  - `Accounts.setUsername`
  - `Accounts.findUserByEmail`
  - `Accounts.findUserByUsername`

- `accounts-passwordless@3.0.0`:

  - `Accounts.sendLoginTokenEmail` is now async.

- `accounts-twitter@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `accounts-ui-unstyled@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `accounts-ui@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `accounts-weibo@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `allow-deny@2.0.0`:

  - Updated to accept async functions.

- `appcache@2.0.0`:

  - Updated internal api to use `handlers`

- `audit-argument-checks@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `autopublish@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `autoupdate@2.0.0`:

  - Updated api to be async, with asyncronous queueing.

- `babel-compiler@8.0.0`:

  - Removed `Promise.await` default transform.
  - Added top-level-await to packages.

- `babel-runtime@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `base64@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `binary-heap@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- Build system:
  - removed `Assets.getText`
  - removed `Assets.getBinary`

- `blaze@3.0.0`:
  - Todo

- `boilerplate-generator-tests@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `boilerplate-generator@2.0.0`:

  - `toHTML` is no longer available (it was already deprecated). Use `toHTMLStream` instead.
  - Updated to use `handlers`

- `browser-policy-common@2.0.0`:

  - Updated to use `handlers`

- `browser-policy-content@2.0.0`:

  - Some methods are now async. See below:
    - `BrowserPolicy.content.setPolicy`
    - `BrowserPolicy.content.allowInlineScripts`
    - `BrowserPolicy.content.disallowInlineScripts`
    - `BrowserPolicy.content.disallowAll`
    - `BrowserPolicy.setDefaultPolicy`

- `browser-policy-framing@2.0.0`:
  - Package was bumped due to a dependency update. No code changes were made.

- `browser-policy@2.0.0`:
  Updated to use async methods from `browser-policy-common` and `browser-policy-content`.

- `caching-compiler@2.0.0`:

  - `afterLink` is now async.
  - Updated to use now async API.

- `callback-hook@2.0.0`:

  - Added `forEachAsync` method.

- `check@2.0.0`:

  - Removed `fibers` related tests.

- `constraint-solver@2.0.0`:

  - Some methods are now async. See below:

    - `ConstraintSolver.getVersionCostSteps`
    - `ConstraintSolver.analyze`
    - `ConstraintSolver.resolve`

  - Updated tests to be async.
  - Removed a few underscore usage.
  - Added updated to use async methods

- `context@1.0.0`:

  - Removed `fibers` from package.

- `core-runtime@2.0.0`:

  - Created package to load packages and the app.
  - This is the pakcages that sets up the Runtime.

- `crosswalk@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `ddp-client@3.0.0`:

  - Added `isAsyncCall` method to know if call is being made by a async method.
  - Removed `fibers` from package.
  - Updated tests to use async methods.

- `ddp-common@2.0.0`:

  - Added `.fence` option.

- `ddp-rate-limiter@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `ddp-server@3.0.0`:

  - Updated to use async methods.
  - Removed `fibers` from package.
  - Updated tests to use async methods.
  - Turned server implementation to async.

- `ddp@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `diff-sequence@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `disable-oplog@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `ecmascript-runtime-client@1.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `ecmascript-runtime-server@1.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `ecmascript-runtime@1.0.0`:

  - Added dependency to `@babel/runtime`.

- `ecmascript@1.0.0`:

  - Added dependency to `@babel/runtime`.
  - Moved runtime tests.

- `ejson@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `email@3.0.0`:

  - `Email.send` is no longer available. Use `Email.sendAsync` instead.
  - Updated types to reflext async methods and `Email.send` depracation.

- `es5-shim@5.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `facebook-config-ui@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `facebook-oauth@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `facts-base@2.0.0`:

  - turned unorderd deps on `ddp` to false.

- `facts-ui@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `fetch@1.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `force-ssl-common@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `force-ssl@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `geojson-utils@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `github-config-ui@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `github-oauth@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `google-config-ui@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `google-oauth@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `hot-code-push@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `http@`:
  - Updated handlers to use `handlers`
- `id-map@2.0.0`:

  - Added `forEachAsync` method.

- `insecure@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `inter-process-messaging@1.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `launch-screen@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `localstorage@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `logging@2.0.0`:

  - Added dependency to `@babel/runtime`.

- `logic-solver@3.0.0`:
  `Logic.disablingAssertions` is now async.
  `minMaxWS` is now async.

- `meetup-config-ui@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `meetup-oauth@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `meteor-base@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `meteor-developer-config-ui@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `meteor-developer-oauth@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `meteor-tool@3.0.0`:

  - Changes to how meteor apps are being created [PR](https://github.com/meteor/meteor/pull/12697)

- `meteor@2.0.0`:

  - Async local storage was added to help deal with async methods.
  - Added `promiseEmmiter` to help with async methods.
  - Removed `fibers` from package.
  - `Meteor.absoluteUrl` in localhost uses `127.0.1` by default.

- `minifier-css@2.0.0`:

  - `minifyCss` is now async.
  - Removed `fibers` from package.

- `minifier-js@3.0.0`:

  - `minifyJs` is now async.
  - `terserMinify` no longer takes callbacks
  - Removed `fibers` from package.

* `minimongo@2.0.0`:
  - `cursor.observe` now returns `isReady` and `isReadyPromise` wich indicates
    if the cursor is ready and if the callbacks are have been called.
    If you only use it in the `Client` or as a `LocalCollection` things have not
    changed.

- `mobile-experience@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `mobile-status-bar@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `modern-browsers@1.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `modules-runtime@1.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `modules@1.0.0`:

  - Updated `reify` version.

- `mongo-decimal@`:

  - Updated to use `async` methods.

- `mongo-dev-server@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `mongo-id@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `mongo-livedata@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `mongo@2.0.0`:

  - Updated to unify methods, `update`,`insert`,`remove`, `fetch` are now async, they are
    the same as their `*Async` counterpart.
  - `ensureIndex` and `createIndex` are now async.

- `npm-mongo@5.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `oauth-encryption@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `oauth@`:

  - `_endOfPopupResponseTemplate` and `_endOfRedirectResponseTemplate` are no longer a property but now a function that returns a promise of the same value as before
  - the following server methods are now async:
  - `OAuth._renderOauthResults`
  - `OAuth._endOfLoginResponse`
  - `OAuth.renderEndOfLoginResponse`
  - `OAuth._storePendingCredential`
  - `OAuth._retrievePendingCredential`
  - `ensureConfigured`
  - `_cleanStaleResults`

- `oauth@3.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `oauth1@`:

  - the following server methods are now async:
  - `OAuth._storeRequestToken`
  - `OAuth._retrieveRequestToken`

- `oauth1@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `oauth2@`:

  - `OAuth._requestHandlers['2']` is now async.

- `oauth2@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `ordered-dict@2.0.0`:

  - Added `forEachAsync` method.

- `package-stats-opt-out@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `package-version-parser@4.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `promise@1.0.0`:

  - Removed `fibers` usage

- `random@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `rate-limit@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `reactive-dict@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `reactive-var@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `reload-safetybelt@2.0.0`:

  - Added `ecmascript` package to `package.js`

- `reload@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `retry@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `routepolicy@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `server-render@1.0.0`:

  - Updated usage with `getBoilerplate` that are now `async`.

- `service-configuration@2.0.0`:

  - Updated to use `createIndexAsync`.

- `session@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `sha@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `shell-server@1.0.0`:

  - Updated to handle promises results.

- `socket-stream-client@1.0.0`:

  - Updated tests to handle `async` code.

- `spiderable@`:

  - Updated handlers to use `handlers` that are now using express
  - removed `fibers` usage if flag is set to `true`

- `standard-minifier-css@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `standard-minifier-js@3.0.0`:

  - `processFilesForBundle` is now `async`.

- `standard-minifiers@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `static-html@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `test-helpers@2.0.0`:

  - Updated to use `async` methods.
  - Removed `fibers` usage.
  - Added possibliy to use `async` tests.

- `test-in-browser@2.0.0`:

  - Updated css to be in dark mode.

- `test-in-console@2.0.0`:

  - Updated log identation.

- `test-server-tests-in-console-once@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `tinytest-harness@1.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `tinytest@2.0.0`:

  - Added `test name` to logs.
  - Removed `fibers` usage.

- `twitter-config-ui@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `twitter-oauth@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `typescript@5.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `underscore-tests@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `underscore@2.0.0`:

  - Removed dependency in meteor package.

- `url@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `webapp-hashing@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `webapp@2.0.0`:

  - These methods are now async:

    - `WebAppInternals.reloadClientPrograms()`
    - `WebAppInternals.pauseClient()`
    - `WebAppInternals.generateClientProgram()`
    - `WebAppInternals.generateBoilerplate()`
    - `WebAppInternals.setInlineScriptsAllowed()`
    - `WebAppInternals.enableSubresourceIntegrity()`
    - `WebAppInternals.setBundledJsCssUrlRewriteHook()`
    - `WebAppInternals.setBundledJsCssPrefix()`
    - `WebAppInternals.getBoilerplate`

  - Changed engine from connect to express and changed api naming to match express. See below:
  - `WebApp.connectHandlers.use(middleware)` is now `WebApp.handlers.use(middleware)`
  - `WebApp.rawConnectHandlers.use(middleware)` is now `WebApp.rawHandlers.use(middleware)`
  - `WebApp.connectApp` is now `WebApp.expressApp`
  - `WebApp.addRuntimeConfigHook` accepts async callbacks

- `weibo-config-ui@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `weibo-oauth@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

#### New Public API


- `Build system` [PR](https://github.com/meteor/meteor/pull/13030):
  - Assets.getTextAsync
  - Assets.getBinaryAsync

- `accounts-base`: (2.9+)

  - `Meteor.userAsync()`

- `callback-hook`:forEachAsync

  - `forEachAsync`

- `ddp-server`: (2.8+)

  - `Meteor.callAsync()`

- `minifier-css`: (2.9+)

  - `CssTools.minifyCssAsync()`

- `mongo`:

  - `Mongo.Collection`: (2.8+)
    - `createCappedCollectionAsync`
    - `createIndexAsync`
    - `dropCollectionAsync`
    - `dropIndexAsync`
    - `findOneAsync`
    - `insertAsync`
    - `removeAsync`
    - `updateAsync`
    - `upsertAsync`
  - `Collection.Cursor`: (2.8+)
    - `countAsync`
    - `fetchAsync`
    - `forEachAsync`
    - `mapAsync`
    - `[Symbol.asyncIterator]` so this code should work:
      ```js
      for await (const document of collection.find(query, options)) /* ... */
      ```

#### Internal API changes

`accounts-base`:

- `_attemptLogin`
- `_loginMethod`
- `_runLoginHandlers`

* Upgraded `node-gyp` to v9.4.0
* Upgraded `node-pre-gyp` to `@mapbox/node-pre-gyp` v1.0.11

#### New Internal API

`accounts-password`:

- `Accounts._checkPasswordAsync`

#### Special thanks to

- [@StorytellerCZ](https://github.com/sponsors/StorytellerCZ/)

For making this great framework even better!

---

---
url: /api/check.md
---
# Check

Documentation on how to use check, Meteor's type checking library.

The `check` package includes pattern checking functions useful for checking the types and structure
of variables and an [extensible library of patterns](#matchpatterns) to specify which types you are
expecting.

To add `check` (or `Match`) to your application, run this command in your terminal:

```bash
meteor add check
```

<ApiBox name="check" hasCustomExample/>

Meteor methods and publish functions can take arbitrary [EJSON](./EJSON.md) types as arguments, but most
functions expect their arguments to be of a particular type. `check` is a lightweight function for
checking that arguments and other values are of the expected type. For example:

```js [server.js]
import { check } from "meteor/check";
import { Meteor } from "meteor/meteor";
Meteor.publish("chatsInRoom", function (roomId) {
  // Make sure `roomId` is a string, not an arbitrary Mongo selector object.
  check(roomId, String);
  return Chats.find({ room: roomId });
});

Meteor.methods({
  addChat(roomId, message) {
    check(roomId, String);
    check(message, {
      text: String,
      timestamp: Date,
      // Optional, but if present must be an array of strings.
      tags: Match.Maybe([String]),
    });

    // Do something with the message...
  },
});
```

If the match fails, `check` throws a `Match.Error` describing how it failed. If
this error gets sent over the wire to the client, it will appear only as
`Meteor.Error(400, 'Match Failed')`. The failure details will be written to the
server logs but not revealed to the client.

<ApiBox name="Match.test" hasCustomExample/>

`Match.test` can be used to identify if a variable has a certain structure.

```js
import { Match } from "meteor/check";

// Will return true for `{ foo: 1, bar: 'hello' }` or similar.
Match.test(value, { foo: Match.Integer, bar: String });

// Will return true if `value` is a string.
Match.test(value, String);

// Will return true if `value` is a string or an array of numbers.
Match.test(value, Match.OneOf(String, [Number]));
```

This can be useful if you have a function that accepts several different kinds
of objects, and you want to determine which was passed in.

## Match Patterns { #matchpatterns }

The following patterns can be used as pattern arguments to
[`check`](#check) and `Match.test`:

### `Match.Any`

Matches any value.

```js
import { Match } from "meteor/check";
// Will return true for any value.
Match.test(value, Match.Any);
```

### `String`, `Number`, `Boolean`, `undefined`, `null`

Matches a primitive of the given type.

```js
import { Match } from "meteor/check";
let result;
// Will return true if `value` is a string.
result = Match.test(value, String);
console.log(result); // true

// Will return true if `value` is a number.
result = Match.test(value, Number);
console.log(result); // true

// Will return true if `value` is a boolean.
result = Match.test(value, Boolean);
console.log(result); // true
```

### `Match.Integer`

Matches a signed 32-bit integer. Doesn't match `Infinity`, `-Infinity`, or `NaN`.

```js
import { Match } from "meteor/check";
let result;
// Will return true if `value` is an integer.
result = Match.test(value, Match.Integer);
console.log(result); // true
```

### `[pattern]` { #arraypattern }

A one-element array matches an array of elements, each of which match
_pattern_. For example, `[Number]` matches a (possibly empty) array of numbers;
`[Match.Any]` matches any array.

```js
import { Match } from "meteor/check";
let result;
// Will return true if `value` is an array of numbers.
result = Match.test(value, [Number]);
console.log(result); // true
```

### `{ key1: pattern1, key2: pattern2, ... }`

Matches an Object with the given keys, with values matching the given patterns.
If any _pattern_ is a `Match.Maybe` or `Match.Optional`, that key does not need to exist
in the object. The value may not contain any keys not listed in the pattern.
The value must be a plain Object with no special prototype.

```js
import { Match } from "meteor/check";
let result;
// Will return true if `value` is an object with keys 'foo' and 'bar'.
result = Match.test(value, { foo: String, bar: Number });
console.log(result); // true
```

### `Match.ObjectIncluding({ key1: pattern1, key2: pattern2, ... })`

Matches an Object with the given keys; the value may also have other keys
with arbitrary values.

```js
import { Match } from "meteor/check";
let result;
// Will return true if `value` is an object with keys 'foo' and 'bar'.
result = Match.test(value, Match.ObjectIncluding({ foo: String, bar: Number }));
console.log(result); // true
```

### `Object`

Matches any plain Object with any keys; equivalent to
`Match.ObjectIncluding({})`.

```js
import { Match } from "meteor/check";
let result;
// Will return true if `value` is an object.
result = Match.test(value, Object);
console.log(result); // true
```

### `Match.Maybe(pattern)` { #maybepattern }

Matches either `undefined`, `null`, or _pattern_. If used in an object, matches only if the key is
not set as opposed to the value being set to `undefined` or `null`. This set of conditions was
chosen because `undefined` arguments to Meteor Methods are converted to `null` when sent over the
wire.

```js
import { Match, check } from "meteor/check";
// In an object
const pattern = { name: Match.Maybe(String) };

check({ name: "something" }, pattern); // OK
check({}, pattern); // OK
check({ name: undefined }, pattern); // Throws an exception
check({ name: null }, pattern); // Throws an exception

// Outside an object
check(null, Match.Maybe(String)); // OK
check(undefined, Match.Maybe(String)); // OK
```

### `Match.Optional(pattern)` { #optionalpattern }

Behaves like `Match.Maybe` except it doesn't accept `null`. If used in an object, the behavior is
identical to `Match.Maybe`.

### `Match.OneOf(pattern1, pattern2, ...)`

Matches any value that matches at least one of the provided patterns.

### Any constructor function (eg, `Date`)

Matches any element that is an instance of that type.

```js
import { Match } from "meteor/check";
let result;

// Will return true if `value` is a Date.
result = Match.test(value, Date);
```

### `Match.Where(condition)`

Calls the function _condition_ with the value as the argument. If _condition_
returns true, this matches. If _condition_ throws a `Match.Error` or returns
false, this fails. If _condition_ throws any other error, that error is thrown
from the call to `check` or `Match.test`. Examples:

```js
import { Match, check } from "meteor/check";

check(buffer, Match.Where(EJSON.isBinary));

const NonEmptyString = Match.Where((x) => {
  check(x, String);
  return x.length > 0;
});

check(arg, NonEmptyString);
```

---

---
url: /packages/coffeescript.md
---
# CoffeeScript

[CoffeeScript](http://coffeescript.org/) is a little language that
compiles into JavaScript. It provides a simple syntax without lots of
braces and parentheses.  The code compiles one-to-one into the
equivalent JS, and there is no interpretation at runtime.

CoffeeScript is supported on both the client and the server. Files
ending with `.coffee`, `.litcoffee`, or `.coffee.md` are automatically
compiled to JavaScript.

### Namespacing and CoffeeScript

Here's how CoffeeScript works with Meteor's namespacing.

* Per the usual CoffeeScript convention, CoffeeScript variables are
  file-scoped by default (visible only in the `.coffee` file where
  they are defined.)

* When writing a package, CoffeeScript-defined variables can be
  exported like any other variable (see [Package.js](/api/package)). Exporting a variable pulls it up to
  package scope, meaning that it will be visible to all of the code in
  your app or package (both `.js` and `.coffee` files).

* Package-scope variables declared in `.js` files are visible in any
  `.coffee` files in the same app or project.

* There is no way to make a package-scope variable from a `.coffee`
  file other than exporting it. We couldn't figure out a way to make
  this fit naturally inside the CoffeeScript language. If you want to
  use package-scope variables with CoffeeScript, one way is to make a
  short `.js` file that declares all of your package-scope
  variables. They can then be used and assigned to from `.coffee`
  files.

* If you want to share variables between `.coffee` files in the same
  package, and don't want to separately declare them in a `.js` file,
  we have an experimental feature that you may like. An object called
  `share` is visible in CoffeeScript code and is shared across all
  `.coffee` files in the same package. So, you can write `share.foo`
  for a value that is shared between all CoffeeScript code in a
  package, but doesn't escape that package.

Heavy CoffeeScript users, please let us know how this arrangement
works for you, whether `share` is helpful for you, and anything else
you'd like to see changed.

### Modules and CoffeeScript

See [Modules » Syntax » CoffeeScript](/packages/modules.html#coffeescript).

---

---
url: /api/collections.md
---
# Collections

Meteor stores data in _collections_. To get started, declare a
collection with `new Mongo.Collection`.

<ApiBox name="Mongo.Collection" />

Calling this function is analogous to declaring a model in a traditional ORM
(Object-Relation Mapper)-centric framework. It sets up a _collection_ (a storage
space for records, or "documents") that can be used to store a particular type
of information, like users, posts, scores, todo items, or whatever matters to
your application. Each document is a EJSON object. It includes an `_id`
property whose value is unique in the collection, which Meteor will set when you
first create the document.

```js
// Common code on client and server declares a DDP-managed Mongo collection.
const Chatrooms = new Mongo.Collection("chatrooms");
const Messages = new Mongo.Collection("messages");
```

The function returns an object with methods to [`insert`](#Mongo-Collection-insert)
documents in the collection, [`update`](#Mongo-Collection-update) their properties, and
[`remove`](#Mongo-Collection-remove) them, and to [`find`](#Mongo-Collection-find) the documents in the
collection that match arbitrary criteria. The way these methods work is
compatible with the popular Mongo database API. The same database API
works on both the client and the server (see below).

```js
// Return an array of my messages.
const myMessages = await Messages.find({ userId: Meteor.userId() }).fetchAsync();

// Create a new message.
await Messages.insertAsync({ text: "Hello, world!" });

// Mark my first message as important.
await Messages.updateAsync(myMessages[0]._id, { $set: { important: true } });
```


If you pass a `name` when you create the collection, then you are
declaring a persistent collection &mdash; one that is stored on the
server and seen by all users. Client code and server code can both
access the same collection using the same API.

Specifically, when you pass a `name`, here's what happens:

- On the server (if you do not specify a `connection`), a collection with that
  name is created on a backend Mongo server. When you call methods on that
  collection on the server, they translate directly into normal Mongo operations
  (after checking that they match your [access control rules](#Mongo-Collection-allow)).

- On the client (and on the server if you specify a `connection`), a Minimongo
  instance is created. Minimongo is essentially an in-memory, non-persistent
  implementation of Mongo in pure JavaScript. It serves as a local cache that
  stores just the subset of the database that this client is working with. Queries
  ([`find`](#Mongo-Collection-find)) on these collections are served directly out of this cache,
  without talking to the server.

- When you write to the database on the client ([`insert`](#Mongo-Collection-insert),
  [`update`](#Mongo-Collection-update), [`remove`](#Mongo-Collection-remove)), the command is executed locally
  immediately, and, simultaneously, it's sent to the server and executed
  there too. This happens via [stubs](./meteor.md#meteor-methods), because writes are
  implemented as methods.

> When, on the server, you write to a collection which has a specified
> `connection` to another server, it sends the corresponding method to the other
> server and receives the changed values back from it over DDP. Unlike on the
> client, it does not execute the write locally first.

::: danger
On Meteor 3.x and later using `insert`, `update`, `upsert`,
`remove`, `findOne` on the server will throw and error. Use the
`*Async` counterparts instead.

For example, instead of `collection.insert(doc)`, use `collection.insertAsync(doc)`.
:::

If you pass a name to a client-only collection, it will not be synchronized
with the server and you need to populate the collection "manually" using the
low-level publication interface (`added/changed/removed`).
See [`added`](./meteor.md#Subscription-added) for more information.

If you pass `null` as the `name`, then you're creating a local
collection. It's not synchronized anywhere; it's just a local scratchpad
that supports Mongo-style [`find`](#Mongo-Collection-find), [`insert`](#Mongo-Collection-insert),
[`update`](#Mongo-Collection-update), and [`remove`](#Mongo-Collection-remove) operations. (On both the
client and the server, this scratchpad is implemented using Minimongo.)

By default, Meteor automatically publishes every document in your
collection to each connected client. To turn this behavior off, remove
the `autopublish` package, in your terminal:

```bash
meteor remove autopublish
```

and instead call [`Meteor.publish`](./meteor.md#Meteor-publish) to specify which parts of
your collection should be published to which users.

```js
// client.js
// Create a collection called `Posts` and put a document in it. The document
// will be immediately visible in the local copy of the collection. It will be
// written to the server-side database a fraction of a second later, and a
// fraction of a second after that, it will be synchronized down to any other
// clients that are subscribed to a query that includes it (see
// `Meteor.subscribe` and `autopublish`).
const Posts = new Mongo.Collection("posts");
Posts.insert({ title: "Hello world", body: "First post" });

// Changes are visible immediately—no waiting for a round trip to the server.
assert(Posts.find().count() === 1);

// Create a temporary, local collection. It works just like any other collection
// but it doesn't send changes to the server, and it can't receive any data from
// subscriptions.
const Scratchpad = new Mongo.Collection();

for (let i = 0; i < 10; i += 1) {
  Scratchpad.insert({ number: i * 2 });
}

assert(Scratchpad.find({ number: { $lt: 9 } }).count() === 5);
```

Generally, you'll assign `Mongo.Collection` objects in your app to global
variables. You can only create one `Mongo.Collection` object for each
underlying Mongo collection.

If you specify a `transform` option to the `Collection` or any of its retrieval
methods, documents are passed through the `transform` function before being
returned or passed to callbacks. This allows you to add methods or otherwise
modify the contents of your collection from their database representation. You
can also specify `transform` on a particular `find`, `findOne`, `allow`, or
`deny` call. Transform functions must return an object and they may not change
the value of the document's `_id` field (though it's OK to leave it out).

```js
// An animal class that takes a document in its constructor.
class Animal {
  constructor(doc) {
    _.extend(this, doc);
  }

  makeNoise() {
    console.log(this.sound);
  }
}

// Define a collection that uses `Animal` as its document.
const Animals = new Mongo.Collection("animals", {
  transform: (doc) => new Animal(doc),
});

// Create an animal and call its `makeNoise` method.
Animals.insert({ name: "raptor", sound: "roar" });
Animals.findOne({ name: "raptor" }).makeNoise(); // Prints 'roar'
```

`transform` functions are not called reactively. If you want to add a
dynamically changing attribute to an object, do it with a function that computes
the value at the time it's called, not by computing the attribute at `transform`
time.

::: warning
In this release, Minimongo has some limitations:

- `$pull` in modifiers can only accept certain kinds
  of selectors.
- `findAndModify`, aggregate functions, and
  map/reduce aren't supported.

All of these will be addressed in a future release. For full
Minimongo release notes, see packages/minimongo/NOTES
in the repository.
:::


::: warning
Minimongo doesn't currently have indexes. It's rare for this to be an
issue, since it's unusual for a client to have enough data that an
index is worthwhile.
:::

Use the `resolverType` option to determine the default method for resolving the functions of the collection methods. In Meteor 3.x, a distinction exists between stub and server promises on call methods. The former handles client simulation and minimongo population, while the latter solely manages success or error on the server call without populating the data in minimongo. The resolverType option offers `stub` and `server` values.

This option is particularly useful on test environments to maintain isomorphic code without needing to manage different code for the server and stub scenarios.

```javascript
const Greetings = new Meteor.Collection('greetUser', { resolverType: 'stub' });
    
await Greetings.insertAsync({ test: 1 });

// 🔵 Client simulation
Greetings.findOne({ name: 'John' }); // 🧾 Data is available (Optimistic-UI)
```

Read more about server and stub promises on calling methods, [please refer to the docs](./meteor.md#Meteor-callAsync).

Read more about collections and how to use them in the [Collections](http://guide.meteor.com/collections.html) article in the Meteor Guide.


<ApiBox name="Mongo.Collection#find" instanceName="Collection"/>


`find` returns a cursor. It does not immediately access the database or return
documents. Cursors provide `fetch` to return all matching documents, `map` and
`forEach` to iterate over all matching documents, and `observeAsync` and
`observeChangesAsync` to register callbacks when the set of matching documents
changes. Cursors also implement ES2015's [iteration protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).

::: warning
Collection cursors are not query snapshots. If the database changes
between calling `Collection.find` and fetching the
results of the cursor, or while fetching results from the cursor,
those changes may or may not appear in the result set.
:::

Cursors are a reactive data source. On the client, the first time you retrieve a
cursor's documents with `fetch`, `map`, or `forEach` inside a
reactive computation (eg, a template or
[`autorun`](./Tracker.md#Tracker-autorun)), Meteor will register a
dependency on the underlying data. Any change to the collection that
changes the documents in a cursor will trigger a recomputation. To
disable this behavior, pass `{reactive: false}` as an option to
`find`.

Note that when `fields` are specified, only changes to the included
fields will trigger callbacks in `observeAsync`, `observeChangesAsync` and
invalidations in reactive computations using this cursor. Careful use
of `fields` allows for more fine-grained reactivity for computations
that don't depend on an entire document.

On the client, there will be a period of time between when the page loads and
when the published data arrives from the server during which your client-side
collections will be empty.


<ApiBox name="Mongo.Collection#findOne"  instanceName="Collection"/>

::: warning
Client only.
For server/isomorphic usage see [findOneAsync](#Mongo-Collection-findOneAsync).
:::

Equivalent to [`find`](#Mongo-Collection-find)`(selector, options).`[`fetch`](#Mongo-Cursor-fetch)`()[0]` with
`options.limit = 1`.

<ApiBox name="Mongo.Collection#findOneAsync" instanceName="Collection"/>

Async version of [`findOne`](#Mongo-Collection-findOne) that return a `Promise`.

<ApiBox name="Mongo.Collection#countDocuments" instanceName="Collection"/>

Similar to `cursor.count`, but returns a `Promise`. For a faster version, see `estimatedDocumentCount`.

<ApiBox name= "Mongo.Collection#estimatedDocumentCount" instanceName="Collection"/>

Returns a `Promise` that resolves to the number of documents in the cursor's result set. The count is an estimate and not guaranteed to be exact.

<ApiBox name="Mongo.Collection#insert" instanceName="Collection"/>

::: warning
Client only.
For server/isomorphic usage see [insertAsync](#Mongo-Collection-insertAsync).
:::

Add a document to the collection. A document is just an object, and
its fields can contain any combination of EJSON-compatible datatypes
(arrays, objects, numbers, strings, `null`, true, and false).

`insert` will generate a unique ID for the object you pass, insert it
in the database, and return the ID. When `insert` is called from
untrusted client code, it will be allowed only if passes any
applicable [`allow`](#Mongo-Collection-allow) and [`deny`](#Mongo-Collection-deny) rules.

On the server, it should be used `insertAsync` that will return a promise with the `ID` of your
object.

On the client, `insert` never blocks. If you do not provide a callback
and the insert fails on the server, then Meteor will log a warning to
the console. If you provide a callback, Meteor will call that function
with `error` and `result` arguments. In an error case, `result` is
undefined. If the insert is successful, `error` is undefined and
`result` is the new document ID.

Example:

```js
const groceriesId = Lists.insert({ name: "Groceries" });

Items.insert({ list: groceriesId, name: "Watercress" });
Items.insert({ list: groceriesId, name: "Persimmons" });
```


<ApiBox name="Mongo.Collection#insertAsync" instanceName="Collection"/>

Async version of [`insert`](#Mongo-Collection-insert) that return a `Promise`.

<ApiBox name="Mongo.Collection#update" instanceName="Collection"/>

::: warning
Client only.
For server/isomorphic usage see [updateAsync](#Mongo-Collection-updateAsync).
:::

Modify documents that match `selector` according to `modifier` (see
[modifier documentation](#modifiers)).

The behavior of `update` differs depending on whether it is called by
trusted or untrusted code. Trusted code includes server code and
method code. Untrusted code includes client-side code such as event
handlers and a browser's JavaScript console.

- Trusted code can modify multiple documents at once by setting
  `multi` to true, and can use an arbitrary [Mongo
  selector](#selectors) to find the documents to modify. It bypasses
  any access control rules set up by [`allow`](#Mongo-Collection-allow) and
  [`deny`](#Mongo-Collection-deny). The number of affected documents will be returned
  from the `update` call if you don't pass a callback.

- Untrusted code can only modify a single document at once, specified
  by its `_id`. The modification is allowed only after checking any
  applicable [`allow`](#Mongo-Collection-allow) and [`deny`](#Mongo-Collection-deny) rules. The number
  of affected documents will be returned to the callback. Untrusted
  code cannot perform upserts, except in insecure mode.

On the server, it should be used `updateAsync`.

On the client, `update` never blocks. If you do not provide a callback
and the update fails on the server, then Meteor will log a warning to
the console. If you provide a callback, Meteor will call that function
with an error argument if there was an error, or a second argument
indicating the number of affected documents if the update was successful.

::: code-group

```js [server.js]
// Give the 'Winner' badge to each user with a score greater than 10. If they
// are logged in and their badge list is visible on the screen, it will update
// automatically as they watch.
Meteor.methods({
  async declareWinners() {
    await Players.updateAsync(
      { score: { $gt: 10 } },
      {
        $addToSet: { badges: "Winner" },
      },
      { multi: true }
    );
  },
});
```

```js [client.js]
// When the 'give points' button in the admin dashboard is pressed, give 5
// points to the current player. The new score will be immediately visible on
// everyone's screens.
Template.adminDashboard.events({
  "click .give-points"() {
    Players.update(Session.get("currentPlayer"), {
      $inc: { score: 5 },
    });
  },
});
```


You can use `update` to perform a Mongo upsert by setting the `upsert`
option to true. You can also use the [`upsert`](#Mongo-Collection-upsert) method to perform an
upsert that returns the `_id` of the document that was inserted (if there was one)
in addition to the number of affected documents.

<ApiBox name="Mongo.Collection#updateAsync" instanceName="Collection"/>

Async version of [`update`](#Mongo-Collection-update) that return a `Promise`.

<ApiBox name="Mongo.Collection#upsert" instanceName="Collection"/>

::: warning
Client only.
For server/isomorphic usage see [upsertAsync](#Mongo-Collection-upsertAsync).
:::

Modify documents that match `selector` according to `modifier`, or insert
a document if no documents were modified. `upsert` is the same as calling
`update` with the `upsert` option set to true, except that the return
value of `upsert` is an object that contain the keys `numberAffected`
and `insertedId`. (`update` returns only the number of affected documents.)

<ApiBox name="Mongo.Collection#upsertAsync" instanceName="Collection"/>

Async version of [`upsert`](#Mongo-Collection-upsert) that return a `Promise`.

<ApiBox name="Mongo.Collection#remove" instanceName="Collection"/>

::: warning
Client only.
For server/isomorphic usage see [removeAsync](#Mongo-Collection-removeAsync).
:::

Find all of the documents that match `selector` and delete them from
the collection.

The behavior of `remove` differs depending on whether it is called by
trusted or untrusted code. Trusted code includes server code and
method code. Untrusted code includes client-side code such as event
handlers and a browser's JavaScript console.

- Trusted code can use an arbitrary [Mongo selector](#selectors) to
  find the documents to remove, and can remove more than one document
  at once by passing a selector that matches multiple documents. It
  bypasses any access control rules set up by [`allow`](#Mongo-Collection-allow) and
  [`deny`](#Mongo-Collection-deny). The number of removed documents will be returned
  from `remove` if you don't pass a callback.

  As a safety measure, if `selector` is omitted (or is `undefined`),
  no documents will be removed. Set `selector` to `{}` if you really
  want to remove all documents from your collection.

- Untrusted code can only remove a single document at a time,
  specified by its `_id`. The document is removed only after checking
  any applicable [`allow`](#Mongo-Collection-allow) and [`deny`](#Mongo-Collection-deny) rules. The
  number of removed documents will be returned to the callback.

On the server, it should be used `removeAsync`.

On the client, `remove` never blocks. If you do not provide a callback
and the remove fails on the server, then Meteor will log a warning to the
console. If you provide a callback, Meteor will call that function with an
error argument if there was an error, or a second argument indicating the number
of removed documents if the remove was successful.

::: code-group

```js [server.js]
// When the server starts, clear the log and delete all players with a karma of
// less than -2.
Meteor.startup(async () => {
  if (Meteor.isServer) {
    await Logs.removeAsync({});
    await Players.removeAsync({ karma: { $lt: -2 } });
  }
});
```

```js [client.js]
// When the 'remove' button is clicked on a chat message, delete that message.
Template.chat.events({
  "click .remove"() {
    Messages.remove(this._id);
  },
});
```

:::



<ApiBox name="Mongo.Collection#removeAsync" instanceName="Collection"/>

Async version of [`remove`](#Mongo-Collection-remove) that return a `Promise`.

<ApiBox name="Mongo.Collection#createIndex" instanceName="Collection"/>

For efficient and performant queries you will sometimes need to define indexes other than the default `_id` field.
You should add indexes to fields (or combinations of fields) you use to lookup documents in a collection.
This is where `createIndex` comes into play. It takes in 2 objects. First is the key and index type specification (which field and how they should be indexed) and second are options like the index name.
For details on how indexes work read the [MongoDB documentation](https://docs.mongodb.com/manual/indexes/).

> Note that indexes only apply to server and MongoDB collection. They are not implemented for Minimongo at this time.

Example defining a simple index on Players collection in Meteor:

```js
Players.createIndex({ userId: 1 }, { name: "user reference on players" });
```



Sometimes you or a package might change an already established indexes. This might throw an error and prevent a startup.
For cases where you can afford to re-build indexes or the change affect too many indexes you can set the `reCreateIndexOnOptionMismatch`
to true in your `settings.json`:

```json
{
  "packages": {
    "mongo": {
      "reCreateIndexOnOptionMismatch": true
    }
  }
}
```

> You should use this option only when you are dealing with a change across many indexes and it is not feasible to fix them manually and you can afford the re-building of the indexes as this will destroy the old index and create a new one. Use this carefully.

<ApiBox name="Mongo.Collection#createIndexAsync" instanceName="Collection"/>

Async version of [`createIndex`](#Mongo-Collection-createIndex) that return a `Promise`.

<ApiBox name="Mongo.Collection#allow" instanceName="Collection"/>


::: warning
While `allow` and `deny` make it easy to get started building an app, it's
harder than it seems to write secure `allow` and `deny` rules. We recommend
that developers avoid `allow` and `deny`, and switch directly to custom methods
once they are ready to remove `insecure` mode from their app. See
[the Meteor Guide on security](https://guide.meteor.com/security.html#allow-deny)
for more details.
:::

When a client calls `insert`/`insertAsync`, `update`/`updateAsync`, `remove`/`removeAsync`
on a collection, the collection's `allow` and [`deny`](#Mongo-Collection-deny) callbacks
are called on the server to determine if the write should be allowed. If at least
one `allow` callback allows the write, and no `deny` callbacks deny the
write, then the write is allowed to proceed.

These checks are run only when a client tries to write to the database
directly, for example by calling `update`/`updateAsync` from inside an event
handler. Server code is trusted and isn't subject to `allow` and `deny`
restrictions. That includes methods that are called with `Meteor.call`
&mdash; they are expected to do their own access checking rather than
relying on `allow` and `deny`.

You can call `allow` as many times as you like, and each call can
include any combination of `insert`, `update`,
and `remove` functions. The functions should return `true`
if they think the operation should be allowed. Otherwise they should
return `false`, or nothing at all (`undefined`). In that case Meteor
will continue searching through any other `allow` rules on the collection.

The available callbacks are:

### Callbacks

- `insert(userId, doc)` - The user `userId` wants to insert the
  document `doc` into the collection. Return `true` if this should be
  allowed. Supports async validations.

  `doc` will contain the `_id` field if one was explicitly set by the client, or
  if there is an active `transform`. You can use this to prevent users from
  specifying arbitrary `_id` fields.

- `update(userId, doc, fieldNames, modifier)` - The user `userId`
  wants to update a document `doc` in the database. (`doc` is the
  current version of the document from the database, without the
  proposed update.) Return `true` to permit the change. Supports async validations.

  `fieldNames` is an array of the (top-level) fields in `doc` that the
  client wants to modify, for example
  `['name', 'score']`.

  `modifier` is the raw Mongo modifier that
  the client wants to execute; for example,
  `{ $set: { 'name.first': 'Alice' }, $inc: { score: 1 } }`.

  Only Mongo modifiers are supported (operations like `$set` and `$push`).
  If the user tries to replace the entire document rather than use
  \$-modifiers, the request will be denied without checking the `allow`
  functions.

- `remove(userId, doc)` - the user `userId` wants to remove `doc` from the database. Return
  `true` to permit this. Supports async validations.


When calling `update`/`updateAsync` or `remove`/`removeAsync` Meteor will by default fetch the
entire document `doc` from the database. If you have large documents
you may wish to fetch only the fields that are actually used by your
functions. Accomplish this by setting `fetch` to an array of field
names to retrieve.

Example:

```js
// Create a collection where users can only modify documents that they own.
// Ownership is tracked by an `owner` field on each document. All documents must
// be owned by the user that created them and ownership can't be changed. Only a
// document's owner is allowed to delete it, and the `locked` attribute can be
// set on a document to prevent its accidental deletion.
const Posts = new Mongo.Collection("posts");

Posts.allow({
  insert(userId, doc) {
    // The user must be logged in and the document must be owned by the user.
    return userId && doc.owner === userId;
  },

  update(userId, doc, fields, modifier) {
    // Can only change your own documents.
    return doc.owner === userId;
  },

  async remove(userId, doc) {
    // Any custom async validation is supported
    await Meteor.sleep(100);
    // Can only remove your own documents.
    return doc.owner === userId;
  },

  fetch: ["owner"],
});

Posts.deny({
  update(userId, doc, fields, modifier) {
    // Can't change owners.
    return _.contains(fields, "owner");
  },

  async remove(userId, doc) {
    // Any custom async validation is supported
    await Meteor.sleep(100);
    // Can't remove locked documents.
    return doc.locked;
  },

  fetch: ["locked"], // No need to fetch `owner`
});
```

If you never set up any `allow` rules on a collection then all client
writes to the collection will be denied, and it will only be possible to
write to the collection from server-side code. In this case you will
have to create a method for each possible write that clients are allowed
to do. You'll then call these methods with `Meteor.call` rather than
having the clients call `insert`/`insertAsync`, `update`/`updateAsync`,
and `remove`/`removeAsync` directly on the
collection.


Meteor also has a special "insecure mode" for quickly prototyping new
applications. In insecure mode, if you haven't set up any `allow` or `deny`
rules on a collection, then all users have full write access to the
collection. This is the only effect of insecure mode. If you call `allow` or
`deny` at all on a collection, even `Posts.allow({})`, then access is checked
just like normal on that collection. **New Meteor projects start in insecure
mode by default.** To turn it off just run in your terminal:

```bash
meteor remove insecure
```

<ApiBox name="Mongo.Collection#deny" instanceName="Collection"/>

::: warning
While `allow` and `deny` make it easy to get started building an app, it's
harder than it seems to write secure `allow` and `deny` rules. We recommend
that developers avoid `allow` and `deny`, and switch directly to custom methods
once they are ready to remove `insecure` mode from their app. See
[the Meteor Guide on security](https://guide.meteor.com/security.html#allow-deny)
for more details.
:::

This works just like [`allow`](#Mongo-Collection-allow), except it lets you
make sure that certain writes are definitely denied, even if there is an
`allow` rule that says that they should be permitted.

When a client tries to write to a collection, the Meteor server first
checks the collection's `deny` rules. If none of them return true then
it checks the collection's `allow` rules. Meteor allows the write only
if no `deny` rules return `true` and at least one `allow` rule returns
`true`.

<ApiBox name="Mongo.Collection#rawCollection" instanceName="Collection"/>

The methods (like `update` or `insert`) you call on the resulting _raw_ collection return promises and can be used outside of a Fiber.

<ApiBox name="Mongo.Collection#rawDatabase" instanceName="Collection"/>


## Cursors {#mongo_cursor}

To create a cursor, use [`find`](#Mongo-Collection-find). To access the documents in a
cursor, use [`forEach`](#Mongo-Cursor-forEach), [`map`](##Mongo-Cursor-map), [`fetch`](#Mongo-Cursor-fetch),
[`forEachAsync`](#Mongo-Cursor-forEachAsync), [`mapAsync`](#Mongo-Cursor-mapAsync), [`fetchAsync`](#Mongo-Cursor-fetchAsync) or ES2015's [iteration protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).

<ApiBox name="Mongo.Cursor#forEach" instanceName="Cursor"/>

This interface is compatible with [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).

When called from a reactive computation, `forEach` registers dependencies on
the matching documents.

Examples:

```js
// Print the titles of the five top-scoring posts.
const topPosts = Posts.find({}, { sort: { score: -1 }, limit: 5 });
let count = 0;

topPosts.forEach((post) => {
  console.log(`Title of post ${count}: ${post.title}`);
  count += 1;
});
```

::: warning
Client only.
For server/isomorphic usage see [forEachAsync](#Mongo-Cursor-forEachAsync).
:::

<ApiBox name="Mongo.Cursor#forEachAsync" instanceName="Cursor"/>

Async version of [`forEach`](#Mongo-Cursor-forEach) that return a `Promise`.

The same example as from `forEach` but using `forEachAsync`:

```js

// Print the titles of the five top-scoring posts.
const topPosts = Posts.find({}, { sort: { score: -1 }, limit: 5 });
let count = 0;

await topPosts.forEachAsync((post) => {
  console.log(`Title of post ${count}: ${post.title}`);
  count += 1;
});

console.log("All done!"); // This will be printed after all the posts are printed.

```

<ApiBox name="Mongo.Cursor#map" instanceName="Cursor"/>

This interface is compatible with [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).

When called from a reactive computation, `map` registers dependencies on
the matching documents.

<!-- The following is not yet implemented, but users shouldn't assume
     sequential execution anyway because that will break. -->

On the server, if `callback` yields, other calls to `callback` may occur while
the first call is waiting. If strict sequential execution is necessary, use
`forEach` instead.

::: warning
Client only.
For server/isomorphic usage see [mapAsync](#Mongo-Cursor-mapAsync).
:::


<ApiBox name="Mongo.Cursor#mapAsync" instanceName="Cursor" />

Async version of [`map`](#Mongo-Cursor-map) that return a `Promise`.

<ApiBox name="Mongo.Cursor#fetch" instanceName="Cursor"/>

When called from a reactive computation, `fetch` registers dependencies on
the matching documents.

::: warning
Client only.
For server/isomorphic usage see [fetchAsync](#Mongo-Cursor-fetchAsync).
:::

<ApiBox name="Mongo.Cursor#fetchAsync" instanceName="Cursor"/>

Async version of [`fetch`](#Mongo-Cursor-fetch) that return a `Promise`.

<ApiBox name="Mongo.Cursor#count" instanceName="Cursor"/>


Unlike the other functions, `count` registers a dependency only on the
number of matching documents. (Updates that just change or reorder the
documents in the result set will not trigger a recomputation.)

::: warning
Client only.
For server/isomorphic usage see [countAsync](#Mongo-Cursor-countAsync).
:::

<ApiBox name="Mongo.Cursor#countAsync" instanceName="Cursor"/>

Async version of [`count`](#Mongo-Cursor-count) that return a `Promise`.

<ApiBox name="Mongo.Cursor#observeAsync" instanceName="Cursor"/>

Establishes a _live query_ that invokes callbacks when the result of
the query changes. The callbacks receive the entire contents of the
document that was affected, as well as its old contents, if
applicable. If you only need to receive the fields that changed, see
[`observeChangesAsync`](#Mongo-Cursor-observeChangesAsync).

`callbacks` may have the following functions as properties:


### Callbacks

- `added(document)` or `addedAt(document, atIndex, before)`
  A new document `document` entered the result set. The new document
  appears at position `atIndex`. It is immediately before the document
  whose `_id` is `before`. `before` will be `null` if the new document
  is at the end of the results.

- `changed(newDocument, oldDocument)` or `changedAt(newDocument, oldDocument, atIndex)`
  The contents of a document were previously `oldDocument` and are now
  `newDocument`. The position of the changed document is `atIndex`.

- `removed(oldDocument)` or `removedAt(oldDocument, atIndex)`
  The document `oldDocument` is no longer in the result set. It used
  to be at position `atIndex`.

- `movedTo(document, fromIndex, toIndex, before)`
  A document changed its position in the result set, from `fromIndex`
  to `toIndex` (which is before the document with id `before`). Its
  current contents is `document`.

Use `added`, `changed`, and `removed` when you don't care about the
order of the documents in the result set. They are more efficient than
`addedAt`, `changedAt`, and `removedAt`.

Before `observeAsync` returns, `added` (or `addedAt`) will be called zero
or more times to deliver the initial results of the query.


`observeAsync` returns a promise of the live query handle, which is an object with a `stop` method.
Call `stop` with no arguments to stop calling the callback functions and tear
down the query. **The query will run forever until you call this.** If
`observeAsync` is called from a `Tracker.autorun` computation, it is automatically
stopped when the computation is rerun or stopped.

::: tip
`observeAsync` is recommended to keep code isomorphism in the client and server.

`observe` stays sync for easier client-side handler management.
:::

(If the cursor was created with the option `reactive` set to false, it will
only deliver the initial results and will not call any further callbacks;
it is not necessary to call `stop` on the handle.)


<ApiBox name="Mongo.Cursor#observeChangesAsync" instanceName="Cursor"/>

Establishes a _live query_ that invokes callbacks when the result of
the query changes. In contrast to [`observeAsync`](#Mongo-Cursor-observeAsync),
`observeChangesAsync` provides only the difference between the old and new
result set, not the entire contents of the document that changed.

`callbacks` may have the following functions as properties:

### Callbacks


- `added(id, fields)` or `addedBefore(id, fields, before)`
  A new document entered the result set. It has the `id` and `fields`
  specified. `fields` contains all fields of the document excluding the
  `_id` field. The new document is before the document identified by
  `before`, or at the end if `before` is `null`.

- `changed(id, fields)`
  The document identified by `id` changed its contents. `fields`
  contains the changed fields with their new values. If a field was
  removed from the document then it will be present in `fields` with a
  value of `undefined`.

- `removed(id)`
  The document identified by `id` is no longer in the result set.

- `movedBefore(id, before)`
  The document identified by `id` changed its position in the result
  set, and now appears before the document identified by `before`.

`observeChangesAsync` is significantly more efficient if you do not use
`addedBefore` or `movedBefore`.

Before `observeChangesAsync` returns, `added` (or `addedBefore`) will be called
zero or more times to deliver the initial results of the query.

`observeChangesAsync` returns a promise of the live query handle, which is an object with a `stop`
method. Call `stop` with no arguments to stop calling the callback functions
and tear down the query. **The query will run forever until you call this.**
If
`observeChangesAsync` is called from a `Tracker.autorun` computation, it is automatically
stopped when the computation is rerun or stopped.

::: tip
`observeChangesAsync` is recommended to keep code isomorphism in the client and server.

`observeChanges` stays sync for easier client-side handler management.
:::

(If the cursor was created with the option `reactive` set to false, it will
only deliver the initial results and will not call any further callbacks;
it is not necessary to call `stop` on the handle.)

> Unlike `observeAsync`, `observeChangesAsync` does not provide absolute position
> information (that is, `atIndex` positions rather than `before`
> positions.) This is for efficiency.

Example:

```js
// Keep track of how many administrators are online.
let count = 0;
const cursor = Users.find({ admin: true, onlineNow: true });

const handle = await cursor.observeChangesAsync({
  added(id, user) {
    count += 1;
    console.log(`${user.name} brings the total to ${count} admins.`);
  },

  removed() {
    count -= 1;
    console.log(`Lost one. We're now down to ${count} admins.`);
  },
});

// After five seconds, stop keeping the count.
setTimeout(() => handle.stop(), 5000);
```

<ApiBox name="Mongo.getCollection" />
<ApiBox name="Mongo.ObjectID" />


`Mongo.ObjectID` follows the same API as the [Node MongoDB driver `ObjectID`](http://mongodb.github.io/node-mongodb-native/3.0/api/ObjectID.html)
class. Note that you must use the `equals` method (or [`EJSON.equals`](./EJSON.md#EJSON-equals)) to
compare them; the `===` operator will not work. If you are writing generic code
that needs to deal with `_id` fields that may be either strings or `ObjectID`s, use
[`EJSON.equals`](./EJSON.md#EJSON-equals) instead of `===` to compare them.

> `ObjectID` values created by Meteor will not have meaningful answers to their `getTimestamp`
> method, since Meteor currently constructs them fully randomly.



## Selectors {#selectors}

The simplest selectors are just a string or
[`Mongo.ObjectID`](#Mongo-ObjectID). These selectors match the
document with that value in its `_id` field.

A slightly more complex form of selector is an object containing a set of keys
that must match in a document:

```js
// Matches all documents where `deleted` is false.
{ deleted: false }

// Matches all documents where the `name` and `cognomen` are as given.
{ name: 'Rhialto', cognomen: 'the Marvelous' }

// Matches every document.
{}
```


But they can also contain more complicated tests:

```js
// Matches documents where `age` is greater than 18.
{
  age: {
    $gt: 18;
  }
}

// Matches documents where `tags` is an array containing 'popular'.
{
  tags: "popular";
}

// Matches documents where `fruit` is one of three possibilities.
{
  fruit: {
    $in: ["peach", "plum", "pear"];
  }
}
```

See the [complete documentation](http://docs.mongodb.org/manual/reference/operator/).

## Modifiers {#modifiers}


A modifier is an object that describes how to update a document in
place by changing some of its fields. Some examples:

```js
// Set the `admin` property on the document to true.
{ $set: { admin: true } }

// Add 2 to the `votes` property and add 'Traz' to the end of the `supporters`
// array.
{ $inc: { votes: 2 }, $push: { supporters: 'Traz' } }
```

But if a modifier doesn't contain any \$-operators, then it is instead
interpreted as a literal document, and completely replaces whatever was
previously in the database. (Literal document modifiers are not currently
supported by [validated updates](#Mongo-Collection-allow).)


```js
// Find the document with ID '123' and completely replace it.
Users.update({ _id: "123" }, { name: "Alice", friends: ["Bob"] });
```

See the [full list of modifiers](http://docs.mongodb.org/manual/reference/operator/update/).

## Sort specifiers {#sortspecifiers}

Sorts may be specified using your choice of several syntaxes:

```js
// All of these do the same thing (sort in ascending order by key `a`, breaking
// ties in descending order of key `b`).
[['a', 'asc'], ['b', 'desc']]
['a', ['b', 'desc']]
{ a: 1, b: -1 }

// Sorted by `createdAt` descending.
Users.find({}, { sort: { createdAt: -1 } });

// Sorted by `createdAt` descending and by `name` ascending.
Users.find({}, { sort: [['createdAt', 'desc'], ['name', 'asc']] });
```

The last form will only work if your JavaScript implementation
preserves the order of keys in objects. Most do, most of the time, but
it's up to you to be sure.

For local collections you can pass a comparator function which receives two
document objects, and returns -1 if the first document comes first in order,
1 if the second document comes first, or 0 if neither document comes before
the other. This is a Minimongo extension to MongoDB.

## Field specifiers {#fieldspecifiers}

Queries can specify a particular set of fields to include or exclude from the
result object.

To exclude specific fields from the result objects, the field specifier is a
dictionary whose keys are field names and whose values are `0`. All unspecified
fields are included.

```js
Users.find({}, { fields: { password: 0, hash: 0 } });
```

To include only specific fields in the result documents, use `1` as
the value. The `_id` field is still included in the result.

```js
Users.find({}, { fields: { firstname: 1, lastname: 1 } });
```

With one exception, it is not possible to mix inclusion and exclusion styles:
the keys must either be all 1 or all 0. The exception is that you may specify
`_id: 0` in an inclusion specifier, which will leave `_id` out of the result
object as well. However, such field specifiers can not be used with
[`observeChangesAsync`](#Mongo-Cursor-observeChangesAsync), [`observeAsync`](#Mongo-Cursor-observeAsync), cursors returned
from a [publish function](./meteor.md#Meteor-publish). They may be used with [`fetch`](#Mongo-Cursor-fetch),
[`findOne`](#Mongo-Collection-findOne), [`forEach`](#Mongo-Cursor-forEach), and [`map`](#Mongo-Cursor-map).

<a href="http://docs.mongodb.org/manual/reference/operator/projection/">Field
operators</a> such as `$` and `$elemMatch` are not available on the client side
yet.


A more advanced example:

```js
Users.insert({
  alterEgos: [
    { name: "Kira", alliance: "murderer" },
    { name: "L", alliance: "police" },
  ],
  name: "Yagami Light",
});

Users.findOne({}, { fields: { "alterEgos.name": 1, _id: 0 } });
// Returns { alterEgos: [{ name: 'Kira' }, { name: 'L' }] }
```



See <a href="http://docs.mongodb.org/manual/tutorial/project-fields-from-query-results/#projection">
the MongoDB docs</a> for details of the nested field rules and array behavior.

## Connecting to your database {#mongo_url}

When developing your application, Meteor starts a local MongoDB instance and
automatically connects to it. In production, you must specify a `MONGO_URL`
environment variable pointing at your database in [the standard mongo connection
string format](https://docs.mongodb.com/manual/reference/connection-string).

> You can also set `MONGO_URL` in development if you want to connect to a
> different MongoDB instance.

If you want to use oplog tailing for livequeries, you should also set
`MONGO_OPLOG_URL` (generally you'll need a special user with oplog access, but
the detail can differ depending on how you host your MongoDB. Read more [here](https://github.com/meteor/docs/blob/master/long-form/oplog-observe-driver.md)).

> As of Meteor 1.4, you must ensure you set the `replicaSet` parameter on your
> `METEOR_OPLOG_URL`

## MongoDB connection options {#mongo_connection_options}

MongoDB provides many connection options, usually the default works but in some
cases you may want to pass additional options. You can do it in two ways:

### Meteor settings {#mongo_connection_options_settings}

You can use your Meteor settings file to set the options in a property called
`options` inside `packages` > `mongo`, these values will be provided as options for MongoDB in
the connect method.

> this option was introduced in Meteor 1.10.2

For example, you may want to specify a certificate for your
TLS connection ([see the options here](https://mongodb.github.io/node-mongodb-native/3.5/tutorials/connect/tls/)) then you could use these options:

```json
  "packages": {
    "mongo": {
      "options": {
        "tls": true,
        "tlsCAFileAsset": "certificate.pem"
      }
    }
  }
```

Meteor will convert relative paths to absolute paths if the option name (key)
ends with `Asset`, for this to work properly you need to place the files in the
`private` folder in the root of your project. In the example Mongo connection would
receive this:

```json
  "packages": {
    "mongo": {
      "options": {
        "tls": true,
        "tlsCAFile": "/absolute/path/certificate.pem"
      }
    }
  }
```

See that the final option name (key) does not contain `Asset` in the end as
expected by MongoDB.

This configuration is necessary in some MongoDB host providers to avoid this
error `MongoNetworkError: failed to connect to server [sg-meteorappdb-32194.servers.mongodirector.com:27017] on first connect [Error: self signed certificate`.

Another way to avoid this error is to allow invalid certificates with this
option:

```json
  "packages": {
    "mongo": {
      "options": {
        "tlsAllowInvalidCertificates": true
      }
    }
  }
```

You can pass any MongoDB valid option, these are just examples using
certificates configurations.

If you're using a certificate and having authentication errors when trying to connect to a database other than `admin`, make sure to provide the flags `&ssl=true&authSource=admin`. You MONGO_URL string should look like this:

```
mongodb://<username>:<password>@[server-1],[server-2],[server-3]/my-database?replicaSet=my-replica&ssl=true&authSource=admin
```

### Mongo Oplog Options {#mongo-oplog-options}

> Oplog options were introduced in Meteor 2.15.1
If you set the [`MONGO_OPLOG_URL`](/cli/environment-variables.html#mongo-oplog-url) env var, Meteor will use MongoDB's Oplog to show efficient, real time updates to your users via your subscriptions.

Due to how Meteor's Oplog implementation is built behind the scenes, if you have certain collections where you expect **big amounts of write operations**, this might lead to **big CPU spikes on your meteor app server, even if you have no publications/subscriptions on any data/documents of these collections**. For more information on this, please have a look into [this blog post from 2016](https://blog.meteor.com/tuning-meteor-mongo-livedata-for-scalability-13fe9deb8908), [this github discussion from 2022](https://github.com/meteor/meteor/discussions/11842) or [this meteor forums post from 2023](https://forums.meteor.com/t/cpu-spikes-due-to-oplog-updates-without-subscriptions/60028).

To solve this, **2 Oplog settings** have been introduced **to tweak, which collections are *watched* or *ignored* in the oplog**.

**Exclusion**: To *exclude* for example all updates/inserts of documents in the 2 collections called `products` and `prices`, you would need to set the following setting in your Meteor settings file:

```json
  "packages": {
    "mongo": {
      "oplogExcludeCollections": ["products", "prices"]
    }
  }
```

**Inclusion**: vice versa, if you only want to watch/*include* the oplog for changes on documents in the 2 collections `chats` and `messages`, you would use:

```json
  "packages": {
    "mongo": {
      "oplogIncludeCollections": ["chats", "messages"]
    }
  }
```

For obvious reasons, using both `oplogExcludeCollections` and `oplogIncludeCollections` at the same time is not possible and will result in an error.

### Mongo.setConnectionOptions(options)

You can also call `Mongo.setConnectionOptions` to set the connection options but
you need to call it before any other package using Mongo connections is
initialized so you need to add this code in a package and add it above the other
packages, like accounts-base in your `.meteor/packages` file.

> this option was introduced in Meteor 1.4

---

---
url: /cli/index.md
---
# Command Line
Documentation of the various command line options of the Meteor tool.

---

The following are some of the more commonly used commands in the `meteor`
command-line tool. This is just an overview and does not mention every command
or every option to every command; for more details, use the `meteor help`
command.

## meteor help {#meteorhelp}

Get help on meteor command line usage.

```bash
meteor help
```

Lists the common meteor commands.

```bash
meteor help <command>
```

Prints detailed help about the specific command.

## meteor run {#meteorrun}

Run a meteor development server in the current project.

```bash
meteor run
```

::: tip
This is the default command. Simply running `meteor` is the same as `meteor run`.
:::

### Features

- Automatically detects and applies changes to your application's source files
- No Internet connection required
- Accesses the application at [localhost:3000](http://localhost:3000) by default
- Searches upward from the current directory for the root directory of a Meteor project

### Options

| Option | Description |
|--------|-------------|
| `--port`, `-p <port>` | Port to listen on (default: 3000). Also uses port N+1 and a port specified by --app-port. Specify as --port=host:port to bind to a specific interface |
| `--open`, `-o` | Opens a browser window when the app starts |
| `--inspect[-brk][=<port>]` | Enable server-side debugging via debugging clients. With --inspect-brk, pauses at startup (default port: 9229) |
| `--mobile-server <url>` | Location where mobile builds connect (defaults to local IP and port). Can include URL scheme (e.g., https://example.com:443) |
| `--cordova-server-port <port>` | Local port where Cordova will serve content |
| `--production` | Simulate production mode. Minify and bundle CSS and JS files |
| `--raw-logs` | Run without parsing logs from stdout and stderr |
| `--settings`, `-s <file>` | Set optional data for Meteor.settings on the server |
| `--release <version>` | Specify the release of Meteor to use |
| `--verbose` | Print all output from builds logs |
| `--no-lint` | Don't run linters used by the app on every rebuild |
| `--no-release-check` | Don't run the release updater to check for new releases |
| `--allow-incompatible-update` | Allow packages to be upgraded or downgraded to potentially incompatible versions |
| `--extra-packages <packages>` | Run with additional packages (comma separated, e.g., "package-name1, package-name2@1.2.3") |
| `--exclude-archs <archs>` | Don't create bundles for certain web architectures (comma separated, e.g., "web.browser.legacy, web.cordova") |

### Node.js Options

To pass additional options to Node.js, use the `SERVER_NODE_OPTIONS` environment variable:

**Windows PowerShell:**
```powershell
$env:SERVER_NODE_OPTIONS = '--inspect' | meteor run
```

**Linux/macOS:**
```bash
SERVER_NODE_OPTIONS=--inspect-brk meteor run
```

### Port Configuration Example

```bash
meteor run --port 4000
```

This command:
- Runs the development server on `http://localhost:4000`
- Runs the development MongoDB instance on `mongodb://localhost:4001`

::: info
The development server always uses port `N+1` for the default MongoDB instance, where `N` is the application port.
:::

## meteor debug {#meteordebug}

Run the project with the server process suspended for debugging.

::: warning Deprecation Notice
The `meteor debug` command has been superseded by the more flexible `--inspect` and `--inspect-brk` command-line flags, which work with `run`, `test`, and `test-packages` commands.
:::

### Modern Debugging Approach

```bash
# Debug server with auto-attachment
meteor run --inspect

# Debug server and pause at start
meteor run --inspect-brk
```

### Command Usage

```bash
meteor debug [--debug-port <port>]
```

### How It Works

- Server process suspends just before the first statement of server code execution
- Debugger listens for incoming connections on port 5858 by default
- Use `--debug-port <port>` to specify a different port

### Setting Breakpoints

- Use the [`debugger`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger) keyword in your code
- Set breakpoints through the debugging client's UI (e.g., in the "Sources" tab)

### Debugging Clients

You can use either:
- Web-based Node Inspector
- Command-line debugger

::: details Node Inspector Console Bug
Due to a [bug in `node-inspector`](https://github.com/node-inspector/node-inspector/issues/903), pressing "Enter" after a command in the Node Inspector Console may not successfully send the command to the server.

**Workarounds:**
- Use Safari browser
- Use `meteor shell` to interact with the server console
- Apply the hot-patch available in [this comment](https://github.com/meteor/meteor/issues/7991#issuecomment-266709459)
:::

### Differences from Node.js Flags

The Meteor `--inspect` and `--inspect-brk` flags work similarly to Node.js flags with two key differences:

1. They affect the server process spawned by the build process, not the build process itself
2. The `--inspect-brk` flag pauses execution after server code has loaded but before it begins to execute

### Alternative Approach

The same debugging functionality can be achieved by adding the `--debug-port <port>` option to other Meteor commands:

```bash
meteor run --debug-port 5858
meteor test-packages --debug-port 5858
```

## meteor profile {#meteorprofile}

Run a performance profile for your Meteor application to analyze build and bundling performance.

```bash
meteor profile [<meteor-run-options>...]
```

::: info Availability
This command is available from Meteor 3.2 and newer.
:::

### Usage

This command monitors the bundler process and tracks key performance metrics to help analyze build and bundling performance.

### Options

| Option        | Description                          |
|---------------|--------------------------------------|
| `--size`      | Monitor both bundle runtime and size |
| `--size-only` | Monitor only the bundle size         |
| `--build`     | Monitor build time                   |

::: info
All other options from `meteor run` are also supported (e.g., `--settings`, `--exclude-archs`).
If you use the --build option, it also accepts meteor build flags (e.g. `--mobile-settings`, `--architecture`).
:::

### Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `METEOR_IDLE_TIMEOUT=<seconds>` | Set a timeout for profiling | 90 seconds |
| `METEOR_CLIENT_ENTRYPOINT=<path>` | Set a custom client entrypoint | From package.json |
| `METEOR_SERVER_ENTRYPOINT=<path>` | Set a custom server entrypoint | From package.json |
| `METEOR_LOG_DIR=<path>` | Set a custom log directory | Default log directory |

::: tip
The default timeout (90s) is usually enough for each build step to complete. If you encounter errors due to early exits, increase the `METEOR_IDLE_TIMEOUT` value.
:::

### Example Usage

```bash
# Basic profile
meteor profile

# Monitor bundle size only
meteor profile --size-only

# Monitor build time
meteor profile --build

# Profile with custom settings and timeout
METEOR_IDLE_TIMEOUT=120 meteor profile --settings settings.json

# Profile with custom entrypoints
METEOR_CLIENT_ENTRYPOINT=client/main.js METEOR_SERVER_ENTRYPOINT=server/main.js meteor profile
```

::: details Customizing the Profiling Process
You can pass any option that works with `meteor run` to customize the profiling process. This allows you to profile your application under specific conditions that match your deployment environment. The same applies to the `--build` option, which matches `meteor build` options.
:::

## meteor create _app-name_ {#meteorcreate}

Create a new Meteor project in a directory called `app-name`.

```bash
meteor create [options] app-name
```

::: tip Default Behavior
Without any flags, `meteor create app-name` generates a React project.
:::

::: tip Interactive Wizard
If you run `meteor create` without arguments, Meteor will launch an interactive wizard that guides you through selecting your project name and application type:

```bash
  ~ What is the name/path of your app?
  ~ Which skeleton do you want to use?
  Blaze     # To create an app using Blaze
  Full      # To create a more complete scaffolded app
  Minimal   # To create an app with as few Meteor packages as possible
  React     # To create a basic React-based app
  Typescript # To create an app using TypeScript and React
  Vue       # To create a basic Vue3-based app
  Svelte    # To create a basic Svelte app
  Tailwind # To create an app using React and Tailwind 
  Chakra-ui # To create an app Chakra UI and React 
  Solid # To create a basic Solid app 
  Apollo # To create a basic Apollo + React app 
  Bare # To create an empty app
```
:::

### Basic Options

| Option | Description |
|--------|-------------|
| `--from <url>` | Clone a Meteor project from a URL |
| `--example <name>` | Use a specific example template |
| `--list` | Show list of available examples |
| `--release <version>` | Specify Meteor version (e.g., `--release 2.8`) |
| `--prototype` | Include `autopublish` and `insecure` packages for rapid prototyping (not for production) |

### Application Types

| Option | Description | Tutorial / Example |
|--------|-------------|----------|
| `--react` | Create a React app (default) | [Meteor 3 with React](https://docs.meteor.com/tutorials/react/), [Meteor 2 with React](https://react-tutorial.meteor.com/) |
| `--vue` | Vue 3 + Tailwind CSS + Vite | [Meteor 3 with Vue](https://docs.meteor.com/tutorials/vue/meteorjs3-vue3-vue-meteor-tracker.html), [Meteor 2 with Vue](https://vue3-tutorial.meteor.com/) |
| `--svelte` | Svelte | [Meteor 2 with Svelte](https://svelte-tutorial.meteor.com/) |
| `--blaze` | Basic Blaze app | [Meteor 2 with Blaze](https://blaze-tutorial.meteor.com/) |
| `--solid` | Solid + Vite | [Meteor 2 with Solid Example](https://github.com/fredmaiaarantes/meteor-solid-app/releases/tag/milestone-2.0) |
| `--apollo` | React + Apollo (GraphQL) | [Meteor 2 with GraphQL](https://react-tutorial.meteor.com/simple-todos-graphql/) |
| `--typescript` | React + TypeScript | [TypeScript Guide](https://guide.meteor.com/build-tool.html#typescript) |
| `--tailwind` | React + Tailwind CSS | - |
| `--chakra-ui` | React + Chakra UI | [Simple Tasks Example](https://github.com/fredmaiaarantes/simpletasks) |

### Project Structure Options

| Option | Description |
|--------|-------------|
| `--minimal` | Create with minimal Meteor packages |
| `--bare` | Create an empty app (Blaze + MongoDB) |
| `--full` | Create a fully scaffolded app with imports-based structure (Blaze + MongoDB) |
| `--package` | Create a new package instead of an application |

::: warning Prototype Mode
The `--prototype` option adds packages that make development faster but shouldn't be used in production. See the [security checklist](https://guide.meteor.com/security.html#checklist).
:::

### Included Packages

<details>
<summary><strong>React App</strong> (--react or default)</summary>

**NPM packages:**
- `@babel/runtime`, `meteor-node-stubs`, `react`, `react-dom`

**Meteor packages:**
- `meteor-base`, `mobile-experience`, `mongo`, `reactive-var`, `standard-minifier-css`,
`standard-minifier-js`, `es5-shim`, `ecmascript`, `typescript`, `shell-server`, `hot-module-replacement`, `static-html`,
`react-meteor-data`
</details>

<details>
<summary><strong>Apollo (GraphQL) App</strong> (--apollo)</summary>

**NPM packages:**
- `@apollo/client`, `@apollo/server`, `@babel/runtime`, `graphql` `meteor-node-stubs`, `react`, `react-dom`

**Meteor packages:**
- `meteor-base`, `mobile-experience`, `mongo`, `reactive-var`, `standard-minifier-css`,
`standard-minifier-js`, `es5-shim`, `ecmascript`, `typescript`, `shell-server`, `hot-module-replacement`, `static-html`,
`apollo`, `compat:graphql`
</details>

<details>
<summary><strong>Blaze App</strong> (--blaze)</summary>

**NPM packages:**
- `@babel/runtime`, `meteor-node-stubs`, `jquery`

**Meteor packages:**
- `meteor-base`, `mobile-experience`, `mongo`, `blaze-html-templates`, `jquery`, `reactive-var`,
`tracker`, `standard-minifier-css`, `standard-minifier-js`, `es5-shim`, `ecmascript`, `typescript`, `shell-server`,
`hot-module-replacement`, `blaze-hot`
</details>

<details>
<summary><strong>Vue App</strong> (--vue)</summary>

**NPM packages:**
- `@babel/runtime`, `meteor-node-stubs`, `vue`, `vue-meteor-tracker`, `vue-router`, `@types/meteor`, `@vitejs/plugin-vue`, `autoprefixer`, `meteor-vite`, `postcss`, `tailwindcss`, `vite`

**Meteor packages:**
- `meteor-base`, `mobile-experience`, `mongo`, `reactive-var`, `standard-minifier-css`,
`standard-minifier-js`, `es5-shim`, `ecmascript`, `typescript`, `shell-server`, `hot-module-replacement`, `static-html`,
`jorgenvatle:vite`
</details>

<details>
<summary><strong>Minimal App</strong> (--minimal)</summary>

**NPM packages:**
- `@babel/runtime`, `meteor-node-stubs`

**Meteor packages:**
- `meteor`, `standard-minifier-css`, `standard-minifier-js`, `es5-shim`, `ecmascript`, `typescript`, `shell-server`,
`static-html`, `webapp`, `ddp`, `server-render`, `hot-module-replacement`
</details>

::: tip File Structure
To learn more about the recommended file structure for Meteor apps, check the [Meteor Guide](https://guide.meteor.com/structure.html#javascript-structure).
:::

##  meteor generate  {meteorgenerate}

``meteor generate`` is a command to generate boilerplate for your current project. `meteor generate` receives a name as a parameter, and generates files containing code to create a [Collection](https://docs.meteor.com/api/collections.html) with that name, [Methods](https://docs.meteor.com/api/meteor.html#methods) to perform basic CRUD operations on that Collection, and a [Subscription](https://docs.meteor.com/api/meteor.html#Meteor-publish) to read its data with reactivity from the client. 

If you run ``meteor generate``  without arguments, it will ask you for a name, and name the auto-generated Collection accordingly. It will also ask if you do want Methods for your API and Publications to be generated as well.

> _Important to note:_
> By default, the generator will generate JavaScript code. If you have a
``tsconfig.json`` file in your project, it will generate TypeScript code instead.

Example:
```bash
meteor generate customer
```

Running the command above will generate the following code in ``/imports/api``:

![Screenshot 2022-11-09 at 11 28 29](https://user-images.githubusercontent.com/70247653/200856551-71c100f5-8714-4b34-9678-4f08780dcc8b.png)

That will have the following code:


### collection.js {meteorgenerate-collection.js}

```js
import { Mongo } from 'meteor/mongo';

export const CustomerCollection = new Mongo.Collection('customer');
```



### methods.js {meteorgenerate-methods.js}

```js
import { Meteor } from 'meteor/meteor';
import { check } from 'meteor/check';
import { CustomerCollection } from './collection';

export async function create(data) {
  return CustomerCollection.insertAsync({ ...data });
}

export async function update(_id, data) {
  check(_id, String);
  return CustomerCollection.updateAsync(_id, { ...data });
}

export async function remove(_id) {
  check(_id, String);
  return CustomerCollection.removeAsync(_id);
}

export async function findById(_id) {
  check(_id, String);
  return CustomerCollection.findOneAsync(_id);
}

Meteor.methods({
  'Customer.create': create,
  'Customer.update': update,
  'Customer.remove': remove,
  'Customer.find': findById
});
```



### publication.js {meteorgenerate-publication.js}

```js
import { Meteor } from 'meteor/meteor';
import { CustomerCollection } from './collection';

Meteor.publish('allCustomers', function publishCustomers() {
  return CustomerCollection.find({});
});
```




### index.js {meteorgenerate-index.js}

```js
export * from './collection';
export * from './methods';
export * from './publications';
```

### path option {meteorgenerate-path}

If you want the generated files to be placed  in a specific directory, you can use the ``--path`` option to tell `meteor generate` where to place the new files. In the example below, `meteor generate` will create a collection called `another-customer` and place the `collection.ts`, `methods.ts`, `publications.ts` and `index.ts`  files inside the `server/admin` directory. In this example, we will assume the user has a `tsconfig.json` file in their project folder, and generate TypeScript instead.

```bash

meteor generate another-customer --path=server/admin

```

It will generate our files in the  ``server/admin`` folder:

![Screenshot 2022-11-09 at 11 32 39](https://user-images.githubusercontent.com/70247653/200857560-a4874e4c-1078-4b7a-9381-4c6590d2f63b.png)


### collection.ts {meteorgenerate-collection.ts}

```typescript
import { Mongo } from 'meteor/mongo';

export type AnotherCustomer = {
  _id?: string;
  name: string;
  createdAt: Date;
}

export const AnotherCustomerCollection = new Mongo.Collection<AnotherCustomer>('another-customer');
```

### methods.ts {meteorgenerate-methods.ts}

```typescript
import { Meteor } from 'meteor/meteor';
import { Mongo } from 'meteor/mongo';
import { check } from 'meteor/check';
import { AnotherCustomer, AnotherCustomerCollection } from './collection';

export async function create(data: AnotherCustomer) {
  return AnotherCustomerCollection.insertAsync({ ...data });
}

export async function update(_id: string, data: Mongo.Modifier<AnotherCustomer>) {
  check(_id, String);
  return AnotherCustomerCollection.updateAsync(_id, { ...data });
}

export async function remove(_id: string) {
  check(_id, String);
  return AnotherCustomerCollection.removeAsync(_id);
}

export async function findById(_id: string) {
  check(_id, String);
  return AnotherCustomerCollection.findOneAsync(_id);
}

Meteor.methods({
  'AnotherCustomer.create': create,
  'AnotherCustomer.update': update,
  'AnotherCustomer.remove': remove,
  'AnotherCustomer.find': findById
});
```



### publications.ts {meteorgenerate-publications.ts}

```typescript
import { Meteor } from 'meteor/meteor';
import { AnotherCustomerCollection } from './collection';

Meteor.publish('allAnotherCustomers', function publishAnotherCustomers() {
  return AnotherCustomerCollection.find({});
});
```



### index.ts {meteorgenerate-index.ts}

```typescript
export * from './collection';
export * from './methods';
export * from './publications';
```

---


###  Using the Wizard   {meteorgenerate-wizard}


Running `meteor-generate` without arguments will start a little wizard in your terminal, which will ask you the name of your Collection, and whether you want Methods and Publications to be generated as well.

```bash
meteor generate
```


![Screenshot 2022-11-09 at 11 38 29](https://user-images.githubusercontent.com/70247653/200859087-a2ef63b6-7ac1-492b-8918-0630cbd30686.png)




---

###  Using your own template  {meteorgenerate-templating}

You may customize the output of `meteor generate` by providing a directory with a "template". A template directory is just a folder provide by you with `.js`/`.ts` files, which are copied over.

To use an user-provided template, you should pass in a template directory URL so that it can copy it with its changes.

`--templatePath`

```bash
meteor generate feed --templatePath=/scaffolds-ts
```
![Screenshot 2022-11-09 at 11 42 47](https://user-images.githubusercontent.com/70247653/200860178-2341befe-bcfd-422f-a4bd-7c9918abfd97.png)

> Note that this is not a full-blown CLI framework inside Meteor. `meteor generate` is just a  command for generating code that is common in Meteor projects.
> Check out Yargs, Inquirer or Commander for more information about CLI frameworks.



###  How to rename things? {meteorgenerate-template-rename}

In addition to your own template folder, you can pass a JavaScript file to `meteor-generate` to perform certain transformations in your template files. That file is just a normal `.js` file that should export two functions: `transformName` and `transformContents`, which are used to modify the file names and contents, respectively.

If you don't want to write such a file yourself, a few functions are provided out of the box to replace strings like ``$$name$$``, ``$$PascalName$$`` and ``$$camelName$$`` in your template files. The [internal Meteor template files](https://github.com/meteor/meteor/blob/release-3.3/tools/static-assets/scaffolds-js/methods.js) (which is used when you don't pass a template folder through the `--templatePath` option) are implemented this way - they include those special strings which get replaced to generate your files.

These replacements come from this function from Meteor's CLI:

_scaffoldName is a string with the name that you have passed as argument._

```js
const transformName = (name) => {
    return name.replace(/\$\$name\$\$|\$\$PascalName\$\$|\$\$camelName\$\$/g, function (substring, args) {
      if (substring === '$$name$$') return scaffoldName;
      if (substring === '$$PascalName$$') return toPascalCase(scaffoldName);
      if (substring === '$$camelName$$') return toCamelCase(scaffoldName);
    })
  }
```

###  How to replace things in your own templates?  {meteorgenerate-template-faq}

`--replaceFn`

If you do want to customize how your templates are generated, you can pass a `.js` file with the ``--replaceFn`` option, as described above.  When you pass in given a `.js` file with an implementation for those two functions, Meteor will use your functions instead of the [default ones](https://github.com/meteor/meteor/blob/ae8cf586acc9a4c7bf9a5ab79dc5f8b7ef433a64/tools/cli/commands.js#L3090).

_example of a replacer file_
```js
export function transformFilename(scaffoldName, filename) {
  console.log(scaffoldName, filename);
  return filename;
}

export function transformContents(scaffoldName, fileContents, filename) {
  console.log(filename, fileContents);
  return contents;
}
```
If you run your command like this:

```bash
 meteor generate feed --replaceFn=/fn/replace.js
```
It will generate files full of ``$$PascalCase$$`` strings using the Meteor provided templates, ignoring the name provided by the user (`feed`). Since we aren't replacing them with anything in the example above, the Meteor template files are copied [as they are](https://github.com/meteor/meteor/blob/release-3.3/tools/static-assets/scaffolds-js/collection.js).

A more real-world usage of this feature could be done with the following `.js` file:
```js
const toPascalCase = (str) => {
  if(!str.includes('-')) return str.charAt(0).toUpperCase() + str.slice(1);
  else return str.split('-').map(toPascalCase).join('');
}
const toCamelCase = (str) => {
  if(!str.includes('-')) return str.charAt(0).toLowerCase() + str.slice(1);
  else return str.split('-').map(toPascalCase).join('');
}

const transformName = (scaffoldName, str) => {
    return str.replace(/\$\$name\$\$|\$\$PascalName\$\$|\$\$camelName\$\$/g, function (substring, args) {
      if (substring === '$$name$$') return scaffoldName;
      if (substring === '$$PascalName$$') return toPascalCase(scaffoldName);
      if (substring === '$$camelName$$') return toCamelCase(scaffoldName);
    })

}

export function transformFilename(scaffoldName, filename) {
  return transformName(scaffoldName, filename);
}

export function transformContents(scaffoldName, contents, fileName) {
  return transformName(scaffoldName, contents);
}
```
## meteor login

Logs you in to your Meteor developer account.

**Usage:**
```bash
meteor login [--email]
```

**Details:**
- Prompts for your username and password
- Pass `--email` to log in by email address rather than by username
- You can set `METEOR_SESSION_FILE=token.json` before `meteor login` to generate a login session token, avoiding the need to share credentials with third-party service providers

## meteor logout

Logs you out of your Meteor developer account.

**Usage:**
```bash
meteor logout
```

## meteor whoami

Displays your currently logged-in username.

**Usage:**
```bash
meteor whoami
```

## meteor deploy _site_ {#meteordeploy}

Deploys the project in your current directory to [Galaxy](https://www.meteor.com/galaxy).

### Basic Deployment

```bash
meteor deploy your-app.meteorapp.com
```

### Deployment Options

| Option | Description |
|--------|-------------|
| `--delete`, `-D` | Permanently delete this deployment |
| `--debug` | Deploy in debug mode (don't minify, etc.) |
| `--settings`, `-s <file>` | Set optional data for Meteor.settings |
| `--free` | Deploy as a free app (with limitations) |
| `--mongo` | Create and connect to a free shared MongoDB database |
| `--plan <plan>` | Set app plan: `professional`, `essentials`, or `free` |
| `--container-size <size>` | Set container size: `tiny`, `compact`, `standard`, `double`, `quad`, `octa`, or `dozen` |
| `--owner` | Specify organization or user account to deploy to |
| `--cache-build` | Reuse the build if the git commit hash is the same |
| `--allow-incompatible-update` | Allow packages to be upgraded or downgraded to potentially incompatible versions |
| `--deploy-polling-timeout <ms>` | Time to wait for build/deploy (defaults to 15 minutes) |
| `--no-wait` | Exit after code upload instead of waiting for deploy to complete |

### Free Deployment

Deploy a free app with MongoDB using:

```bash
meteor deploy your-app.meteorapp.com --free --mongo
```

::: tip Quick Start
The combination of `--free` and `--mongo` is the fastest way to deploy an app without any additional configuration.
:::

#### Free App Limitations

- **Domain**: Must use a Meteor domain (`.meteorapp.com`, `.au.meteorapp.com`, or `.eu.meteorapp.com`)
- **Cold Start**: App stops after 30 minutes of inactivity and restarts on next connection
- **Resources**: Limited to one Tiny container (not recommended for production use)


### MongoDB Options

#### Shared MongoDB (Free)

The `--mongo` option creates a database in Galaxy's shared cluster:

- On first deploy, you'll receive your MongoDB URI in the console
- The URI is also visible in your app's version details in Galaxy
- You must create at least one document to fully instantiate the database
- The database can be accessed using any MongoDB client with the provided URI

::: warning
Free shared MongoDB is not recommended for production applications. The shared cluster doesn't provide backups or restoration resources.
:::

#### MongoDB Connection Settings

When connecting to the free MongoDB shared cluster using your own settings, include:

```json
{
  "packages": {
    "mongo": {
      "options": {
        "tlsAllowInvalidCertificates": true
      }
    }
  }
}
```

::: details Why is this needed?
This is necessary because the database provider doesn't have certificates installed on every machine. More about this option [here](../api/collections.html#mongo_connection_options_settings).
:::

### Important Notes

- Settings persist between deployments unless explicitly changed
- Your project should be a git repository (commit hash is used to track code changes)
- Free apps and MongoDB shared hosting are not recommended for production use
- Meteor Software reserves the right to stop or remove applications that abuse the free plan

::: info Version Compatibility
- `--free` and `--mongo` options were introduced in Meteor 2.0
- `--plan` option was introduced in Meteor 2.1
- `--container-size` option was introduced in Meteor 2.4.1
- `--cache-build` option is available since Meteor 1.11
:::

## meteor update

Updates your Meteor application while maintaining compatibility.

**Usage:**
```bash
meteor update
meteor update --patch
meteor update --release <release>
meteor update --packages-only
meteor update [packageName packageName2 ...]
meteor update --all-packages
```

**Update Types:**

| Command | Description |
|---------|-------------|
| `meteor update` | Updates the Meteor release and compatible package versions |
| `meteor update --patch` | Updates to the latest patch release (recommended for bug fixes) |
| `meteor update --release <release>` | Updates to a specific Meteor release |
| `meteor update --packages-only` | Updates only packages, not the Meteor release |
| `meteor update [packageName ...]` | Updates specific named packages |
| `meteor update --all-packages` | Updates all packages including indirect dependencies |

**Important Notes:**
- Every project is pinned to a specific Meteor release
- By default, updates will not break compatibility between packages
- Patch releases contain minor, critical bug fixes and are highly recommended
- The `--release` flag can override compatibility checks (may cause warnings)
- The `--all-packages` option will update all packages to their latest compatible versions, respecting dependency constraints


## meteor add *package* {#meteor-add}

Adds packages to your Meteor project.

**Usage:**
```bash
meteor add [package1] [package2] ...
meteor add package@version
```

**Version Constraints:**
- `package@1.1.0` - Version 1.1.0 or higher (but not 2.0.0+)
- `package@=1.1.0` - Exactly version 1.1.0
- `package@=1.0.0 || =2.0.1` - Either version 1.0.0 or 2.0.1 exactly

**Notes:**
- By convention, community packages include the maintainer's name (e.g., `iron:router`)
- To remove a version constraint, run `meteor add package` without specifying a version

## meteor remove *package* {#meteor-remove}

Removes a package previously added to your Meteor project.

**Usage:**
```bash
meteor remove [package1] [package2] ...
```

**Notes:**
- For a list of currently used packages, run `meteor list`
- This removes the package entirely (to only remove version constraints, use [`meteor add`](#meteor-add))
- Transitive dependencies aren't automatically downgraded unless necessary

## meteor list {#meteor-list}

Lists all packages added to your project, including versions and available updates.

**Usage:**
```bash
meteor list [flags]
```

**Flags:**

| Flag | Description |
|------|-------------|
| `--tree` | Outputs a tree showing package reference hierarchy |
| `--json` | Outputs an unformatted JSON string of package references |
| `--weak` | Shows weakly referenced dependencies (only with `--tree` or `--json`) |
| `--details` | Adds more package details (only with `--json`) |


## meteor add-platform *platform* {#meteor-add-platform}

Adds platforms to your Meteor project.

**Usage:**
```bash
meteor add-platform [platform1] [platform2] ...
```

**Notes:**
- Multiple platforms can be added with one command
- After adding, use `meteor run <platform>` to run on that platform
- Use `meteor build` to build for all added platforms


## meteor remove-platform *platform* {#meteor-remove-platform}

Removes a previously added platform.

**Usage:**
```bash
meteor remove-platform [platform]
```

**Notes:**
- For a list of currently added platforms, use `meteor list-platforms`


## meteor list-platforms {#meteor-list-platforms}

Lists all platforms explicitly added to your project.

**Usage:**
```bash
meteor list-platforms
```


## meteor ensure-cordova-dependencies {#meteor-ensure-cordova-dependencies}

Checks if dependencies are installed, and installs them if necessary.

**Usage:**
```bash
meteor ensure-cordova-dependencies
```


## meteor mongo {#meteor-mongo}

Opens a MongoDB shell on your local development database.

**Usage:**
```bash
meteor mongo
```

::: warning
For now, you must already have your application running locally with `meteor run`. This will be easier in the future.
:::

## meteor reset {#meteor-reset}

Resets the current project to a fresh state and clears the local cache.

**Usage:**
```bash
meteor reset [--db]
```

**Flags:**
- `--db` - Also removes the local MongoDB database

::: warning
Reset with `--db` flag deletes your data! Make sure you do not have any information you care about in your local mongo database by running `meteor mongo`. From the mongo shell, use `show collections` and `db.<collection>.find()` to inspect your data.
:::

::: warning
For now, you cannot run this while a development server is running. Quit all running meteor applications before running this.
:::


## meteor build {#meteorbuild}

Package your project for deployment.

```bash
meteor build <output-path> [options]
```

### Output Artifacts

The command produces deployment-ready artifacts for all platforms in your project:

- **Server Bundle**: A tarball containing everything needed to run the application server
- **Android Package**: AAB/APK bundle and Android project source (if Android platform is added)
- **iOS Package**: Xcode project source (if iOS platform is added)

::: tip Self-Hosting
You can use the server bundle to host a Meteor application on your own infrastructure instead of Galaxy. Note that you'll need to handle logging, monitoring, backups, and load-balancing yourself.
:::

### Options

| Option | Description |
|--------|-------------|
| `--debug` | Build in debug mode (don't minify, preserve source maps) |
| `--directory` | Output a directory instead of a tarball (existing output location will be deleted first) |
| `--server-only` | Skip building mobile apps but still build the 'web.cordova' client target for hot code push |
| `--mobile-settings <file>` | Set the initial value of `Meteor.settings` in mobile apps |
| `--server <url>` | Location where mobile builds connect to the Meteor server (defaults to localhost:3000) |
| `--architecture <arch>` | Build for a different architecture than your development machine |
| `--allow-incompatible-update` | Allow packages to be upgraded/downgraded to potentially incompatible versions |
| `--platforms <platforms>` | Build only for specified platforms (when available) |
| `--packageType <type>` | Choose between `apk` or `bundle` for Android builds (defaults to `bundle`) |

::: details Available Architectures
Valid architectures include:
- `os.osx.x86_64`
- `os.linux.x86_64`
- `os.linux.x86_32`
- `os.windows.x86_32`
- `os.windows.x86_64`

This option selects the architecture of binary-dependent Atmosphere packages. If your project doesn't use Atmosphere packages with binary dependencies, `--architecture` has no effect.
:::

### Examples

```bash
# Basic build
meteor build ../build

# Output a directory instead of a tarball
meteor build ../build --directory

# Debug build (unminified)
meteor build ../build --debug

# Build only the server (skip mobile apps)
meteor build ../build --server-only

# Build for specific platforms
meteor build ../build --platforms=android,ios

# Set server location for mobile apps
meteor build ../build --server=https://example.com:443

# Build for a different architecture
meteor build ../build --architecture=os.linux.x86_64

# Specify Android package type
meteor build ../build --packageType=apk
```

## meteor lint {#meteorlint}

Run linters on your Meteor application code.

```bash
meteor lint [options]
```

### Description

This command:
- Performs a complete build of your application
- Runs all configured linters
- Outputs build errors and linting warnings to standard output

::: tip CI Integration
The `meteor lint` command is particularly useful for continuous integration environments to catch code quality issues before deployment.
:::

### Options

| Option | Description |
|--------|-------------|
| `--allow-incompatible-update` | Allow packages to be upgraded or downgraded to potentially incompatible versions if required to satisfy all package version constraints |

### Example Usage

```bash
# Basic usage
meteor lint

# Allow incompatible package updates during linting
meteor lint --allow-incompatible-update
```

::: warning
Linting errors will prevent your application from being built successfully. Fixing these errors is required for deployment.
:::


## meteor search {#meteorsearch}

Search for Meteor packages and releases.

```bash
meteor search <regex> [options]
```

### Description

Searches through the Meteor package and release database for items whose names match the specified regular expression.

::: info Default Behavior
By default, the search will not show:
- Packages without official versions (e.g., those with only prereleases)
- Packages known to be incompatible with Meteor 0.9.0 and later due to migration issues
:::

### Options

| Option | Description |
|--------|-------------|
| `--maintainer <username>` | Filter results by authorized maintainer |
| `--show-all` | Show all matches, including prereleases and incompatible packages |
| `--ejson` | Display more detailed output in EJSON format |

### Examples

```bash
# Search for all packages related to "auth"
meteor search auth

# Search for packages maintained by a specific user
meteor search mongo --maintainer meteor

# Show all matching packages, including prereleases
meteor search bootstrap --show-all

# Get detailed output in EJSON format
meteor search react --ejson
```

::: tip Advanced Searching
You can use regular expressions for more powerful searches:
```bash
# Packages that start with "react-"
meteor search "^react-"

# Packages that end with "router"
meteor search "router$"
```
:::


## meteor show {#meteorshow}

Display detailed information about packages and releases.

```bash
meteor show <name> [options]
meteor show <name@version> [options]
meteor show [options]
```

### Description

Shows detailed information about a specific package or release, including:
- Name and summary
- Available versions
- Maintainers
- Homepage and git URL (if specified)
- Exports and other package metadata

::: tip
This works on both local packages built from source and remote packages stored on the server.
:::

### Common Usage

#### View Package Information

```bash
# Show information about a package
meteor show jam:easy-schema

# Show information about a specific version
meteor show jam:easy-schema@1.7.0

# Show information about the local version
meteor show jam:easy-schema@local
```

#### View Meteor Releases

```bash
# Show recommended Meteor releases
meteor show METEOR

# Show all Meteor releases (including intermediate ones)
meteor show METEOR --show-all
```

### Options

| Option | Description |
|--------|-------------|
| `--show-all` | Show hidden versions, experimental releases, and incompatible packages |
| `--ejson` | Display more detailed output in EJSON format |

### Examples

```bash
# Running from a package directory shows info for that package
cd ~/my-package
meteor show

# View detailed EJSON output
meteor show react-meteor-data --ejson
```

::: info Default Behavior
By default, Meteor:
- Shows no more than five versions
- Hides experimental release versions
- Hides packages incompatible with Meteor 0.9.0 and later
:::

::: details Version Selection
For version-specific information (like exports), Meteor will use:
1. The local version, if available
2. The latest official version, if no local version exists
:::


## meteor publish {#meteorpublish}

Publish a package to Atmosphere (Meteor package server).

```bash
meteor publish [options]
meteor publish --update
```

### Description

Publishes a new version of a local package to Atmosphere. Must be run from the package directory.

::: warning Package Naming Convention
Published package names must begin with the maintainer's Meteor Developer Account username and a colon, like `username:package-name`.
:::

### Common Operations

#### Publish a New Package

```bash
cd my-package
meteor publish --create
```

#### Update an Existing Package

```bash
cd my-package
meteor publish
```

#### Update Package Metadata

Update README, description, or other metadata without changing the code:

```bash
cd my-package
meteor publish --update
```

### Options

| Option | Description |
|--------|-------------|
| `--create` | Publish a new package for the first time |
| `--update` | Update metadata of a previously published version (README, git URL, description, etc.) |
| `--allow-incompatible-update` | Allow dependencies to be upgraded/downgraded to potentially incompatible versions |
| `--no-lint` | Skip linting the package and its local dependencies before publishing |

### Architecture-Specific Packages

For packages with binary components:
- Regular `publish` will only upload the build for your current architecture
- Use `meteor publish-for-arch` from a different machine to upload builds for other architectures

::: details Package Publication Process
When you publish a package:
1. Meteor reads version information from `package.js`
2. Builds the package
3. Sends both source code and built version to the package server
4. Marks you as the sole maintainer (use `meteor admin maintainers` to modify)
:::

### Examples

```bash
# Publish a new package
meteor publish --create

# Update an existing package
meteor publish

# Update metadata only
meteor publish --update

# Publish without linting
meteor publish --no-lint
```

::: tip
Use `meteor show` to preview how your package information will appear in the package server.
:::

## meteor publish-for-arch {#meteorpublishforarch}

Publish architecture-specific builds of a package.

```bash
meteor publish-for-arch packageName@version
```

### Description

Creates and publishes a build of an existing package version for a different architecture than the one initially published.

::: info Architecture Support
Meteor currently supports the following architectures:
- 32-bit Linux
- 64-bit Linux (used by Galaxy servers)
- 64-bit macOS
:::

### Use Case

When a package contains platform-specific components (like npm modules with native code), running `meteor publish` only creates a build for your current architecture. To make your package usable on other architectures, you need to run `publish-for-arch` from machines with those architectures.

### How It Works

1. Run the command on a machine with the target architecture
2. Meteor downloads your package's source and dependencies from the package server
3. Builds the package for the current architecture
4. Uploads the architecture-specific build to the package server

::: tip No Source Required
You don't need to have a copy of your package's source code to run this command. Meteor automatically downloads everything needed from the package server.
:::

### Example Workflow

Imagine you've published a package with binary components from a Mac:

```bash
# On your Mac
cd my-binary-package
meteor publish --create
```

To make it available for Linux users:

```bash
# Later, on a 64-bit Linux machine
meteor publish-for-arch username:my-binary-package@1.0.0
```


## meteor publish-release {#meteorpublishrelease}

Publish a new Meteor release.

```bash
meteor publish-release <path-to-json-config> [options]
```

### Description

Publishes a new release of Meteor based on a JSON configuration file. This allows you to create custom Meteor releases or release tracks.

::: info Release Tracks
Meteor releases are divided into tracks:
- Only Meteor Software can publish to the default Meteor track
- Anyone can create and publish to their own custom tracks
- Users won't switch tracks when running `meteor update` unless specified
:::

### Configuration File Format

The JSON configuration file must contain:

```json
{
  "track": "TRACK_NAME",          // Release track (e.g., "METEOR")
  "version": "VERSION",           // Version number (e.g., "2.8.0")
  "recommended": true|false,      // Is this a recommended release?
  "description": "DESCRIPTION",   // Brief description of the release
  "tool": "PACKAGE@VERSION",      // The meteor tool package and version
  "packages": {                   // Specific package versions for this release
    "package1": "version",
    "package2": "version"
  },
  "patchFrom": ["VERSION1", "VERSION2"]  // Optional: releases this patches
}
```

::: warning Prerequisites
You must publish all package versions to the package server before you can specify them in a release.
:::

### Options

| Option | Description |
|--------|-------------|
| `--create-track` | Create and publish a new release track |

### Recommended Flag

- Set `recommended: true` for stable releases (e.g., METEOR@3.2.2)
- Set `recommended: false` for release candidates, experimental releases, etc.

### Patch Releases

Use the `patchFrom` field to specify a patch release:
- Lists releases this new release patches
- Automatically unrecommends the releases specified in `patchFrom`

### Examples

#### Publishing a New Release Track

```bash
meteor publish-release my-release-config.json --create-track
```

#### Publishing a New Release

```bash
meteor publish-release meteor-3.3.0.json
```

#### Sample Configuration File

```json
{
  "track": "MYCORP",
  "version": "1.0.0",
  "recommended": true,
  "description": "MyCompany's custom Meteor release",
  "tool": "meteor-tool@2.8.0",
  "packages": {
    "accounts-base": "2.2.5",
    "mongo": "1.15.0"
  }
}
```

::: tip Custom Tool Forks
This system allows forks of the meteor tool to be published as packages, letting users switch to custom tool implementations by changing to the corresponding release.
:::


## meteor test-packages {#meteortestpackages}

Run tests for Meteor packages.

```bash
meteor test-packages [options] [package...]
```

### Description

Runs unit tests for one or more packages. Test results appear in a browser dashboard that updates whenever relevant source files are modified.

::: tip Package Specification
Packages can be specified by:
- **Name**: Resolved using the standard package search algorithm
- **Path**: Any argument containing a '/' is loaded from that directory path
:::

If no packages are specified, all available packages will be tested.

### Options

| Option                        | Description                                                     |
|-------------------------------|-----------------------------------------------------------------|
| `--port`, `-p <port>`         | Port to listen on (default: 3000). Also uses ports N+1 and N+2  |
| `--open`, `-o`                | Opens a browser window when the app starts                      |
| `--inspect[-brk][=<port>]`    | Enable server-side debugging (default port: 9229)               |
| `--settings`, `-s <file>`     | Set optional data for Meteor.settings on the server             |
| `--production`                | Simulate production mode (minify and bundle CSS, JS files)      |
| `--driver-package <package>`  | Test driver package to use (e.g., `meteortesting:mocha`)        |
| `--filter`, `-f`              | Filter the tests by name                                        |
| `--verbose`                   | Print all output from build logs                                |
| `--no-lint`                   | Skip running linters on every test app rebuild                  |
| `--extra-packages <packages>` | Run with additional packages (comma separated)                  |
| `--test-app-path <path>`      | Set directory for temporary test app (default: system temp dir) |

#### Mobile Testing Options

| Option | Description |
|--------|-------------|
| `--ios`, `--android` | Run tests in an emulator |
| `--ios-device`, `--android-device` | Run tests on a connected device |
| `--mobile-server <url>` | Server location for mobile builds (default: local IP and port) |
| `--cordova-server-port <port>` | Local port where Cordova will serve content |

### Examples

#### Test specific packages by name

```bash
meteor test-packages accounts-base accounts-password
```

#### Test a package by path

```bash
meteor test-packages ./packages/my-package
```

#### Test with custom settings

```bash
meteor test-packages --settings settings.json
```

#### Test with Mocha test driver

```bash
meteor test-packages --driver-package meteortesting:mocha
```

#### Test with filter

```bash
meteor test-packages --filter myTestName
```

Alternatively, you can use the `TINYTEST_FILTER` environment variable to filter:

```bash
TINYTEST_FILTER=myTestName meteor test-packages
```

#### Test on mobile device

```bash
meteor test-packages --ios-device
```

## meteor admin {#meteoradmin}

Administrative commands for official Meteor services.

```bash
meteor admin <command> [args]
```

::: warning Authorization Required
These commands require authorization to use.
:::

### Available Commands

| Command | Description |
|---------|-------------|
| `maintainers` | View or change package maintainers |
| `recommend-release` | Recommend a previously published release |
| `change-homepage` | Change the homepage URL of a package |
| `list-organizations` | List the organizations of which you are a member |
| `members` | View or change the members of an organization |
| `get-machine` | Open an SSH shell to a machine in the Meteor build farm |

### Usage Examples

```bash
# View or change package maintainers
meteor admin maintainers packagename [add/remove] [username]

# Change a package homepage
meteor admin change-homepage packagename [url]

# List your organizations
meteor admin list-organizations

# Manage organization members
meteor admin members organization-name [add/remove] [username]
```

::: tip Detailed Help
For more information on any admin command, run:
```bash
meteor help admin <command>
```
:::

## meteor shell {#meteorshell}

Start an interactive JavaScript shell for evaluating server-side code.

```bash
meteor shell
```

### Description

The `meteor shell` command connects to a running Meteor server and provides an interactive JavaScript REPL (Read-Eval-Print Loop) for executing server-side code.

::: tip Connection Behavior
- Requires a running Meteor server in the application directory
- If no server is available, it will keep trying to connect until successful
- Multiple shells can be attached to the same server simultaneously
:::

### Features

#### Server Integration

- Exiting the shell does not terminate the server
- If the server restarts (due to code changes or errors), the shell will automatically restart with it
- You can manually trigger a reload by typing `.reload` in the shell

#### Developer Experience

| Feature | Description |
|---------|-------------|
| **Tab Completion** | Built-in tab completion for global variables like `Meteor`, `Mongo`, and `Package` |
| **Persistent History** | Command history is maintained across sessions |
| **Command Recall** | Access previously-run commands using the up arrow key |

### Example Usage

```bash
# Start a Meteor server in one terminal
meteor run

# Connect a shell in another terminal
meteor shell

# Now you can run server-side code interactively:
> Meteor.users.find().count()
> Package.mongo.Mongo.Collection.prototype
> Meteor.isServer
true
> .reload  # Manually restart the shell
```

::: details Advanced Example
```js
// Query the database
> db = Package.mongo.MongoInternals.defaultRemoteCollectionDriver().mongo.db
> db.collection('users').find().toArray()

// Access Meteor settings
> Meteor.settings.public

// Inspect publications
> Object.keys(Meteor.server.publish_handlers)
```
:::

## meteor npm {#meteornpm}

Run npm commands using Meteor's bundled npm version.

```bash
meteor npm <command> [args...]
```

### Description

The `meteor npm` command executes [npm](https://docs.npmjs.com/) commands using the version bundled with Meteor itself.

::: tip Benefits of Using Meteor's npm
1. Ensures compatibility with Meteor's Node.js version
2. Crucial for packages with native dependencies (like `bcrypt`)
3. No need to install npm separately
4. Consistent behavior across development environments
:::

### Common Commands

| Command | Description |
|---------|-------------|
| `meteor npm install` | Install all dependencies listed in `package.json` |
| `meteor npm install <package> --save` | Install and save a package as a dependency |
| `meteor npm install <package> --save-dev` | Install and save a package as a development dependency |
| `meteor npm update` | Update all packages to their latest allowed versions |
| `meteor npm ls` | List installed packages |
| `meteor npm rebuild` | Rebuild packages that have native dependencies |

### Examples

```bash
# Install a package and save to dependencies
meteor npm install lodash --save

# Install packages from package.json
meteor npm install

# Run an npm script defined in package.json
meteor npm run start

# View package information
meteor npm info react
```

::: warning Native Dependencies
Using `meteor npm` instead of regular `npm` is especially important when working with packages that have binary dependencies making native C calls (like `bcrypt`). This ensures they're built with the same libraries used by Meteor.
:::

## meteor node {#meteornode}

Run Node.js commands using Meteor's bundled Node.js version.

```bash
meteor node [options] [script.js] [arguments]
```

::: info Alternative
Consider using [`meteor shell`](#meteorshell) instead, which provides similar functionality plus access to your Meteor application's server context.
:::

### Description

The `meteor node` command runs [Node.js](https://nodejs.org/) using the version bundled with Meteor itself.

### Common Uses

| Command | Description |
|---------|-------------|
| `meteor node` | Start an interactive Node.js REPL |
| `meteor node script.js` | Execute a JavaScript file |
| `meteor node -e "<code>"` | Execute a line of JavaScript |
| `meteor node --version` | Show Node.js version |

### Examples

```bash
# Start an interactive REPL
meteor node

# Execute inline JavaScript
meteor node -e "console.log(process.versions)"

# Run a script with arguments
meteor node scripts/migrate.js --force

# Check installed Node.js version
meteor node --version
```

::: details Running a Simple Script
Create `hello.js`:
```js
console.log('Hello from Node.js version', process.version);
console.log('Arguments:', process.argv.slice(2));
```

Run it:
```bash
meteor node hello.js arg1 arg2
```
:::

---

---
url: /community-packages/index.md
---
# Community Packages

::: tip
The Meteor community is making great efforts to migrate popular packages to Meteor 3.0.

A [spreadsheet maintained](https://docs.google.com/spreadsheets/u/0/d/1JbUZmJab3owZ9LV71Ubto32YX_QWQljRypJTOQupxL8/htmlview) by [@harryadel](https://github.com/harryadel) tracks the status of your favorite packages and offers opportunities to help.
:::

There are some very popular community packages that do not have a documentation website or only have a readme file.
This section tries to list and add some information about usage, configuration, and examples for these packages.

> Think this section as an `Awesome List`, similar to [`awesome-node`](https://github.com/sindresorhus/awesome-nodejs) or [`awesome-react`](https://github.com/enaqx/awesome-react)

Many packages have been consolidated into the [Meteor Community organization](https://github.com/Meteor-Community-Packages). Others are maintained by individual developers or companies.

If you use or have a package that you think would be useful to add to this list, please open a pull request.

Please bear in mind if you are adding a package to this list, try providing as much information as possible, including:

- `Who maintains the package` – how to get in touch to submit issues or questions
- `Why is this package for?`
- `API`
- `examples/guide`

## List of Community Packages

#### Method/Subscription helpers

- [`meteor-rpc`](./meteor-rpc.md), Meteor Methods Evolved with type checking and runtime validation
- [`jam:method`](./jam-method.md), An easy way to create Meteor methods with extensions to offline handling
- [`jam:pub-sub`](./pub-sub.md), Publish / subscribe using a Method and/or Change Streams, and cache subscriptions for Meteor apps

#### MongoDB collection extensions

- [`jam:mongo-transactions`](./mongo-transactions.md), An easy way to use Mongo Transactions for Meteor apps
- [`jam:soft-delete`](./soft-delete.md), An easy way to add soft deletes to your Meteor app
- [`jam:archive`](./archive.md),

#### Utilities

- [`jam:offline`](./offline.md), An easy way to give your Meteor app offline capabilities and make it feel instant

---

---
url: /packages/community-packages.md
---

If you are not redirected automatically, open /community-packages/index

---

---
url: /about/cordova.md
---

# Cordova

Meteor allows developers to build mobile applications using web technologies like HTML, CSS, and JavaScript, while also accessing native mobile capabilities. This integration is made with [Apache Cordova](https://cordova.apache.org).

Cordova apps run in a web view, which is like a browser without the UI. Different browser engines have varying implementations and support for web standards. This means the web view your app uses can greatly affect its performance and available features. (For details on supported features across browsers and versions, check caniuse.com.)

There is a [Meteor Cordova guide](https://guide.meteor.com/cordova) available that offers advanced configuration details for Meteor Cordova projects. Feel free to refer to it while we update the information in the new documentation.

This section will summarize the steps needed to set up your environment for Meteor Cordova development, manage development, and generate native artifacts for store uploads.

## Pre-Installation

Before you begin, make sure your development environment meets the following requirements:

### Android

#### Java

For Android development, Cordova requires the JDK.

``` sh
# On Debian/Ubuntu:
sudo apt-get update
sudo apt-get install openjdk-17-jdk

# On Mac OSX
brew install openjdk@17
sudo ln -sfn $(brew --prefix)/opt/openjdk@17/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-17.jdk

# using sdkman
curl -s "https://get.sdkman.io" | bash
source "$HOME/.sdkman/bin/sdkman-init.sh"
sdk install java 17
sdk default java 17

java -version  # Verify installation
```

Ensure `JAVA_HOME` environment variable is set by adding it to `~/.bashrc` or `~/.zshrc` :

``` sh
export JAVA_HOME=$(dirname $(dirname $(readlink -f $(which java))))
export PATH=$JAVA_HOME/bin:$PATH
```

Run `echo $JAVA_HOME` to check the current Java version. If it's incorrect, manually set the correct path by finding where Java is installed.

##### Windows

To install Java on Windows, [download the Java 17 executable](https://www.oracle.com/java/technologies/javase/jdk17-archive-downloads.html) and run the installer.

Ensure the `JAVA_HOME` environment variable is set globally in your system path:

1. Open System Properties: Press Windows Key + Pause/Break or right-click This PC > Properties.
2. Click Advanced system settings.
3. Click the Environment Variables button.
4. Under System Variables, click New.
5. Variable Value: Path to your JDK (e.g., C:\Program Files\Java\jdk-17).
6. Click New and add `%JAVA_HOME%\bin`.
7. Click OK to save all changes.

Verify the installation in a terminal by running `echo %JAVA_HOME%`.

Alternatively, you can set the environment variable in a terminal each time you work with your Meteor Cordova app:

``` sh
$env:JAVA_HOME = "C:\Program Files\Java\jdk-17"
$env:PATH += ";%JAVA_HOME%\bin"
```

#### Android SDK

For Android builds, you will need the Android SDK. You can install it via [Android Studio](https://developer.android.com/studio).

Once Android Studio is installed, go to **SDK Manager** and install the required SDK packages. The minimum required version is Android SDK 35. Install the `Android SDK Command-line Tools (latest)` as well.

Ensure `ANDROID_HOME` environment variable is set by adding it to `~/.bashrc` or `~/.zshrc` :

```sh
export ANDROID_HOME=$HOME/Library/Android/sdk
export ANDROID_SDK_ROOT=${ANDROID_HOME}
export PATH=$ANDROID_HOME/cmdline-tools/latest/bin:$ANDROID_HOME/tools:$ANDROID_HOME/tools/bin:$ANDROID_HOME/platform-tools:$ANDROID_HOME/emulator:$PATH
```

##### Windows

Ensure `ANDROID_HOME` environment variable are set globally on the system configuration or by setting the envs on the terminal.

``` ps
$env:ANDROID_HOME = "C:\Users\<USER>\AppData\Local\Android\Sdk"
$env:ANDROID_SDK_ROOT = $env:ANDROID_HOME
$env:PATH = "$env:ANDROID_HOME\cmdline-tools\latest\bin;$env:ANDROID_HOME\tools;$env:ANDROID_HOME\tools\bin;$env:ANDROID_HOME\platform-tools;$env:ANDROID_HOME\emulator;$env:PATH"
```

#### Gradle

If Gradle cannot be found install it with:

```sh
# On Mac OSX:
brew install gradle

# On Debian/Ubuntu:
sudo apt-get install gradle

# using sdkman
curl -s "https://get.sdkman.io" | bash
source "$HOME/.sdkman/bin/sdkman-init.sh"
sdk install gradle 8.7

gradle --version  # Verify installation
```

##### Windows

Install Gradle on your Windows system [by following the official guide](https://gradle.org/install).

Make sure the Gradle path is included in your system's PATH variable.

```ps
$env:PATH += ";C:\Gradle\gradle-8.10.2\bin"
```

### iOS

For iOS development, you will need Xcode (macOS only).

Install [Xcode](https://apps.apple.com/us/app/xcode/id497799835?mt=12) from the App Store.

After installing, ensure that the **command-line tools** are installed:

```sh
xcode-select --install
```

Once the download and installation are finished, you'll need to accept the license agreement. When you open Xcode for the first time, a dialog will appear with the agreement for you to review and accept. You can then close Xcode. Or use the next command on the command line.

```sh
sudo xcodebuild -license accept
```

Also, install CocoaPods, which is needed to manage iOS project dependencies:

```sh
sudo gem install cocoapods
```

## Development

Once you have all the prerequisites set up, you can quickly get a mobile project running.

### Add platforms

To develop a mobile app, you need to add the platforms (iOS and Android) for Cordova:

```sh
# Android
meteor add-platform android

# iOS (only works on macOS)
meteor add-platform ios
```

### Run emulator

You can now run the application in development mode using the `meteor run` command:

```sh
# Android
meteor run android

# iOS (only works on macOS)
meteor run ios
```

#### Launch a new Android emulator

1. **Open AVD Manager**: Go to **Tools** > **AVD Manager**.
2. **Create New Device**: Click **Create Virtual Device...**.
3. **Choose Hardware Profile**: Select a hardware profile and click **Next**.
4. **Select System Image**: Choose a system image and click **Next**.
5. **Configure Settings**: Name your AVD and adjust settings, then click **Finish**.
6. **Launch Emulator**: Click the **green play icon** to start the emulator.
7. **Run Meteor apps**: Run `meteor run android`. 

#### Launch a new iOS emulator

In iOS, you can launch simulator by opening Xcode and choose the desired simulator device from the device list at the top.

### Run physical device

To run on a physical device, ensure the device is connected via USB or Wi-Fi:

```sh
# Android
meteor run android-device

# iOS (only works on macOS)
meteor run ios-device
```

You can manage connected devices in Android Studio and Xcode.

### Open IDE

Once you have set up your Meteor project with Cordova, you may want to run or debug your mobile app using **Android Studio** or **XCode** directly. This can be useful for advanced debugging, custom configurations, or accessing specific platform tools

#### Open in Android Studio

1. Open **Android Studio**
2. Click on **"Open an existing Android Studio project"**
3. Navigate to your Meteor project directory:  
   `.meteor/local/cordova-build/platforms/android/`
4. Open the project

Now you can manage your app with **Android Studio**, including connecting to physical devices or emulators, reviewing code, using debugging tools, and more.

#### Open in XCode

1. Open **XCode**
2. Navigate to the Meteor project directory:  
   `.meteor/local/cordova-build/platforms/ios/`
3. Open the project or the `.xcworkspace` file

Now you can manage your app with **XCode**, including connecting to physical devices or emulators, reviewing code, using debugging tools, and more.

## Production

### Build

Once development is complete, you’ll need to build the actual mobile application (APK/AAB for Android or IPA for iOS) to distribute to users or upload to the app stores.

```sh
meteor build ../build-output --server=https://your-server-url.com
```

### Distribute

After building your Cordova project with Meteor, you can use **Android Studio** for Android and **Xcode** for iOS to handle signing and creating the final artifacts.

#### Android

1. Open **Android Studio**
2. Click on **"Open an existing Android Studio project"**
3. Navigate to your Meteor project directory:  
   `./build-output/android/project`
4. Open the project
5. Go to **Build > Generate Signed Bundle / APK**
6. Follow the prompts to create or use a keystore, [configure signing](https://developer.android.com/studio/publish/app-signing#sign-apk), and build the APK/ABB.
7. Upload the APK/ABB to Play Store using Google Play Console


#### iOS

1. Open **XCode**
2. Navigate to the Meteor project directory:  
   `../build-output/ios/project`
3. Open the project or the `.xcworkspace` file
4. [Configure Signing in Xcode](https://developer.apple.com/documentation/xcode/sharing-your-teams-signing-certificates)
5. Go to **Product > Archive** to create an archive of your app
6. In the **Organizer** window, click **Distribute App** and follow the prompts to configure signing and export the IPA file.
7. Upload the IPA file to the App Store or distribute via TestFlight.

# Legacy device support

Meteor distinguishes between legacy and modern browsers - see the [modern browsers package](../packages/modern-browsers). Web apps include different code bundles for each, but Cordova apps only have a single code bundle. From Meteor 3.3.2 onwards, the default code bundle changed from legacy to modern.

You can force Meteor to use the legacy browser code bundle by setting the variable `cordova.disableModern` to `true` in `package.json` when running or building your app. For example:

```
  "meteor": {
    "mainModule": { ... },
    "testModule": { ... },
    "cordova": { "disableModern":  true}
  }
```

Both the App Store and Google Play will only publish new and updated apps for a certain minimum mobile OS version. As of 2025, these minimum OS versions support the  modern browser code bundle. 

---

---
url: /api/packages-listing.md
---


[//]: # (Do not edit this file by hand.)

[//]: # (This is a generated file.)

[//]: # (If you want to change something in this file)

[//]: # (go to meteor/docs/generators/packages-listing)

# Core Packages


### [blaze](https://github.com/meteor/blaze) {#blaze}
### [react-packages](https://github.com/meteor/react-packages) {#react-packages}
### [accounts-2fa](https://github.com/meteor/meteor/tree/devel/packages/accounts-2fa) {#accounts-2fa}
### [accounts-base](https://github.com/meteor/meteor/tree/devel/packages/accounts-base) {#accounts-base}
### [accounts-facebook](https://github.com/meteor/meteor/tree/devel/packages/accounts-facebook) {#accounts-facebook}
### [accounts-github](https://github.com/meteor/meteor/tree/devel/packages/accounts-github) {#accounts-github}
### [accounts-google](https://github.com/meteor/meteor/tree/devel/packages/accounts-google) {#accounts-google}
### [accounts-meetup](https://github.com/meteor/meteor/tree/devel/packages/accounts-meetup) {#accounts-meetup}
### [accounts-meteor-developer](https://github.com/meteor/meteor/tree/devel/packages/accounts-meteor-developer) {#accounts-meteor-developer}
### [accounts-oauth](https://github.com/meteor/meteor/tree/devel/packages/accounts-oauth) {#accounts-oauth}
### [accounts-password](https://github.com/meteor/meteor/tree/devel/packages/accounts-password) {#accounts-password}
### [accounts-passwordless](https://github.com/meteor/meteor/tree/devel/packages/accounts-passwordless) {#accounts-passwordless}
### [accounts-twitter](https://github.com/meteor/meteor/tree/devel/packages/accounts-twitter) {#accounts-twitter}
### [accounts-ui](https://github.com/meteor/meteor/tree/devel/packages/accounts-ui) {#accounts-ui}
### [accounts-ui-unstyled](https://github.com/meteor/meteor/tree/devel/packages/accounts-ui-unstyled) {#accounts-ui-unstyled}
### [accounts-weibo](https://github.com/meteor/meteor/tree/devel/packages/accounts-weibo) {#accounts-weibo}
### [allow-deny](https://github.com/meteor/meteor/tree/devel/packages/allow-deny) {#allow-deny}
### [audit-argument-checks](https://github.com/meteor/meteor/tree/devel/packages/audit-argument-checks) {#audit-argument-checks}
### [autopublish](https://github.com/meteor/meteor/tree/devel/packages/autopublish) {#autopublish}
### [autoupdate](https://github.com/meteor/meteor/tree/devel/packages/autoupdate) {#autoupdate}
### [babel-compiler](https://github.com/meteor/meteor/tree/devel/packages/babel-compiler) {#babel-compiler}
### [babel-runtime](https://github.com/meteor/meteor/tree/devel/packages/babel-runtime) {#babel-runtime}
### [base64](https://github.com/meteor/meteor/tree/devel/packages/base64) {#base64}
### [binary-heap](https://github.com/meteor/meteor/tree/devel/packages/binary-heap) {#binary-heap}
### [boilerplate-generator](https://github.com/meteor/meteor/tree/devel/packages/boilerplate-generator) {#boilerplate-generator}
### [boilerplate-generator-tests](https://github.com/meteor/meteor/tree/devel/packages/boilerplate-generator-tests) {#boilerplate-generator-tests}
### [browser-policy](https://github.com/meteor/meteor/tree/devel/packages/browser-policy) {#browser-policy}
### [browser-policy-common](https://github.com/meteor/meteor/tree/devel/packages/browser-policy-common) {#browser-policy-common}
### [browser-policy-content](https://github.com/meteor/meteor/tree/devel/packages/browser-policy-content) {#browser-policy-content}
### [browser-policy-framing](https://github.com/meteor/meteor/tree/devel/packages/browser-policy-framing) {#browser-policy-framing}
### [caching-compiler](https://github.com/meteor/meteor/tree/devel/packages/caching-compiler) {#caching-compiler}
### [callback-hook](https://github.com/meteor/meteor/tree/devel/packages/callback-hook) {#callback-hook}
### [check](https://github.com/meteor/meteor/tree/devel/packages/check) {#check}
### [constraint-solver](https://github.com/meteor/meteor/tree/devel/packages/constraint-solver) {#constraint-solver}
### [core-runtime](https://github.com/meteor/meteor/tree/devel/packages/core-runtime) {#core-runtime}
### [crosswalk](https://github.com/meteor/meteor/tree/devel/packages/crosswalk) {#crosswalk}
### [ddp](https://github.com/meteor/meteor/tree/devel/packages/ddp) {#ddp}
### [ddp-client](https://github.com/meteor/meteor/tree/devel/packages/ddp-client) {#ddp-client}
### [ddp-common](https://github.com/meteor/meteor/tree/devel/packages/ddp-common) {#ddp-common}
### [ddp-rate-limiter](https://github.com/meteor/meteor/tree/devel/packages/ddp-rate-limiter) {#ddp-rate-limiter}
### [ddp-server](https://github.com/meteor/meteor/tree/devel/packages/ddp-server) {#ddp-server}
### [deprecated](https://github.com/meteor/meteor/tree/devel/packages/deprecated) {#deprecated}
### [dev-error-overlay](https://github.com/meteor/meteor/tree/devel/packages/dev-error-overlay) {#dev-error-overlay}
### [diff-sequence](https://github.com/meteor/meteor/tree/devel/packages/diff-sequence) {#diff-sequence}
### [disable-oplog](https://github.com/meteor/meteor/tree/devel/packages/disable-oplog) {#disable-oplog}
### [dynamic-import](https://github.com/meteor/meteor/tree/devel/packages/dynamic-import) {#dynamic-import}
### [ecmascript](https://github.com/meteor/meteor/tree/devel/packages/ecmascript) {#ecmascript}
### [ecmascript-runtime](https://github.com/meteor/meteor/tree/devel/packages/ecmascript-runtime) {#ecmascript-runtime}
### [ecmascript-runtime-client](https://github.com/meteor/meteor/tree/devel/packages/ecmascript-runtime-client) {#ecmascript-runtime-client}
### [ecmascript-runtime-server](https://github.com/meteor/meteor/tree/devel/packages/ecmascript-runtime-server) {#ecmascript-runtime-server}
### [ejson](https://github.com/meteor/meteor/tree/devel/packages/ejson) {#ejson}
### [email](https://github.com/meteor/meteor/tree/devel/packages/email) {#email}
### [es5-shim](https://github.com/meteor/meteor/tree/devel/packages/es5-shim) {#es5-shim}
### [facebook-config-ui](https://github.com/meteor/meteor/tree/devel/packages/facebook-config-ui) {#facebook-config-ui}
### [facebook-oauth](https://github.com/meteor/meteor/tree/devel/packages/facebook-oauth) {#facebook-oauth}
### [facts-base](https://github.com/meteor/meteor/tree/devel/packages/facts-base) {#facts-base}
### [facts-ui](https://github.com/meteor/meteor/tree/devel/packages/facts-ui) {#facts-ui}
### [fetch](https://github.com/meteor/meteor/tree/devel/packages/fetch) {#fetch}
### [force-ssl](https://github.com/meteor/meteor/tree/devel/packages/force-ssl) {#force-ssl}
### [force-ssl-common](https://github.com/meteor/meteor/tree/devel/packages/force-ssl-common) {#force-ssl-common}
### [geojson-utils](https://github.com/meteor/meteor/tree/devel/packages/geojson-utils) {#geojson-utils}
### [github-config-ui](https://github.com/meteor/meteor/tree/devel/packages/github-config-ui) {#github-config-ui}
### [github-oauth](https://github.com/meteor/meteor/tree/devel/packages/github-oauth) {#github-oauth}
### [google-config-ui](https://github.com/meteor/meteor/tree/devel/packages/google-config-ui) {#google-config-ui}
### [google-oauth](https://github.com/meteor/meteor/tree/devel/packages/google-oauth) {#google-oauth}
### [hot-code-push](https://github.com/meteor/meteor/tree/devel/packages/hot-code-push) {#hot-code-push}
### [hot-module-replacement](https://github.com/meteor/meteor/tree/devel/packages/hot-module-replacement) {#hot-module-replacement}
### [id-map](https://github.com/meteor/meteor/tree/devel/packages/id-map) {#id-map}
### [insecure](https://github.com/meteor/meteor/tree/devel/packages/insecure) {#insecure}
### [inter-process-messaging](https://github.com/meteor/meteor/tree/devel/packages/inter-process-messaging) {#inter-process-messaging}
### [launch-screen](https://github.com/meteor/meteor/tree/devel/packages/launch-screen) {#launch-screen}
### [localstorage](https://github.com/meteor/meteor/tree/devel/packages/localstorage) {#localstorage}
### [logging](https://github.com/meteor/meteor/tree/devel/packages/logging) {#logging}
### [logic-solver](https://github.com/meteor/meteor/tree/devel/packages/logic-solver) {#logic-solver}
### [meetup-config-ui](https://github.com/meteor/meteor/tree/devel/packages/meetup-config-ui) {#meetup-config-ui}
### [meetup-oauth](https://github.com/meteor/meteor/tree/devel/packages/meetup-oauth) {#meetup-oauth}
### [meteor](https://github.com/meteor/meteor/tree/devel/packages/meteor) {#meteor}
### [meteor-base](https://github.com/meteor/meteor/tree/devel/packages/meteor-base) {#meteor-base}
### [meteor-developer-config-ui](https://github.com/meteor/meteor/tree/devel/packages/meteor-developer-config-ui) {#meteor-developer-config-ui}
### [meteor-developer-oauth](https://github.com/meteor/meteor/tree/devel/packages/meteor-developer-oauth) {#meteor-developer-oauth}
### [meteor-tool](https://github.com/meteor/meteor/tree/devel/packages/meteor-tool) {#meteor-tool}
### [minifier-css](https://github.com/meteor/meteor/tree/devel/packages/minifier-css) {#minifier-css}
### [minifier-js](https://github.com/meteor/meteor/tree/devel/packages/minifier-js) {#minifier-js}
### [minimongo](https://github.com/meteor/meteor/tree/devel/packages/minimongo) {#minimongo}
### [mobile-experience](https://github.com/meteor/meteor/tree/devel/packages/mobile-experience) {#mobile-experience}
### [mobile-status-bar](https://github.com/meteor/meteor/tree/devel/packages/mobile-status-bar) {#mobile-status-bar}
### [modern-browsers](https://github.com/meteor/meteor/tree/devel/packages/modern-browsers) {#modern-browsers}
### [modules](https://github.com/meteor/meteor/tree/devel/packages/modules) {#modules}
### [modules-runtime](https://github.com/meteor/meteor/tree/devel/packages/modules-runtime) {#modules-runtime}
### [modules-runtime-hot](https://github.com/meteor/meteor/tree/devel/packages/modules-runtime-hot) {#modules-runtime-hot}
### [mongo](https://github.com/meteor/meteor/tree/devel/packages/mongo) {#mongo}
### [mongo-dev-server](https://github.com/meteor/meteor/tree/devel/packages/mongo-dev-server) {#mongo-dev-server}
### [mongo-id](https://github.com/meteor/meteor/tree/devel/packages/mongo-id) {#mongo-id}
### [mongo-livedata](https://github.com/meteor/meteor/tree/devel/packages/mongo-livedata) {#mongo-livedata}
### [npm-mongo](https://github.com/meteor/meteor/tree/devel/packages/npm-mongo) {#npm-mongo}
### [npm-mongo-legacy](https://github.com/meteor/meteor/tree/devel/packages/npm-mongo-legacy) {#npm-mongo-legacy}
### [oauth](https://github.com/meteor/meteor/tree/devel/packages/oauth) {#oauth}
### [oauth-encryption](https://github.com/meteor/meteor/tree/devel/packages/oauth-encryption) {#oauth-encryption}
### [oauth1](https://github.com/meteor/meteor/tree/devel/packages/oauth1) {#oauth1}
### [oauth2](https://github.com/meteor/meteor/tree/devel/packages/oauth2) {#oauth2}
### [ordered-dict](https://github.com/meteor/meteor/tree/devel/packages/ordered-dict) {#ordered-dict}
### [package-stats-opt-out](https://github.com/meteor/meteor/tree/devel/packages/package-stats-opt-out) {#package-stats-opt-out}
### [package-version-parser](https://github.com/meteor/meteor/tree/devel/packages/package-version-parser) {#package-version-parser}
### [promise](https://github.com/meteor/meteor/tree/devel/packages/promise) {#promise}
### [random](https://github.com/meteor/meteor/tree/devel/packages/random) {#random}
### [rate-limit](https://github.com/meteor/meteor/tree/devel/packages/rate-limit) {#rate-limit}
### [react-fast-refresh](https://github.com/meteor/meteor/tree/devel/packages/react-fast-refresh) {#react-fast-refresh}
### [reactive-dict](https://github.com/meteor/meteor/tree/devel/packages/reactive-dict) {#reactive-dict}
### [reactive-var](https://github.com/meteor/meteor/tree/devel/packages/reactive-var) {#reactive-var}
### [reload](https://github.com/meteor/meteor/tree/devel/packages/reload) {#reload}
### [reload-safetybelt](https://github.com/meteor/meteor/tree/devel/packages/reload-safetybelt) {#reload-safetybelt}
### [retry](https://github.com/meteor/meteor/tree/devel/packages/retry) {#retry}
### [roles](https://github.com/meteor/meteor/tree/devel/packages/roles) {#roles}
### [routepolicy](https://github.com/meteor/meteor/tree/devel/packages/routepolicy) {#routepolicy}
### [server-render](https://github.com/meteor/meteor/tree/devel/packages/server-render) {#server-render}
### [service-configuration](https://github.com/meteor/meteor/tree/devel/packages/service-configuration) {#service-configuration}
### [session](https://github.com/meteor/meteor/tree/devel/packages/session) {#session}
### [sha](https://github.com/meteor/meteor/tree/devel/packages/sha) {#sha}
### [shell-server](https://github.com/meteor/meteor/tree/devel/packages/shell-server) {#shell-server}
### [socket-stream-client](https://github.com/meteor/meteor/tree/devel/packages/socket-stream-client) {#socket-stream-client}
### [standard-minifier-css](https://github.com/meteor/meteor/tree/devel/packages/standard-minifier-css) {#standard-minifier-css}
### [standard-minifier-js](https://github.com/meteor/meteor/tree/devel/packages/standard-minifier-js) {#standard-minifier-js}
### [standard-minifiers](https://github.com/meteor/meteor/tree/devel/packages/standard-minifiers) {#standard-minifiers}
### [static-html](https://github.com/meteor/meteor/tree/devel/packages/static-html) {#static-html}
### [static-html-tools](https://github.com/meteor/meteor/tree/devel/packages/static-html-tools) {#static-html-tools}
### [test-helpers](https://github.com/meteor/meteor/tree/devel/packages/test-helpers) {#test-helpers}
### [test-in-browser](https://github.com/meteor/meteor/tree/devel/packages/test-in-browser) {#test-in-browser}
### [test-in-console](https://github.com/meteor/meteor/tree/devel/packages/test-in-console) {#test-in-console}
### [test-server-tests-in-console-once](https://github.com/meteor/meteor/tree/devel/packages/test-server-tests-in-console-once) {#test-server-tests-in-console-once}
### [tinytest](https://github.com/meteor/meteor/tree/devel/packages/tinytest) {#tinytest}
### [tinytest-harness](https://github.com/meteor/meteor/tree/devel/packages/tinytest-harness) {#tinytest-harness}
### [tracker](https://github.com/meteor/meteor/tree/devel/packages/tracker) {#tracker}
### [twitter-config-ui](https://github.com/meteor/meteor/tree/devel/packages/twitter-config-ui) {#twitter-config-ui}
### [twitter-oauth](https://github.com/meteor/meteor/tree/devel/packages/twitter-oauth) {#twitter-oauth}
### [typescript](https://github.com/meteor/meteor/tree/devel/packages/typescript) {#typescript}
### [url](https://github.com/meteor/meteor/tree/devel/packages/url) {#url}
### [webapp](https://github.com/meteor/meteor/tree/devel/packages/webapp) {#webapp}
### [webapp-hashing](https://github.com/meteor/meteor/tree/devel/packages/webapp-hashing) {#webapp-hashing}
### [weibo-config-ui](https://github.com/meteor/meteor/tree/devel/packages/weibo-config-ui) {#weibo-config-ui}
### [weibo-oauth](https://github.com/meteor/meteor/tree/devel/packages/weibo-oauth) {#weibo-oauth}

---

---
url: /api/DDPRateLimiter.md
---
# DDPRateLimiter

Customize rate limiting for methods and subscriptions to avoid a high load of WebSocket messages in your app.

> Galaxy (Meteor hosting) offers additional App Protection, [read more](https://galaxy-support.meteor.com/en/article/ddos-mitigation-1qb032b/) and try it with our [free plans](https://galaxy-support.meteor.com/en/article/billing-4gyv1p/).

By default, `DDPRateLimiter` is configured with a single rule. This rule
limits login attempts, new user creation, and password resets to 5 attempts
every 10 seconds per connection. It can be removed by calling
`Accounts.removeDefaultRateLimit()`.

To use `DDPRateLimiter` for modifying the default rate-limiting rules,
add the `ddp-rate-limiter` package to your project in your terminal:

```bash
meteor add ddp-rate-limiter
```

<ApiBox name="DDPRateLimiter.addRule" hasCustomExample/>

Custom rules can be added by calling `DDPRateLimiter.addRule`. The rate
limiter is called on every method and subscription invocation.

A rate limit is reached when a bucket has surpassed the rule's predefined
capacity, at which point errors will be returned for that input until the
buckets are reset. Buckets are regularly reset after the end of a time
interval.


Here's example of defining a rule and adding it into the `DDPRateLimiter`:
```js
// Define a rule that matches login attempts by non-admin users.
const loginRule = {
  userId(userId) {
    const user = Meteor.users.findOne(userId);
    return user && user.type !== 'admin';
  },

  type: 'method',
  name: 'login'
};

// Add the rule, allowing up to 5 messages every 1000 milliseconds.
DDPRateLimiter.addRule(loginRule, 5, 1000);

```

<ApiBox name="DDPRateLimiter.removeRule" />
<ApiBox name="DDPRateLimiter.setErrorMessage" />
<ApiBox name="DDPRateLimiter.setErrorMessageOnRule" />

Allows developers to specify custom error messages for each rule instead of being
limited to one global error message for every rule.
It adds some clarity to what rules triggered which errors, allowing for better UX
and also opens the door for i18nable error messages per rule instead of the
default English error message.

Here is an example with a custom error message:
```js
const setupGoogleAuthenticatorRule = {
  userId(userId) {
    const user = Meteor.users.findOne(userId);
    return user;
  },
  type: 'method',
  name: 'Users.setupGoogleAuthenticator',
};

// Add the rule, allowing up to 1 google auth setup message every 60 seconds
const ruleId = DDPRateLimiter.addRule(setupGoogleAuthenticatorRule, 1, 60000);
DDPRateLimiter.setErrorMessageOnRule(ruleId, function (data) {
  return `You have reached the maximum number of Google Authenticator attempts. Please try again in ${Math.ceil(data.timeToReset / 1000)} seconds.`;
});
```

Or a more simple approach:

```js
const ruleId = DDPRateLimiter.addRule(setupGoogleAuthenticatorRule, 1, 60000);
DDPRateLimiter.setErrorMessageOnRule(ruleId, 'Example as a single string error message');
```

---

---
url: /about/modern-build-stack/dev-server.md
---
# Dev Server

Meteor Dev Server provides real-time file watching during development, with fast feedback through HMR, bundle visualizers, debug tools, Mongo built-in instance, CLI tools and more. At runtime, it offers a complete server environment supporting SSR and modern Express-based APIs.

As part of the modern build stack, we update each component for improved performance, smarter tooling, and better bundle observability and debugging. While Meteor Dev Server remains at the core, we’ll integrate modern tools and a new bundler to enhance your app development.

## Watcher

:::info
Starting with Meteor 3.3
:::

> The watcher listens for changes in your app’s code files and triggers quick recompilations.

New apps use a modern, cross-platform watcher: [`@parcel/watcher`](https://github.com/parcel-bundler/watcher). It responds quickly to file changes using native file watching. Symbolic link changes and all traversed files are supported via polling.

For existing apps, enable this by adding to `package.json`:

```json
"meteor": {
  "modern": true
}
```

If you run into issues with the new watcher, you can revert to the previous implementation for better file change detection. To disable the new watcher, set `"watcher": false` in your package.json.

```json
"meteor": {
  "modern": {
    "watcher": false
  }
}
```

The modern watcher uses the OS's native file watching with a performance-first approach. Both modern and legacy watchers support environment variables for polling, useful in edge cases like WSL with host, volumes, or remote setups.

To enable polling, run your Meteor app with:

```shell
# enable polling
METEOR_WATCH_FORCE_POLLING=true meteor run

# set polling interval (in ms)
METEOR_WATCH_POLLING_INTERVAL_MS=1000 METEOR_WATCH_FORCE_POLLING=true meteor run
```

> Polling uses more CPU and RAM, but it's the most reliable option in some environments.

---

---
url: /packages/dynamic-import.md
---
# Dynamic Imports

> **Note:** Dynamic imports require Meteor 1.5 or higher.

The `dynamic-import` package provides an implementation of
`Module.prototype.dynamicImport`, an extension of the module runtime which
powers the [dynamic `import(...)`](https://github.com/tc39/proposal-dynamic-import)
statement, an up-and-coming (ECMA2020) addition to the
ECMAScript standard.

The dynamic `import(...)` statement is a complementary method to the static
`import` technique of requiring a module. While a statically `import`-ed
module would be bundled into the initial JavaScript bundle, a
dynamically `import()`-ed module is fetched from the server at
runtime.

Once a module is fetched dynamically from the server, it is cached permanently
on the client and additional requests for the same version of the module will
not incur the round-trip request to the server. If the module is changed then a
fresh copy will always be retrieved from the server.

## Usage

The `import(...)` statement returns a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises)
which is resolved with the `exports` of the module when it has been successfully
fetched from the server and is ready to be used.

Because it's a `Promise`, there are a couple methods developers can use to
dictate what will happen upon the availability of the dynamically loaded module:

### The `.then()` method of the `Promise`

```js
import("tool").then((tool) => tool.task());
```

### By `await`-ing in an asynchronous function

Meteor supports [`async` and `await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function),
which provide a straightforward approach to asynchronously wait for the
module to be ready without the need to provide a callback:

```js
async function performTask() {
  const tool = await import("tool");
  tool.task();
}
```

::: warning
**Default exports**

The `import(...)` `Promise` is resolved with the `exports` of the module.
If it's necessary to use the "default" export from a module, it will be
available on the `default` property of the resulting object. In the above
examples, this means it will be available as `tool.default`. It can be
helpful to use parameter de-structuring to provide additional clarity:

```js
import("another-tool").then(({ default: thatTool }) => thatTool.go());
```

:::

### Using `import()` with dynamic expressions

If you try to import using any computed expression, such as:

```js
let path = "example";
const module = await import(`/libs/${path}.js`);
```

You'll get an error like so:

```js
Error: Cannot find module '/libs/example.js'
```

Meteor’s build process builds a graph of all files that are imported or required
using static analysis. It then creates exact bundles of the referenced files
and makes them available to the client for `import()`.

Without a complete import statement (static, dynamic or `require`), Meteor won't
make that module available for `import()`.

The solution to make dynamic expressions work is to create a module "whitelist"
that can be read by the build process, but does not actually run. For example:

```js
if (false) {
  import("/libs/example.js");
  import("/libs/another-example.js");
  import("/libs/yet-another-example.js");
}
```

Make sure the whitelist is imported from both the client and server entry points.

## Difference to other bundling systems

In Meteor's implementation, the client has perfect information about which
modules were in the initial bundle, which modules are in the local cache, and
which modules still need to be fetched. There is never any overlap between
requests made by a single client, nor will there be any unneeded modules in the
response from the server. You might call this strategy **exact code splitting**,
to differentiate it from bundling.

Moreover, the initial bundle includes the hashes of all available dynamic
modules, so the client doesn't have to ask the server if it can use a cached
version of a module, and the same version of the module never needs to be
downloaded again by the same client. This caching system has all the benefits of
immutable caching.

Meteor also allows dynamic expressions as long as the dependency is expressed
statically somewhere else in your code. This is possible because Meteor's
client-side module system understands how to resolve dynamic strings at runtime
(which is not true in webpack or browserify, because they replace module
identifier strings with numbers). However, the set of available modules is
constrained by the string literals that you, the programmer, explicitly decided
to allow to be imported (either directly or in a whitelist).

---

---
url: /packages/ecmascript.md
---
# ECMAScript

This package lets you use new JavaScript language features that are part
of the [ECMAScript 2015 specification](http://www.ecma-international.org/ecma-262/6.0/) but are
not yet supported by all engines or browsers. Unsupported syntax is
automatically translated into standard JavaScript that behaves the same
way.

[This video](https://www.youtube.com/watch?v=05Z6YGiZKmE) from the July
2015 Meteor Devshop gives an overview of how the package works, and what
it provides.

## Usage

The `ecmascript` package registers a compiler plugin that transpiles
ECMAScript 2015+ to ECMAScript 5 (standard JS) in all `.js` files. By
default, this package is pre-installed for all new apps and packages.

To add this package to an existing app, run the following command from
your app directory:

```bash
meteor add ecmascript
```

To add the `ecmascript` package to an existing package, include the
statement `api.use('ecmascript');` in the `Package.onUse` callback in your
`package.js` file:

```js
Package.onUse((api) => {
  api.use('ecmascript');
});
```

## Supported ES2015 Features

### Syntax

The `ecmascript` package uses [Babel](http://babeljs.io/) to compile
ES2015 syntax to ES5 syntax. Many but not all ES2015 features can be
simulated by Babel, and `ecmascript` enables most of the features
supported by Babel.

Here is a list of the Babel transformers that are currently enabled:

* [`es3.propertyLiterals`](https://babeljs.io/docs/advanced/transformers/es3/property-literals/)<br>
  Makes it safe to use reserved keywords like `catch` as unquoted keys in
  object literals. For example, `{ catch: 123 }` is translated to `{ "catch": 123 }`.

* [`es3.memberExpressionLiterals`](https://babeljs.io/docs/advanced/transformers/es3/member-expression-literals/)<br>
  Makes it safe to use reserved keywords as property names. For
  example, `object.catch` is translated to `object["catch"]`.

* [`es6.arrowFunctions`](http://babeljs.io/docs/learn-es2015/#arrows)<br>
  Provides a shorthand for function expressions. For example,
  `[1, 2, 3].map(x => x + 1)` evaluates to `[2, 3, 4]`. If `this` is used
  in the body of the arrow function, it will be automatically bound to the
  value of `this` in the enclosing scope.

* [`es6.literals`](http://babeljs.io/docs/learn-es2015/#binary-and-octal-literals)<br>
  Adds support for binary and octal numeric literals. For example,
  `0b111110111 === 503` and `0o767 === 503`.

* [`es6.templateLiterals`](http://babeljs.io/docs/learn-es2015/#template-strings)<br>
  Enables multi-line strings delimited by backticks instead of quotation
  marks, with variable interpolation:
  ```js
  var name = 'Ben';
  var message = `My name is:
  ${name}`;
  ```

* [`es6.classes`](http://babeljs.io/docs/learn-es2015/#classes)<br>
  Enables `class` syntax:
  ```js
  class Base {
    constructor(a, b) {
      this.value = a * b;
    }
  }

  class Derived extends Base {
    constructor(a, b) {
      super(a + 1, b + 1);
    }
  }

  var d = new Derived(2, 3);
  d.value; // 12
  ```

* [`es6.constants`](https://babeljs.io/docs/learn-es2015/#let-const)<br>
  Allows defining block-scoped variables that are not allowed to be
  redefined:
  ```js
  const GOLDEN_RATIO = (1 + Math.sqrt(5)) / 2;

  // This reassignment will be forbidden by the compiler:
  GOLDEN_RATIO = 'new value';
  ```

* [`es6.blockScoping`](http://babeljs.io/docs/learn-es2015/#let-const)<br>
  Enables the `let` and `const` keywords as alternatives to `var`. The key
  difference is that variables defined using `let` or `const` are
  visible only within the block where they are declared, rather than being
  visible anywhere in the enclosing function. For example:
  ```js
  function example(condition) {
    let x = 0;
    if (condition) {
      let x = 1;
      console.log(x);
    } else {
      console.log(x);
      x = 2;
    }
    return x;
  }

  example(true); // logs 1, returns 0
  example(false); // logs 0, returns 2
  ```

* [`es6.properties.shorthand`](https://babeljs.io/docs/learn-es2015/#enhanced-object-literals)<br>
  Allows omitting the value of an object literal property when the desired
  value is held by a variable that has the same name as the property
  key. For example, instead of writing `{ x: x, y: y, z: "asdf" }` you can
  just write `{ x, y, z: "asdf" }`. Methods can also be written without
  the `: function` property syntax:
  ```js
  var obj = {
    oldWay: function (a, b) { ... },
    newWay(a, b) { ... }
  };
  ```

* [`es6.properties.computed`](http://babeljs.io/docs/learn-es2015/#enhanced-object-literals)<br>
  Allows object literal properties with dynamically computed keys:
  ```js
  var counter = 0;
  function getKeyName() {
    return 'key' + counter++;
  }

  var obj = {
    [getKeyName()]: 'zero',
    [getKeyName()]: 'one',
  };

  obj.key0; // 'zero'
  obj.key1; // 'one'
  ```

* [`es6.parameters`](http://babeljs.io/docs/learn-es2015/#default-rest-spread)<br>
  Default expressions for function parameters, evaluated whenever the parameter
  is `undefined`, `...rest` parameters for capturing remaining
  arguments without using the `arguments` object:
  ```js
  function add(a = 0, ...rest) {
    rest.forEach(n => a += n);
    return a;
  }

  add(); // 0
  add(1, 2, 3); // 6
  ```

* [`es6.spread`](http://babeljs.io/docs/learn-es2015/#default-rest-spread)<br>
  Allows an array of arguments to be interpolated into a list of arguments
  to a function call, `new` expression, or array literal, without using
  `Function.prototype.apply`:
  ```js
  add(1, ...[2, 3, 4], 5); // 15
  new Node('name', ...children);
  [1, ...[2, 3, 4], 5]; // [1, 2, 3, 4, 5]
  ```

* [`es6.forOf`](http://babeljs.io/docs/learn-es2015/#iterators-for-of)<br>
  Provides an easy way to iterate over the elements of a collection:
  ```js
  let sum = 0;
  for (var x of [1, 2, 3]) {
    sum += x;
  }
  sum; // 6
  ```

* [`es6.destructuring`](http://babeljs.io/docs/learn-es2015/#destructuring)<br>
  Destructuring is the technique of using an array or object pattern on
  the left-hand side of an assignment or declaration, in place of the
  usual variable or parameter, so that certain sub-properties of the value
  on the right-hand side will be bound to identifiers that appear within the
  pattern. Perhaps the simplest example is swapping two variables without
  using a temporary variable:
  ```js
  [a, b] = [b, a];
  ```
  Extracting a specific property from an object:
  ```js
  let { username: name } = user;
  // is equivalent to
  let name = user.username;
  ```
  Instead of taking a single opaque `options` parameter, a function can
  use an object destructuring pattern to name the expected options:
  ```js
  function run({ command, args, callback }) { ... }

  run({
    command: 'git',
    args: ['status', '.'],
    callback(error, status) { ... },
    unused: 'whatever'
  });
  ```

* [`es7.objectRestSpread`](https://github.com/sebmarkbage/ecmascript-rest-spread)<br>
  Supports catch-all `...rest` properties in object literal declarations
  and assignments:
  ```js
  let { x, y, ...rest } = { x: 1, y: 2, a: 3, b: 4 };
  x; // 1
  y; // 2
  rest; // { a: 3, b: 4 }
  ```
  Also enables `...spread` properties in object literal expressions:
  ```js
  let n = { x, y, ...rest };
  n; // { x: 1, y: 2, a: 3, b: 4 }
  ```

* [`es7.trailingFunctionCommas`](https://github.com/jeffmo/es-trailing-function-commas)<br>
  Allows the final parameter of a function to be followed by a comma,
  provided that parameter is not a `...rest` parameter.

* [`flow`](https://babeljs.io/docs/advanced/transformers/other/flow/)<br>
  Permits the use of [Flow](http://flowtype.org/) type annotations. These
  annotations are simply stripped from the code, so they have no effect on
  the code's behavior, but you can run the `flow` tool over your code to
  check the types if desired.

### Polyfills

The ECMAScript 2015 standard library has grown to include new APIs and
data structures, some of which can be implemented ("polyfilled") using
JavaScript that runs in all engines and browsers today. Here are three new
constructors that are guaranteed to be available when the `ecmascript`
package is installed:

* [`Promise`](https://github.com/meteor/promise)<br>
  A `Promise` allows its owner to wait for a value that might not be
  available yet. See [this tutorial](https://www.promisejs.org/) for more
  details about the API and motivation. The Meteor `Promise`
  implementation is especially useful because it runs all callback
  functions in recycled `Fiber`s, so you can use any Meteor API, including
  those that yield (e.g. `HTTP.get`, `Meteor.call`, or `MongoCollection`),
  and you never have to call `Meteor.bindEnvironment`.

* [`Map`](https://github.com/zloirock/core-js#map)<br>
  An associative key-value data structure where the keys can be any
  JavaScript value (not just strings). Lookup and insertion take constant
  time.

* [`Set`](https://github.com/zloirock/core-js#set)<br>
  A collection of unique JavaScript values of any type. Lookup and
  insertion take constant time.

* [`Symbol`](https://github.com/zloirock/core-js#ecmascript-6-symbol)<br>
  An implementation of the global
  [`Symbol`](http://www.2ality.com/2014/12/es6-symbols.html)s namespace
  that enables a number of other ES2015 features, such as `for`-`of` loops
  and `Symbol.iterator` methods: `[1,2,3][Symbol.iterator]()`.

* Polyfills for the following [`Object`](https://github.com/zloirock/core-js#ecmascript-6-object)-related methods:
  * `Object.assign`
  * `Object.is`
  * `Object.setPrototypeOf`
  * `Object.prototype.toString` (fixes `@@toStringTag` support)<br>

  Complete reference [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object).

* Polyfills for the following [`String`](https://github.com/zloirock/core-js#ecmascript-6-string)-related methods:
  * `String.fromCodePoint`
  * `String.raw`
  * `String.prototype.includes`
  * `String.prototype.startsWith`
  * `String.prototype.endsWith`
  * `String.prototype.repeat`
  * `String.prototype.codePointAt`
  * `String.prototype.trim`<br>

  Complete reference [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String).

* Polyfills for the following [`Array`](https://github.com/zloirock/core-js#ecmascript-6-array)-related methods:
  * `Array.from`
  * `Array.of`
  * `Array.prototype.copyWithin`
  * `Array.prototype.fill`
  * `Array.prototype.find`
  * `Array.prototype.findIndex`

  Complete reference [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array).

* Polyfills for the following [`Function`](https://github.com/zloirock/core-js#ecmascript-6-function)-related properties:
  * `Function.prototype.name` (fixes IE9+)
  * `Function.prototype[Symbol.hasInstance]` (fixes IE9+)

  Complete reference [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array).

---

---
url: /api/EJSON.md
---
# EJSON

EJSON is an extension of JSON to support more types. It supports all JSON-safe types, as well as:

- **Date** (JavaScript `Date`)
- **Binary** (JavaScript `Uint8Array` or the
  result of [`EJSON.newBinary`](#EJSON-newBinary))
- **Special numbers** (JavaScript `NaN`, `Infinity`, and `-Infinity`)
- **Regular expressions** (JavaScript `RegExp`)
- **User-defined types** (see [`EJSON.addType`](#EJSON-addType). For example,
  [`Mongo.ObjectID`](./collections.md#Mongo-ObjectID) is implemented this way.)

All EJSON serializations are also valid JSON. For example an object with a date
and a binary buffer would be serialized in EJSON as:

```json
{
  "d": { "$date": 1358205756553 },
  "b": { "$binary": "c3VyZS4=" }
}
```

Meteor supports all built-in EJSON data types in publishers, method arguments
and results, Mongo databases, and [`Session`](./session.md) variables.

<ApiBox name="EJSON.parse" />

<ApiBox name="EJSON.stringify" hasCustomExample/>

```js
import { EJSON } from "meteor/ejson";

EJSON.stringify(
  { num: 42, someProp: "foo" },
  options // this param is optional
);
```

<ApiBox name="EJSON.fromJSONValue" />

<ApiBox name="EJSON.toJSONValue" />

<ApiBox name="EJSON.equals" />

<ApiBox name="EJSON.clone" />

<ApiBox name="EJSON.newBinary" />

Buffers of binary data are represented by `Uint8Array` instances on JavaScript
platforms that support them. On implementations of JavaScript that do not
support `Uint8Array`, binary data buffers are represented by standard arrays
containing numbers ranging from 0 to 255, and the `$Uint8ArrayPolyfill` key
set to `true`.

<ApiBox name="EJSON.isBinary" />

<ApiBox name="EJSON.addType"  hasCustomExample/>

The factory function passed to the `EJSON.addType` method should create an instance of our custom type and initialize it with values from an object passed as the first argument of the factory function. Here is an example:

```js
class Distance {
  constructor(value, unit) {
    this.value = value;
    this.unit = unit;
  }

  // Convert our type to JSON.
  toJSONValue() {
    return {
      value: this.value,
      unit: this.unit,
    };
  }

  // Unique type name.
  typeName() {
    return "Distance";
  }
}

EJSON.addType("Distance", function fromJSONValue(json) {
  return new Distance(json.value, json.unit);
});

EJSON.stringify(new Distance(10, "m"));
// Returns '{"$type":"Distance","$value":{"value":10,"unit":"m"}}'
```

When you add a type to EJSON, Meteor will be able to use that type in:

- publishing objects of your type if you pass them to publish handlers.
- allowing your type in the return values or arguments to
  [methods](./meteor.md#methods).
- storing your type client-side in Minimongo.
- allowing your type in [`Session`](./session.md) variables.

Instances of your type must implement [`typeName`](#EJSON-CustomType-typeName) and
[`toJSONValue`](#EJSON-CustomType-toJSONValue) methods, and may implement
[`clone`](#EJSON-CustomType-clone) and [`equals`](#EJSON-CustomType-equals) methods if the
default implementations are not sufficient.

<ApiBox name="EJSON.CustomType#typeName" hasCustomExample  instanceName="CustomType"/>
<ApiBox name="EJSON.CustomType#toJSONValue" hasCustomExample  instanceName="CustomType"/>

For example, the `toJSONValue` method for
[`Mongo.ObjectID`](./collections.md#Mongo-ObjectID) could be:

```js
function () {
  return this.toHexString();
}
```

<ApiBox name="EJSON.CustomType#clone" hasCustomExample  instanceName="CustomType"/>

If your type does not have a `clone` method, `EJSON.clone` will use
[`toJSONValue`](#EJSON-CustomType-toJSONValue) and the factory instead.

<ApiBox name="EJSON.CustomType#equals" hasCustomExample instanceName="CustomType"/>

The `equals` method should define an [equivalence relation](http://en.wikipedia.org/wiki/Equivalence_relation). It should have
the following properties:

- _Reflexivity_ - for any instance `a`: `a.equals(a)` must be true.
- _Symmetry_ - for any two instances `a` and `b`: `a.equals(b)` if and only if `b.equals(a)`.
- _Transitivity_ - for any three instances `a`, `b`, and `c`: `a.equals(b)` and `b.equals(c)` implies `a.equals(c)`.

If your type does not have an `equals` method, `EJSON.equals` will compare the
result of calling [`toJSONValue`](#EJSON-CustomType-toJSONValue) instead.

---

---
url: /api/email.md
---
# Email

The `email` package allows sending email from a Meteor app. To use it, add the
package to your project by running in your terminal:

```bash
meteor add email
```

There are two ways on how to setup the package for sending e-mail.

First is to set `MAIL_URL`. The server reads from the `MAIL_URL` environment
variable to determine how to send mail. The `MAIL_URL` should reference an
[SMTP](https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol) server and
use the form `smtp://USERNAME:PASSWORD@HOST:PORT` or
`smtps://USERNAME:PASSWORD@HOST:PORT`. The `smtps://` form (the `s` is for
"secure") should be used if the mail server requires TLS/SSL (and does not use
`STARTTLS`) and is most common on port 465. Connections which start unencrypted
prior to being upgraded to TLS/SSL (using `STARTTLS`) typically use port 587
(and _sometimes_ 25) and should use `smtp://`. For more information see the
[Nodemailer docs](https://nodemailer.com/smtp/)

Second, if you are using a one of the [supported services](https://community.nodemailer.com/smtp/well-known/#supported-services) you can setup the sending options in your app settings like this:

```json
{
  "packages": {
    "email": {
      "service": "Mailgun",
      "user": "postmaster@meteor.com",
      "password": "superDuperPassword"
    }
  }
}
```

The package will take care of the rest.

> If you use a supported service the package will try to match to supported service and use the stored settings instead.
> You can force this by switching protocol like `smtp` to the name of the service.
> Though you should only use this as a stop-gap measure and instead set the settings properly.

If neither option is set, `Email.send` outputs the message to standard output
instead.

> Package setting is only available since Email v2.2

<ApiBox name="Email.send" hasCustomExample/>

You must provide the `from` option and at least one of `to`, `cc`, and `bcc`;
all other options are optional.

`Email.send` only works on the server. Here is an example of how a
client could use a server method call to send an email. (In an actual
application, you'd need to be careful to limit the emails that a
client could send, to prevent your server from being used as a relay
by spammers.)

::: code-group

```js [server.js]
import { Meteor } from "meteor/meteor";
import { Email } from "meteor/email";
import { check } from "meteor/check";
// Server: Define a method that the client can call.
Meteor.methods({
  sendEmail({ to, from, subject, text }) {
    // Make sure that all arguments are strings.
    check([to, from, subject, text], [String]);

    Email.send({ to, from, subject, text });
  },
});
```

```js [client.js]
import { Meteor } from "meteor/meteor";
// Client: Asynchronously send an email.
Meteor.callAsync("sendEmail", {
  to: "Alice <alice@example.com>",
  from: "bob@example.com",
  subject: "Hello from Meteor!",
  text: "This is a test of Email.send.",
});
```

:::

<ApiBox name="Email.sendAsync" hasCustomExample/>

`sendAsync` only works on the server. It has the same behavior as `Email.send`, but returns a Promise.
If you defined `Email.customTransport`, the `callAsync` method returns the return value from the `customTransport` method or a Promise, if this method is async.

```js
// Server: Define a method that the client can call.
Meteor.methods({
  sendEmail({ to, from, subject, text }) {
    // Make sure that all arguments are strings.
    check([to, from, subject, text], [String]);

    return Email.sendAsync({ to, from, subject, text }).catch((err) => {
      // do something with the error
    });
  },
});
```

<ApiBox name="Email.hookSend" hasCustomExample/>

```js
import { Email } from 'meteor/email'

Email.hookSend(({to}) => {
  if (to === 'ceo@company.com') {
    console.log(`Let's not send email to the CEO`);
    return false;
  }
  return true;
})
```

`hookSend` is a convenient hook if you want to: prevent sending certain emails,
send emails via your own integration instead of the default one provided by
Meteor, or do something else with the data. This is especially useful
if you want to intercept emails sent by core packages like accounts-password
or other packages where you can't modify the email code.

The hook function will receive an object with the options for Nodemailer.


<ApiBox name="Email.customTransport" hasCustomExample/>

> `Email.customTransport` is only available since Email v2.2

There are scenarios when you have your own transport set up, be it an SDK
for your mailing service or something else. This is where `customTransport`
comes in. If you set this function all sending events will be passed to it
(after `hookSend` is run) with an object of the options passed into `send`
function with addition of `packageSettings` key which will pass in package settings
set in your app settings (if any). It is up to you what you do in that function
as it will override the original sending function.

Here is a simple example with Mailgun:

```javascript
import { Email } from 'meteor/email'
import { Log } from 'meteor/logging'
import Mailgun from 'mailgun-js'

Email.customTransport = (data) => {
  // `options.packageSettings` are settings from `Meteor.settings.packages.email`
  // The rest of the options are from Email.send options
  const mailgun = Mailgun({ apiKey: data.packageSettings.mailgun.privateKey, domain: 'mg.mygreatapp.com' })

  // Since the data object that we receive already includes the correct key names for sending
  // we can just pass it to the mailgun sending message.
  mailgun.messages().send(data, (error, body) => {
    if (error) Log.error(error)
    if (body) Log.info(body)
  })
}
```

> Note that this also overrides the development display of messages in console
> so you might want to differentiate between production and development for
> setting this function.

---

---
url: /cli/environment-variables.md
---

# Environment Variables
List of environment variables that you can use with your Meteor application.


## BIND_IP
(_production_)

Bind the application server to a specific network interface by IP address, for example: `BIND_IP=192.168.0.2`.

See also: [`PORT`](#port).

> In development, this can be accomplished with `meteor run --port a.b.c.d:port`.

## DDP_DEFAULT_CONNECTION_URL
(_develoment, production_)

There are some situations where it is valuable for the meteor client to use a different DDP server than the `ROOT_URL` server.

Setting `DDP_DEFAULT_CONNECTION_URL` when running a meteor server (development: `meteor run` or production: `node main.js`) will set the DDP server to the value in `DDP_DEFAULT_CONNECTION_URL`.

Setting `DDP_DEFAULT_CONNECTION_URL` when building (`meteor build`)  will define the DDP server for `cordova` builds.

## DISABLE_WEBSOCKETS
(_development, production_)

In the event that your own deployment platform does not support WebSockets, or you are confident that you will not benefit from them, setting this variable with `DISABLE_WEBSOCKETS=1` will explicitly disable WebSockets and forcibly resort to the fallback polling-mechanism, instead of trying to detect this automatically.

## DISABLE_SOCKJS
(_development, production_)

Set `DISABLE_SOCKJS=1` if you want to use the native WebSocket implementation instead of SockJS on the client side, for example, if you want to use a custom WebSocket implementation (e.g. [uWebSockets.js](https://github.com/uNetworking/uWebSockets.js/)) on the server side.

## DO_NOT_TRACK
(_development, production_)

Meteor automatically sends usage statistics about which Meteor packages your app uses by default. This behavior can be disabled by setting `DO_NOT_TRACK` to any truthy value (for example, `DO_NOT_TRACK=1`).

Having this variable set globally (say, by adding it to your `.bashrc` file) would disable statistics for all Meteor projects in your computer, and do the same for other programs that respect this flag (like [FerretDB](https://www.ferretdb.com/) or [Bun](https://bun.sh/)).

Alternatively, you can install the `package-stats-opt-out` package by calling `meteor add package-stats-opt-out` inside your Meteor project folder. Having this package installed in your project disables usage statistics being sent to the Meteor project, regardless of whether the `DO_NOT_TRACK` environment variable is set or not.

## HTTP_FORWARDED_COUNT
(_production_)

Set this to however many number of proxies you have running before your Meteor application. For example, if have an NGINX server acting as a proxy before your Meteor application, you would set `HTTP_FORWARDED_COUNT=1`. If you have a load balancer in front of that NGINX server, the count is 2.

## MAIL_URL
(_development, production_)

Use this variable to set the SMTP server for sending e-mails.  [Postmark](https://www.postmarkapp.com), [Mandrill](https://www.mandrillapp.com), [MailGun](https://www.mailgun.com) and [SendGrid](https://www.sendgrid.com) (among others) are companies who can provide this service.  The `MAIL_URL` contains all of the information for connecting to the SMTP server and, like a URL, should look like `smtp://user:pass@yourservice.com:587` or `smtps://user:pass@yourservice.com:465`.

The `smtp://` form is for mail servers which support encryption via `STARTTLS` or those that do not use encryption at all and is most common for servers on port 587 and _sometimes_ port 25.  On the other hand, the `smtps://` form (the `s` stands for "secure") should be used if the server only supports TLS/SSL (and does not support connection upgrade with `STARTTLS`) and is most common for servers on port 465.

## METEOR_DISABLE_OPTIMISTIC_CACHING
(_production_)

When running `meteor build` or `meteor deploy` you can set `METEOR_DISABLE_OPTIMISTIC_CACHING=1` to speed up your build time.

Since optimistic in-memory caching is one of the more memory-intensive parts of the build system, setting the environment variable `METEOR_DISABLE_OPTIMISTIC_CACHING=1` can help improve memory usage during meteor build, which seems to improve the total build times. This configuration is perfectly safe because the whole point of optimistic caching is to keep track of previous results for future rebuilds, but in the case of meteor `build` or `deploy` there's only ever one initial build, so the extra bookkeeping is unnecessary.

## METEOR_PROFILE
(_development_)

In development, you may need to diagnose what has made builds start taking a long time. To get the callstack and times during builds, you can run `METEOR_PROFILE=1 meteor`.

## METEOR_PACKAGE_DIRS
(_development, production_)

Colon-delimited list of local package directories to look in, outside your normal application structure, for example: `METEOR_PACKAGE_DIRS="/usr/local/my_packages/"`. Note that this used to be `PACKAGE_DIRS` but was changed in Meteor 1.4.2.

## METEOR_SETTINGS
(_production_)

When running your bundled application in production mode, pass a string of JSON containing your settings with `METEOR_SETTINGS='{ "server_only_setting": "foo", "public": { "client_and_server_setting": "bar" } }'`.

> In development, this is accomplished with `meteor --settings [file.json]` in order to provide full-reactivity when changing settings.  Those settings are simply passed as a string here. Please see the [Meteor.settings](../api/meteor#Meteor-settings) documentation for further information.

## METEOR_SQLITE_JOURNAL_MODE
(_development_)

The Meteor package catalog uses the `WAL` [SQLite Journal Mode](https://www.sqlite.org/pragma.html#pragma_journal_mode) by default.  The Journal mode for the package catalog can be modifed by setting `METEOR_SQLITE_JOURNAL_MODE`.

When running multiple concurrent meteor servers on [Windows Subsystem for Linux (WSL)](https://docs.microsoft.com/en-us/windows/wsl/) some meteor developers have seen issues with the package catalog.  Setting the environment variable `METEOR_SQLITE_JOURNAL_MODE=TRUNCATE` can overcome the issue.

## MONGO_OPLOG_URL
(_development, production_)

MongoDB server oplog URL. If you're using a replica set (which you should), construct this url like so: `MONGO_OPLOG_URL="mongodb://user:password@myserver.com:10139/local?replicaSet=(your replica set)&authSource=(your auth source)"`

## MONGO_URL
(_development, production_)

MongoDB server URL. Give a fully qualified URL (or comma-separated list of URLs) like `MONGO_URL="mongodb://user:password@myserver.com:10139"`. For more information see the [MongoDB docs](https://docs.mongodb.com/manual/reference/connection-string/).

## PORT
(_production_)

Which port the app should listen on, for example: `PORT=3030`

See also: [`BIND_IP`](#bind-ip).

> In development, this can be accomplished with `meteor run --port <port>`.

## ROOT_URL
(_development, production_)

Used to generate URLs to your application by, among others, the accounts package. Provide a full URL to your application like this: `ROOT_URL="https://www.myapp.com"`.

## TOOL_NODE_FLAGS
(_development, production_)

Used to pass flags/variables to Node inside Meteor build. For example you can use this to pass a link to icu data: `TOOL_NODE_FLAGS="--icu-data-dir=node_modules/full-icu"`
For full list of available flags see the [Node documentation](https://nodejs.org/dist/latest-v12.x/docs/api/cli.html).

## UNIX_SOCKET_GROUP
(_production_)

This overrides the default UNIX group of the socket file configured in `UNIX_SOCKET_PATH`. It can be set to a group name or a numerical gid.

## UNIX_SOCKET_PATH
(_production_)

Configure Meteor's HTTP server to listen on a UNIX socket file path (e.g. `UNIX_SOCKET_PATH=/tmp/meteor.sock`) instead of a TCP port. This is useful when running a local reverse proxy server like Nginx to handle client HTTP requests and direct them to your Meteor application. Leveraging UNIX domain sockets for local communication on the same host avoids the Operating System overhead required by TCP based communication and can also improve security. This UNIX socket file is created when Meteor starts and removed when Meteor exits.

## UNIX_SOCKET_PERMISSIONS
(_production_)

This overrides the default UNIX file permissions on the UNIX socket file configured in `UNIX_SOCKET_PATH`. For example, `UNIX_SOCKET_PERMISSIONS=660` would set read/write permissions for both the user and group.


---

---
url: /troubleshooting/expired-certificate.md
---

# Expired Certificates
Troubleshooting Expired Certificates Issues



Let's Encrypt Root Certificate expired on September 30th and this change is causing some issues. We explain the possible problems below and also how to solve them.

This is not an issue with Meteor or Galaxy, but a natural process if you are using Let's Encrypt's generated certificates.


## Can't run Meteor commands {#commands}

Galaxy and all Meteor servers uses Let's Encrypt, which announced a change in May in this [post](https://letsencrypt.org/docs/dst-root-ca-x3-expiration-september-2021) about DST Root CA X3 expiring on September 30, 2021.

Older versions of Meteor, more specifically anything older than Meteor v1.9 shipped with a Node.JS version below v10, which used OpenSSL < 1.0.2.


![](/openssl-suport-table.png)


If you are getting errors like Connection error (certificate has expired) when running Meteor commands it means that you are running a version of Meteor older than v1.9.

A workaround, for now, is to run all the meteor commands with the following environment variable ***NODE_TLS_REJECT_UNAUTHORIZED***, for example in the deploy command:

```bash
NODE_TLS_REJECT_UNAUTHORIZED=0 meteor deploy
```

Also note that if you are running old distributions, like Ubuntu 16 and before, locally, or in any of your CI pipelines you may also face this issue. In this case, we do recommend updating your distribution, or your local repository of root certificates (the how-to of this varies based on your distribution).

This is not a Meteor or Galaxy issue, but it's a change in the Let's Encrypt certificate in our resources that you are accessing.


## Requests failing {#server-requests}

If your server is accessing external resources where the target host is using Let's Encrypt certificates and your app is running an old Meteor version, you will also need to add `NODE_TLS_REJECT_UNAUTHORIZED` to your server environment variables.

If you are using Galaxy, it's as simple as adding this to your settings file:

```json
{
  "galaxy.meteor.com": {
    "env": {
      "NODE_TLS_REJECT_UNAUTHORIZED": "0"
    }
  }
}
```

***Please note:*** We don't recommend continued use of this workaround, as any SSL certificate is going to be authorized and you are exposing your application to serious security issues. The best option is to update Meteor to latest version, or at least Meteor 1.9 as it is the first using Node.js 12.

You can check our list of supported Meteor versions [here](https://github.com/meteor/meteor/blob/devel/SECURITY.md#supported-versions). If your applications is not in one of them, you should migrate as soon as possible.

This is not a Meteor or Galaxy issue, but it's a change in the Let's Encrypt certificate in the external resource that you are accessing.


## Client Compatibility {#client-compatibility}

As stated before, Galaxy issues Let's Encrypt certificates automatically for all clients. This is source of confusion, as if you are depending on older clients being able to access your website, this won't work.

If Let's encrypt certificates are not good for your clients you would need to acquire other certificate from a different provider and upload your custom certificate into Galaxy.

You can also generate a Let's Encrypt certificate manually and upload to Galaxy, but specifying an alternative preferred chain on certbot:

```
sudo certbot certonly --manual --preferred-chain "ISRG Root X1" --preferred-challenges dns
```

More info can be obtained [here](https://letsencrypt.org/certificates).

If you are using Galaxy, you need to follow the requirements and steps [here](https://galaxy-support.meteor.com/en/article/encryption-pt8wbl/) after generating the certificate. Galaxy only accepts custom certs in `.pem` format, the same as nginx uses.

This is not a Meteor or Galaxy issue, but it's a change in the Let's Encrypt certificate you are using.


## Clients Known to be not working {#clients-not-working}

Here is a succinct list of known to be not working clients:

- Mac OS X prior to 10.12.1. Any browser, except firefox that bundles root chains, won't work.
- Node.JS HTTP requests prior to v10. This includes any Meteor version prior to 1.9(except).
- Any client using OpenSSL 1.0.2 and before.

Please note that this is not an exhaustive list, but based on our reports and experience.

This is not a Meteor or Galaxy issue, but it's a change in the Let's Encrypt certificate you are using.

---

---
url: /packages/fetch.md
---
# Fetch

Isomorphic modern/legacy/Node polyfill for WHATWG fetch().

This package replaces the `http` package for HTTP calls. `fetch` package provides polyfill for the [WHATWG fetch specification](https://fetch.spec.whatwg.org/) for legacy browsers or defaults to the global class which is available in modern browsers and Node. It is recommended that you use this package for compatibility with non-modern browsers.

For more information we recommend [reading the MDN articles](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) about it as this article covers only basic usage in Meteor.

## Usage

### Installation

To add this package to an existing app, run the following command from
your app directory:

```bash
meteor add fetch
```

To add the `fetch` package to an existing package, include the
statement `api.use('fetch');` in the `Package.onUse` callback in your
`package.js` file:

```js
Package.onUse((api) => {
  api.use("fetch");
});
```

## API

You can import `fetch`, `Headers`, `Request` and `Response` classes from `meteor/fetch`.

```js
import { fetch, Headers, Request, Response } from "meteor/fetch";
```

For the most part though, you will only need to import `fetch` and `Headers`.

```js
import { fetch, Headers } from 'meteor/fetch';

async function postData (url, data) {
    try {
      const response = await fetch(url, {
          method: 'POST', // *GET, POST, PUT, DELETE, etc.
          mode: 'cors', // no-cors, *cors, same-origin
          cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
          credentials: 'same-origin', // include, *same-origin, omit
          headers: new Headers({
              Authorization: 'Bearer my-secret-key',
              'Content-Type': 'application/json'
          }),
          redirect: 'follow', // manual, *follow, error
          referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
          body: JSON.stringify(data) // body data type must match "Content-Type" header
      });
      const data = await response.json();
      return response(null, data);
    } catch (err) {
      return response(err, null);
    }
}

const result = await postData('https://www.example.org/statsSubmission', { totalUsers: 55 });

```

---

---
url: /packages/hot-module-replacement.md
---
# Hot Module Replacement

Hot Module Replacement (HMR) is a method of updating javascript modules within a running application. This reduces the feedback cycle while developing, so you can view and test changes quicker. In Meteor's implementation, the app can be updated before the build has even finished.

::: tip
`hot-module-replacement` package was introduced in Meteor 2.0
:::

To enable HMR for an app, it should use the `hot-module-replacement` package. HMR is currently not supported for packages, but packages can depend on the `hot-module-replacement` package to ensure access to the hot API. When a change can not be accepted with HMR, Meteor uses hot code push to update the app, as is normally done when HMR is not used.

HMR currently supports the modern web architecture. It is always disabled in other architectures and in production.

### How the app is updated

While rebuilding a supported architecture, Meteor checks which files were modified, and sends the modified files to the client. The client then uses this process:

1. It checks if the modified module accepts or declines updates. If the module does neither, Meteor looks at the modules that imported it to see if they accept or decline the update, and then the modules that import those, and so on. If all paths it followed leads to modules that accept the update, it uses HMR. Otherwise, it uses hot code push.
2. Many js modules do things that have a long term effect on the app. They might create Tracker autoruns, register event listeners, or have UI components that have been rendered. Modules can register dispose handlers to clean up the old version of a module so it no longer affects the app. At this point in the update process, those dispose handlers are called.
3. Meteor runs the new version of the module, the modules that accepted the update, and all of the modules between them. This ensures the module's new exports are used. Because of this, usually the only modules that accept updates are the ones that have no exports or that have another way of updating the exports used by parent modules. At this point, there are two versions of these modules running, but the old version is no longer in use if it was disposed properly.

For HMR to work properly, the correct modules have to accept or decline updates, and dispose handlers have to be written. Fortunately, most apps do not need to manually do either. Instead, you can use integrations that automatically detect modules that can accept updates, and how to clean up specific types of modules. For example, the React integration is enabled by default in Meteor apps, and is able to automatically update React components.

### API

The hot-module-replacement package provides an API to control how HMR is used. The API is available at `module.hot`. Since the API isn't always available (for example, in production or in architectures not supported by HMR), the code should make sure `module.hot` is defined before using it:

```js
if (module.hot) {
  module.hot.accept();
}
```

In a future Meteor version, using the if statement will allow minifiers to remove this block when minifying for production.

Packages that use the `module.hot` api should use the `hot-module-reload` package to ensure access to the API.

<ApiBox name="module.hot#accept" hasCustomExample instanceName="module.hot"/>

HMR reruns files that import the modified modules so the files use the new exports. In addition to configuring which modules can be updated with HMR, `module.hot.accept()` also controls how many files are re-ran. Meteor re-runs the files that import the modified modules, the files that import those files, and so on, until it reaches the modules that accepted the update. Because of this, usually the only modules that accept updates are ones that have no exports, are have another way of updating the exports used by its parent modules.

<ApiBox name="module.hot#decline" hasCustomExample instanceName="module.hot"/>

<ApiBox name="module.hot#dispose" hasCustomExample instanceName="module.hot"/>

The call back is run when this instance of the module will no longer be used. The main use is making sure the instance of the module no longer affects the app. Here is an example where we stop a Tracker computation:

```js
import { setLocale } from '/imports/utils/locale';

const computation = Tracker.autorun(() => {
  const user = Meteor.user();

  if (user && user.locale) {
    setLocale(user.locale);
  }
});

if (module.hot) {
  module.hot.dispose(() => {
    computation.stop();
  });
}
```

If it did not stop the computation, each time the module is reran for HMR, there would be an additional computation. This can lead to unexpected behavior, especially if we've modified the computation function.

The callback receives a data object that can be mutated to store information for the new instance of the module. This can be used to preserve class instances, state, or other data. For example, this module will preserve the value of the color variable:

```js

let color = 'blue';

export function getColor() {
  return color;
}

export function changeColor(newColor) {
  color = newColor;
}

if (module.hot) {
  if (module.hot.data) {
    color = module.hot.data.color;
  }

  module.hot.dispose(data => {
    data.color = color;
  });
}
```

When the module first runs, `module.hot.data` is null, so it leaves `color` set to blue. Eventually the app calls `changeColor` and sets the color to `purple`. If the module is re-ran, the old instance of the module stores the color in `data.color`. The new instance retrieves it from `module.hot.data.color`, and registers a new dispose handler for the next time it is re-run.

<ApiBox name="module.hot#data" hasCustomExample instanceName="module.hot"/>

<ApiBox name="module.hot#onRequire" hasCustomExample instanceName="module.hot"/>

This is used by some HMR integrations to detect files that can be automatically updated with HMR, and handle cleaning up the old module instances and migrating state.
For example, React Fast Refresh uses this to find the modules that only export React components, and have those modules accept updates.

```js
if (module.hot) {
  module.hot.onRequire({
    // requiredModule is the same object available in the
    // required module as `module`, including access to `module.hot`
    // and `module.exports`
    //
    // parentId is a string with the path of the module that
    // imported requiredModule.
    before(requiredModule, parentId) {
      // Anything returned here is available to the
      // after callback as the data parameter.
      return {
        importedBy: parentId,
        previouslyEvaluated: !requiredModule.loaded
      }
    },
    after(requiredModule, data) {
      if (!data.previouslyEvaluated) {
        console.log(`Finished evaluating ${requiredModule.id}`);
        console.log(`It was imported by ${data.importedBy}`);
        console.log(`Its exports are ${requiredModule.exports}`);
      }

      // canAcceptUpdates would look at the exports, and maybe the imports
      // to check if this module can safely be updated with HMR.
      if (requiredModule.hot && canAcceptUpdates(requiredModule)) {
        requiredModule.hot.accept();
      }
    }
  });
}
```

---

---
url: /about/install.md
---
# Install

You need to install the Meteor command line tool to create, run, and manage your Meteor.js projects. Check the prerequisites and follow the installation process below.

```bash
npx meteor
```

To create your meteor project you can run:

```bash
meteor create
```

And it will prompt you to choose a project name and frontend framework.

## Prerequisites {#prereqs}

### Operating System (OS) {#prereqs-os}

- Meteor currently supports **OS X, Windows, and Linux**. Only 64-bit is supported.
- Meteor supports Windows 7 / Windows Server 2008 R2 and up.
- Apple M1 is natively supported from Meteor 2.5.1 onward (for older versions, rosetta terminal is required).
- If you are using Meteor <= 3.0.4 and you are on a Mac M1 (Arm64 version) you need to have Rosetta 2 installed, as Meteor uses it for running MongoDB. Check how to install it [here](https://osxdaily.com/2020/12/04/how-install-rosetta-2-apple-silicon-mac/). *No longer needed in Meteor 3.1*.
- Disabling antivirus (Windows Defender, etc.) will improve performance.
- For compatibility, Linux binaries are built with CentOS 6.4 i386/amd64.

### Mobile Development {#prereqs-mobile}

- iOS development requires the latest Xcode.

## Installation

Install the latest official version of Meteor.js from your terminal by running one of the commands below. You can check our [changelog](https://v3-docs.meteor.com/history.html) for the release notes.

For Windows, Linux and OS X, you can run the following command:

```bash
npx meteor
```

::: tip

If you get an error with the installation `npx` you can try running `npx clear-npx-cache`

or `rm -rf ~/.npm/_npx`

if the error persists, please try to install Meteor using `npm`:

```bash
npm install -g meteor --foreground-script
```

Make sure you have Node.js v20 or higher installed.

:::

An alternative for Linux and OS X, is to install Meteor by using curl:

```bash
curl https://install.meteor.com/ | sh
```

You can also install a specific Meteor.js version by using curl:

```bash
curl https://install.meteor.com/\?release\=2.8 | sh
```

> Do not install the npm Meteor Tool in your project's package.json. This library is just an installer.

## Troubleshooting {#troubleshooting}

If your user doesn't have permission to install global binaries, and you need to use sudo, it's necessary to append _--unsafe-perm_ to the above command:

```bash
sudo npm install -g meteor --unsafe-perm
```

We strongly discourage the usage of Node.js or Meteor with root permissions.
Only run the above command with sudo if you know what you are doing.

If you only use sudo because of a distribution default permission system, [check this link for fixing it](https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally).

In some cases you can get this error `npm WARN checkPermissions Missing write access to /usr/local/lib/node_modules` because your Node.js installation was performed with wrong permissions. An easy way to fix this is to install Node.js using [nvm](https://github.com/nvm-sh/nvm) and forcing it to be used in your terminal. You can force it in the current session of your terminal by running `nvm use 14`.

## PATH management {#path-management}

By default, the Meteor installer adds its install path (by default, `~/.meteor/`) to your PATH by updating either your `.bashrc`, `.bash_profile`, or `.zshrc` as appropriate. To disable this behavior, install Meteor by running:

```bash
npm install -g meteor --ignore-meteor-setup-exec-path --foreground-script
```

(or by setting the environment variable `npm_config_ignore_meteor_setup_exec_path=true`)

## Old Versions on Apple M1 {#old-versions-m1}

For Apple M1 computers, you can append Rosetta prefix as following, if you need to run older versions of Meteor (before 2.5.1):

```bash
arch -x86_64 npm install -g meteor
```

or select Terminal in the Applications folder, press CMD(⌘)+I and check the "Open using Rosetta" option.

## Meteor Docker image {#meteor-docker}

You can also use a Docker container for running Meteor inside your CI, or even in your local development toolchain.

We do provide the meteor/meteor-base ubuntu-based Docker image, that comes pre-bundled with Node.JS and Meteor, and runs it as a local user (not as root).

You can refer to our meteor/galaxy-images repository to see how to use it, and the latest version. [More about meteor-base here.](https://github.com/meteor/galaxy-images/blob/master/meteor-base/README.md)

## Note for Windows users {#windows}

On Windows, the installer runs faster when [Windows Developer Mode](https://docs.microsoft.com/en-us/windows/apps/get-started/enable-your-device-for-development) is enabled. The installation extracts a large number of small files, which Windows Defender can cause to be very slow.

## Node version manager {#nvm}

If you use a node version manager that uses a separate global `node_modules` folder for each Node version, you will need to re-install the `meteor` npm package when changing to a Node version for the first time. Otherwise, the `meteor` command will no longer be found.

## Note for fish shell users (Linux) {#fish-shell}

To be able to use the `meteor` command from fish it's needed to include `/home/<user>/.meteor` in `$PATH`; to do that just add this line in `/home/<user>/.config/fish/config.fish` file (replace `<user>` with your username):

`set PATH /home/<user>/.meteor $PATH`

## Using AI with Meteor docs {#ai-docs}

Meteor docs ships with [llms.txt](https://llmstxt.org/) file, which helps language models use your website

If you have [LM Studio installed](https://lmstudio.ai/docs/app) or any other LLM tool, you can use the llms.txt file to ask questions about Meteor.

```bash
curl https://docs.meteor.com/llms-full.txt  -o meteor-docs.txt
```

Then, you can use the file with your LLM tool of choice. For example, if you have LM Studio installed, you can use their [chat with documents feature](https://lmstudio.ai/docs/app/basics/rag)
to ask questions about Meteor.

## Uninstalling Meteor {#uninstall}

If you installed Meteor using npx, you can remove it by running:

```bash
npx meteor uninstall
```

If you installed Meteor using curl or as a fallback solution, run:

```bash
rm -rf ~/.meteor
sudo rm /usr/local/bin/meteor
```

---

---
url: /about/what-is.md
---
# Introduction {#introduction}

:::info You are reading the Meteor 3 documentation!

- Searching for the Meteor 2 documentation? Access the [Meteor 2 Docs](https://v2-docs.meteor.com/).
- Upgrading from Meteor 2? Check out the [Migration Guide](https://v3-migration-docs.meteor.com/).

:::

Meteor is a full-stack JavaScript platform for developing modern web and mobile applications. Meteor includes a key set of technologies for building connected-client reactive applications, a build tool, and a curated set of packages from the Node.js and general JavaScript community.

- Meteor allows you to develop in **one language**, JavaScript or TypeScript, in all environments: application server, web browser, and mobile device.

- Meteor uses **data on the wire**, meaning the server sends data, not HTML, and the client renders it.

- Meteor **embraces the ecosystem**, bringing the best parts of the extremely active JavaScript community to you in a careful and considered way.

- Meteor provides **full stack reactivity**, allowing your UI to seamlessly reflect the true state of the world with minimal development effort.

- Meteor offers **flexibility in front-end** development, allowing you to choose your preferred framework such as React, Vue, Blaze, Svelte, or Solid.

- Meteor **simplifies back-end and front-end integration** through Methods, its built-in Remote Procedure Call (RPC) system for seamless communication.

- Meteor includes a **ready-to-use Login and Accounts** package, eliminating the need to rebuild authentication systems for your applications.

## Meteor Resources {#learning-more}

### Learning Meteor

- Start by learning how to install Meteor in the [Installation Section](/about/install.html).

- The tutorials are the perfect place to start. Build a simple app to manage a task list! Available for [React](/tutorials/react/index.html), and [Vue 3](/tutorials/vue/meteorjs3-vue3-vue-meteor-tracker.html). Blaze and Svelte tutorials are coming soon.

- Participate in Meteor's fully professional, engaging and interactive online school. Join [Meteor University](https://university.meteor.com/). Our courses cover Meteor 2 but most of the content is still relevant.

- Subscribe to our official [Youtube channel](https://www.youtube.com/@meteorsoftware) and watch the latest MeteorJS videos and presentations.

### Developer Resources

- Explore and contribute to our [GitHub repository](https://github.com/meteor). You can access our code, request new features, and start contributing.

- Use the [Chrome Extension](https://chrome.google.com/webstore/detail/meteor-devtools-evolved/ibniinmoafhgbifjojidlagmggecmpgf) or [Firefox Extension](https://addons.mozilla.org/en-US/firefox/addon/meteor-devtools-evolved/) for insights into your app's performance and to understand what is going on under the hood of your application.

- Discover [Meteor Examples](https://github.com/meteor/examples) to see a range of projects built with Meteor.

- Visit [Atmosphere](https://atmospherejs.com), the dedicated repository for Meteor community packages.

### Join Our Community

- Participate in the [Official Forum](https://forums.meteor.com) for project news, support, and community discussions.

- Join the discussion and live streams on the official [Meteor Lounge Discord](https://discord.gg/hZkTCaVjmT).

- Engage with peers in the [Meteor Slack Community](https://join.slack.com/t/meteor-community/shared_invite/enQtODA0NTU2Nzk5MTA3LWY5NGMxMWRjZDgzYWMyMTEyYTQ3MTcwZmU2YjM5MTY3MjJkZjQ0NWRjOGZlYmIxZjFlYTA5Mjg4OTk3ODRiOTc).

---

---
url: /community-packages/jam-method.md
---
# Jam Method

- `Who maintains the package` – [Jam](https://github.com/jamauro)

[[toc]]

## What is this package?

Method is an easy way to create Meteor methods with Optimistic UI. It's built with Meteor 3 in mind and is compatible with Meteor 2 to make migration easy. It's meant to be a drop in replacement for Validated Method and comes with additional features:

* Before and after hooks
* Global before and after hooks for all methods
* Pipe a series of functions
* Authed by default (can be overriden)
* Easily configure a rate limit
* Optionally run a method on the server only
* Attach the methods to Collections (optional)
* Validate with one of the supported schema packages or a custom validate function
* No need to use .call to invoke the method as with Validated Method

## How to download it?

Add the package to your app by running the following in your Meteor project:

```bash
meteor add jam:method
```
### Sources

* [GitHub repository](https://github.com/jamauro/method)

## How to use it?

### Create a method
`name` is required and will be how Meteor's internals identifies it.

`schema` will automatically validate using a [supported schema](#supported-schemas).

`run` will be executed when the method is called.

```js
import { createMethod } from 'meteor/jam:method'; // can import { Methods } from 'meteor/jam:method' instead and use Methods.create if you prefer

export const create = createMethod({
  name: 'todos.create',
  schema: Todos.schema, // using jam:easy-schema in this example
  async run({ text }) {
    const todo = {
      text,
      done: false,
      createdAt: new Date(),
      authorId: Meteor.userId(), // can also use this.userId instead of Meteor.userId()
    }
    const todoId = await Todos.insertAsync(todo);
    return todoId;
  }
});
```

#### Supported schemas
Currently, these schemas are supported:
* [jam:easy-schema](https://github.com/jamauro/easy-schema)
* [check](https://docs.meteor.com/api/check.html)
* [zod](https://github.com/colinhacks/zod)
* [simpl-schema](https://github.com/longshotlabs/simpl-schema)

If you're using `jam:easy-schema`, be sure to check out [Using with jam:easy-schema](#using-with-jameasy-schema) below for details on a way to write methods with less boilerplate.

Here's a quick example of each one's syntax. They vary in features so pick the one that best fits your needs.
```js
// jam:easy-schema. you'll attach to a Collection so you can reference one {Collection}.schema in your methods
const schema = {text: String, isPrivate: Optional(Boolean)}
// check
const schema = {text: String, isPrivate: Match.Maybe(Boolean)}
// zod
const schema = z.object({text: z.string(), isPrivate: z.boolean().optional()})
// simpl-schema
const schema = new SimpleSchema({text: String, isPrivate: {type: Boolean, optional: true}})
```

#### Custom validate function
If you're not using one of the supported schemas, you can use `validate` to pass in a custom validation function.
**`Note`**: `validate` can be an async function if needed.

```js
// import your schema from somewhere
// import your validator function from somewhere

export const create = createMethod({
  name: 'todos.create',
  validate(args) {
    validator(args, schema)
  },
  async run({ text }) {
    const todo = {
      text,
      done: false,
      createdAt: new Date(),
      authorId: Meteor.userId() // can also use this.userId instead of Meteor.userId()
    }
    const todoId = await Todos.insertAsync(todo);
    return todoId;
  }
});
```

### Import on the client and use
```js
import { create } from '/imports/api/todos/methods';

async function submit() {
  try {
    await create({text: 'book flight to Hawaii'})
  } catch(error) {
    alert(error)
  }
}
```

### Before and after hooks
You can execute functions `before` and / or `after` the method's `run` function. `before` and `after` accept a single function or an array of functions.

When using `before`, the original input passed into the method will be available. The original input will be returned automatically from a `before` function so that `run` receives what was originally passed into the method.

A great use case for using `before` is to verify the user has permission. For example:

```js
async function checkOwnership({ _id }) { // the original input passed into the method is available here. destructuring for _id since that's all we need for this function
  const todo = await Todos.findOneAsync(_id);
  if (todo.authorId !== Meteor.userId()) {
    throw new Meteor.Error('not-authorized')
  }

  return true; // any code executed as a before function will automatically return the original input passed into the method so that they are available in the run function
}

export const markDone = createMethod({
  name: 'todos.markDone',
  schema: Todos.schema,
  before: checkOwnership,
  async run({ _id, done }) {
    return await Todos.updateAsync(_id, {$set: {done}});
  }
});
```

When using `after`, the result of the `run` function will be available as the first argument and the second argument will contain the original input that was passed into the method. The result of the `run` function will be automatically returned from an `after` function.

```js
function exampleAfter(result, context) {
  const { originalInput } = context; // the name of the method is also available here
  // do stuff

  return 'success'; // any code executed as an after function will automatically return the result of the run function
}

export const markDone = createMethod({
  name: 'todos.markDone',
  schema: Todos.schema,
  before: checkOwnership,
  async run({ _id, done }) {
    return await Todos.updateAsync(_id, {$set: {done}});
  },
  after: exampleAfter
});
```

**`Note`**: If you use arrow functions for `before`, `run`, or `after`, you'll lose access to `this` – the methodInvocation. You may be willing to sacrifice that because `this.userId` can be replaced by `Meteor.userId()` and `this.isSimulation` can be replaced by `Meteor.isClient` but it's worth noting.


### Pipe a series of functions
Instead of using `run`, you can compose functions using `.pipe`. Each function's output will be available as an input for the next function.

```js
// you'd define the functions in the pipe and then place them in the order you'd like them to execute within .pipe
// be sure that each function in the pipe returns what the next one expects, otherwise you can add an arrow function to the pipe to massage the data, e.g. (input) => manipulate(input)

export const create = createMethod({
  name: 'todos.create',
  schema: Todos.schema
}).pipe(
  checkOwnership,
  createTodo,
  sendNotification
)
```

### Attach methods to its Collection (optional)
Instead of importing each method, you can attach them to the Collection. If you're using [jam:easy-schema](https://github.com/jamauro/easy-schema) be sure to attach the schema before attaching the methods.

```js
// /imports/api/todos/collection
import { Mongo } from 'meteor/mongo';
import { schema } from './schema';

export const Todos = new Mongo.Collection('todos');

Todos.attachSchema(schema); // if you're using jam:easy-schema

const attach = async () => {
  const methods = await import('./methods.js') // dynamic import is recommended
  return Todos.attachMethods(methods); // if you prefer not to use dynamic import, you can simply call attachMethods synchronously
};

attach().catch(error => console.error('Error attaching methods', error))
```
`attachMethods` accepts the method `options` as an optional second parameter. See [Configuring](#configuring-optional) for a list of the `options`.

With the methods attached you'll use them like this on the client:
```js
import { Todos } from '/imports/api/todos/collection';
// no need to import each method individually

async function submit() {
  try {
    await Todos.create({text: 'book flight to Hawaii'})
  } catch(error) {
    alert(error)
  }
}
```

### Executing code on the server only
By default, methods are optimistic meaning they will execute on the client and then on the server. If there's only part of the method that should execute on the server and not on the client, then simply wrap that piece of code in a `if (Meteor.isServer)` block. This way you can still maintain the benefits of Optimistic UI. For example:

```js
export const create = createMethod({
  name: 'todos.create',
  schema: Todos.schema,
  async run(args) {
    // rest of your function
    // code running on both client and server
    if (Meteor.isServer) {
      // code running on the server only
      import { secretCode } from '/server/secretCode'; // since it's in a /server folder the code will not be shipped to the client
      // do something with secretCode
    }

    // code running on both client and server
    return Todos.insertAsync(todo)
  }
});
```

If you prefer, you can force the entire method to execute on the server only by setting `serverOnly: true`. It can be used with `run` or `.pipe`. Here's an example with `run`:

```js
export const create = createMethod({
  name: 'todos.create',
  schema: Todos.schema,
  serverOnly: true,
  async run(args) {
    // all code here will execute only on the server
  }
});
```

You can also set all methods to be `serverOnly`. See [Configuring](#configuring-optional) below.

#### Security note
**`Important`**: Since Meteor does not currently support tree shaking, the contents of the code inside `run` function or `.pipe` could still be visible to the client even if you use `if (Meteor.isServer)` or `serverOnly: true`. To prevent this, you have these options:

1. Attach methods to its Collection with a dynamic import as shown above [Attach methods to its Collection (optional)](#attach-methods-to-its-collection-optional)

2. Import function(s) from a file within a `/server` folder. Any code imported from a `/server` folder will not be shipped to the client. The `/server` folder can be located anywhere within your project's file structure and you can have multiple `/server` folders. For example, you can co-locate with your collection folder, e.g. `/imports/api/todos/server/`, or it can be at the root of your project. See [Secret server code](https://guide.meteor.com/security.html#secret-code) for more info.

```js
export const create = createMethod({
  name: 'todos.create',
  schema: Todos.schema,
  serverOnly: true,
  async run(args) {
    import { serverFunction } from '/server/serverFunction';

    serverFunction(args);
  }
});
```

3. Dynamically import function(s). These do not have to be inside a `/server` folder. This will prevent the code being inspectable via the browser console.

```js
export const create = createMethod({
  name: 'todos.create',
  schema: Todos.schema,
  serverOnly: true,
  async run(args) {
    const { serviceFunction } = await import('./services');

    serviceFunction(args);
  }
});
```

### Changing authentication rules
By default, all methods will be protected by authentication, meaning they will throw an error if there is *not* a logged-in user. You can change this for an individual method by setting `open: true`. See [Configuring](#configuring-optional) below to change it for all methods.

```js
export const create = createMethod({
  name: 'todos.create',
  schema: Todos.schema,
  open: true,
  async run({ text }) {
    // ... //
  }
});
```

### Rate limiting
Easily rate limit a method by setting its max number of requests – the `limit` – within a given time period (milliseconds) – the `interval`.

```js
export const create = createMethod({
  name: 'todos.create',
  schema: Todos.schema,
  rateLimit: { // rate limit to a max of 5 requests every second
    limit: 5,
    interval: 1000
  },
  async run({ text }) {
    // ... //
  }
});
```

### Validate without executing the method
There may be occassions where you want to validate without executing the method. In these cases, you can use `.validate`. If you want to validate against only part of the schema, use `.validate.only`.

```js
export const create = createMethod({
  name: 'todos.create',
  schema: Todos.schema,
  async run({ text }) {
    // ... //
  }
});

// validate against the schema without executing the method
create.validate({...})

// validate against only the relevant part of the schema based on the data passed in without executing the method
create.validate.only({...})
```

If you're using a custom validate function instead of one of the supported schemas and you'd like to use `.validate.only`, you can simply append an `only` function onto the `validate` function that you supply.

### Options for Meteor.applyAsync
When called, the method uses [Meteor.applyAsync](https://docs.meteor.com/api/methods#Meteor-applyAsync) under the hood to execute your `run` function or `.pipe` function(s). `Meteor.applyAsync` takes a few options which can be used to alter the way Meteor handles the method. If you want to change the defaults or include other supported options, pass in `options` when creating the method.

```js
export const create = createMethod({
  name: 'todos.create',
  schema: Todos.schema,
  options: {
    // ... //
  },
  async run({ text }) {
    // ... //
  }
});
```

By default, this package uses the following `options`:
```js
{
  // Make it possible to get the ID of an inserted item
  returnStubValue: true,

  // Don't call the server method if the client stub throws an error, so that we don't end
  // up doing validations twice
  throwStubExceptions: true,
};
```
See [Configuring](#configuring-optional) below to set `options` for all methods.

### Working with the stub result (Meteor 3.0+)
In Meteor 3.0+, you can optionally take action with the stub result, i.e. the result when the method simulation is run on the client, before the server has returned with the final result or error. This can come in handy when you want to make your app feel instant for the user and you're relatively sure the action will succeed, e.g. when inserting new documents into the database.

```js
  const { stubPromise, serverPromise } = create();
  const _id = await stubPromise.catch(error => {
    // optionally handle a stub error
  });

  // take action with the _id stub result, for example, route to a new page
  router.go(`/detail/${_id}`)

  await serverPromise.catch(error => {
    // handle server error, rollback changes as needed, for example route to home
    router.go('/')
    alert('sorry, could not create')
  });
```

### Mocking the method context
You can mock the method invocation context, aka the `this` value inside the method, by invoking the method with `.call(context, args)`. This is particularly useful for unit testing to mock the `this.userId`:

```js
const context = {
  userId: 'fakeUserId',
  // ... //
}

await create.call(context, {...})
```

## Configuring (optional)
If you like the defaults, then you won't need to configure anything. But there is some flexibility in how you use this package.

Here are the global defaults:
```js
const config = {
  before: [], // global before function(s) that will run before all methods
  after: [], // global after function(s) that will run after all methods
  serverOnly: false, // globally make all methods serverOnly, aka disable Optimistic UI, by setting to true
  open: false, // by default all methods will be protected by authentication, override it for all methods by setting this to true
  loggedOutError: new Meteor.Error('logged-out', 'You must be logged in'), // customize the logged out error
  options: {
    returnStubValue: true, // make it possible to get the ID of an inserted item on the client before the server finishes
    throwStubExceptions: true,  // don't call the server method if the client stub throws an error, so that we don't end up doing validations twice
  }
};
````

To change the global defaults, use:
```js
// put this in a file that's imported on both the client and server
import { Methods } from 'meteor/jam:method';

Methods.configure({
  // ... change the defaults here ... //
});
```

### Global before and after hooks
You can create before and/or after functions to run before / after all methods. Both `before` and `after` accept a single function or an array of functions.

```js
import { Methods } from 'meteor/jam:method';

const hello = () => { console.log('hello') }
const there = () => { console.log('there') }
const world = () => { console.log('world') }

Methods.configure({
  before: [hello, there],
  after: world
});
```

### Helpful utility function to log your methods
Here's a helpful utility function - `log` - that you might consider adding. It isn't included in this package but you can copy and paste it into your codebase where you see fit.

```js
// log will simply console.log or console.error when the Method finishes
function log(input, pipeline) {
  pipeline.onResult((result) => {
    console.log(`Method ${pipeline.name} finished`, input);
    console.log('Result', result);
  });

  pipeline.onError((err) => {
    console.error(`Method ${pipeline.name} failed`);
    console.error('Error', err);
  });
};
```

Then you could use it like this:
```js
import { Methods, server } from 'meteor/jam:method';

Methods.configure({
  after: server(log)
});
```

## Alternative functional-style syntax
You can use a functional-style syntax to compose your methods if you prefer. Here's an example.

```js
const fetchGifs = async({ searchTerm, limit }) => {...}

export const getGifs = createMethod(server(schema({ searchTerm: String, limit: Number })(fetchGifs)))
```
`getGifs` is callable from the client but will only run on the server. Internally it will be identified as `fetchGifs`

**`Note`**: if you pass in a named function into `createMethod`, then that will be used to identify the method internally. Otherwise if you pass in an anonymous function, `jam:method` generates a unique name based on its schema to identify it internally.

### Customizing methods when using functional-style syntax
There are a few functions available when you need to customize the method: `schema`, `server`, `open`, `close`. These can be composed when needed.

#### schema
Specify the schema to validate against.

```js
import { schema } from 'meteor/jam:method';

export const doSomething = schema({thing: String, num: Number})(async ({ thing, num }) => {
  // ... //
});
```

#### server
Make the method run on the server only.

```js
import { server } from 'meteor/jam:method';

export const aServerOnlyMethod = server(async data => {
  // ... //
});
```

#### open
Make the method publically available so that a logged-in user isn't required.

```js
import { open } from 'meteor/jam:method';

export const aPublicMethod = open(async data => {
  // ... //
});
```

#### close
Make the method check for a logged-in user.

**`Note`**: by default, all methods require a logged-in user so if you stick with that default, then you won't need to use this function. See [Configuring](#configuring-optional).

```js
import { close } from 'meteor/jam:method';

export const closedMethod = close(async data => {
  // ... //
});
```

## Using with `jam:easy-schema`
`jam:method` integrates with `jam:easy-schema` and offers a way to reduce boilerplate and make your methods even easier to write (though you can still use `createMethod` if you prefer).

For example, instead of writing this:
```js
export const setDone = createMethod({
  name: 'todos.setDone',
  schema: Todos.schema,
  before: checkOwnership,
  async run({ _id, done }) {
    return Todos.updateAsync({ _id }, { $set: { done } });
  }
});
```

You can write:
```js
export const setDone = async ({ _id, done }) => {
  await checkOwnership({ _id });
  return Todos.updateAsync({ _id }, { $set: { done } });
};
```

**`Note`**: This assumes that you're attaching your methods to its collection. See [Attach methods to its Collection](#attach-methods-to-its-collection-optional).

When you call `Todos.setDone` from the client, the arguments will be automatically checked against the `Todos.schema`. The method will automatically be named `todos.setDone` internally to identify it for app performance monitoring (APM) purposes.

You can also compose with the functions available in the [function-style syntax](#alternative-functional-style-syntax). For example:
```js
export const setDone = server(async ({ _id, done }) => {
  await checkOwnership({ _id });
  return Todos.updateAsync({ _id }, { $set: { done } });
});
```
Now when you call `Todos.setDone` from the client it will only run on the server.

## Using with `jam:offline`
`jam:method` integrates with `jam:offline` to automatically queue methods when a user is offline. You don't need to configure anything in `jam:method` for this. 🎉 `jam:offline` will then replay them when the user reconnects. See [jam:offline](https://github.com/jamauro/offline) for more details.

## Coming from `Validated Method`?
You may be familiar with `mixins` and wondering where they are. With the features of this package - authenticated by default, `before` / `after` hooks, `.pipe` - your mixin code may no longer be needed or can be simplified. If you have another use case where your mixin doesn't translate, I'd love to hear it. Open a new discussion and let's chat.

---

---
url: /packages/less.md
---
# less

[LESS](http://lesscss.org/) extends CSS with dynamic behavior such as variables, mixins,
operations and functions. It allows for more compact stylesheets and
helps reduce code duplication in CSS files.

With the `less` package installed, `.less` files in your application are
automatically compiled to CSS and the results are included in the client CSS
bundle.

> If you want to `@import` a file, give it the extension `.import.less`
to prevent Meteor from processing it independently.

---

---
url: /generators/packages-listing/README.md
---
# Listing of all meteor core packages

This is a script that will generate a list of all meteor core packages, being ran every build.
This ensures that we always have a list of core packages up to date with their correct links to GitHub.


We can always add packages to the list by adding them to the `script.js` constant `OUTSIDE_OF_CORE_PACKAGES`.

Should follow the following format:

```js
{
  name: 'package-name',
  link: 'https://link-to-github.com/meteor/meteor/tree/devel/packages/package-name'
}
```

At the end, this script will update the file located in `docs/source/packages/packages-listing.md` with the new list of packages.

---

---
url: /packages/logging.md
---
# Logging

The `logging` package provides a standardised way for you to log and display in console various message from your application.
The added benefit is that among other data it will show you the location where the log was fired,
this is useful during debugging to quickly locate where the message is coming from.

Start by installing the package:

```bash
meteor add logging
```

You can then import the utility anywhere in you code like this:

```javascript
import { Log } from "meteor/logging";
```

You can then call the logging functions in one of the following ways:

```javascript
Log("starting up"); // or Log.info('starting up')
Log.error("error message");
Log.warn("warning");
Log.debug("this will show only in development");
```

Besides passing in strings, you can also pass in objects. This has few exceptions and special functions associated.
First in the root of the object the following keys are not allowed:

```javascript
  "time",
  "timeInexact",
  "level",
  "file",
  "line",
  "program",
  "originApp",
  "satellite",
  "stderr";
```

On the other hand there is `message` and `app`, which are also reserved, but they will display in more prominent manner:

```javascript
Log.info({
  message: "warning",
  app: "DESKTOP",
  error: { property1: "foo", property2: "bar", property3: { foo: "bar" } },
});
```

will turn into:

```shell
E20200519-17:57:41.655(9) [DESKTOP] (main.js:36) warning {"error":{"property1":"foo","property2":"bar","property3":{"foo":"bar"}}}
```

The display of each log is color coded. Info is `blue`, warn is `magenta`, debug is `green` and error is in `red`.

### Log.debug

The `Log.debug()` logging is different from the other calls as these messages will not be displayed in production.

### Options

You can set the following options:

```javascript
// Either 'json' or 'colored-text'. Defaults to 'json'.
//
// When this is set to 'json', print JSON documents to the console.
//
// When this is set to 'colored-text', call 'Log.format' before printing.
// This should be used for logging to the console in a human-readable format.
Log.outputFormat = "json";

// Boolean. Defaults to true.
// for cloud environments is interesting to leave it false as most of them have the timestamp in the console.
// Only works in server with colored-text output format.
Log.showTime = true;
```

---

---
url: /packages/packages-listing.md
---


[//]: # (Do not edit this file by hand.)

[//]: # (This is a generated file.)

[//]: # (If you want to change something in this file)

[//]: # (go to meteor/docs/generators/packages-listing)

# Maintained Packages

Meteor maintains several packages that are part of the Meteor Core.

The list below refers to the repository links for these packages compatible with Meteor 3.0.

### [blaze](https://github.com/meteor/blaze/tree/meteor-3.0) {#blaze}
### [react-packages](https://github.com/meteor/react-packages) {#react-packages}
### [accounts-2fa](https://github.com/meteor/meteor/tree/release-3.0/packages/accounts-2fa) {#accounts-2fa}
### [accounts-base](https://github.com/meteor/meteor/tree/release-3.0/packages/accounts-base) {#accounts-base}
### [accounts-facebook](https://github.com/meteor/meteor/tree/release-3.0/packages/accounts-facebook) {#accounts-facebook}
### [accounts-github](https://github.com/meteor/meteor/tree/release-3.0/packages/accounts-github) {#accounts-github}
### [accounts-google](https://github.com/meteor/meteor/tree/release-3.0/packages/accounts-google) {#accounts-google}
### [accounts-meetup](https://github.com/meteor/meteor/tree/release-3.0/packages/accounts-meetup) {#accounts-meetup}
### [accounts-meteor-developer](https://github.com/meteor/meteor/tree/release-3.0/packages/accounts-meteor-developer) {#accounts-meteor-developer}
### [accounts-oauth](https://github.com/meteor/meteor/tree/release-3.0/packages/accounts-oauth) {#accounts-oauth}
### [accounts-password](https://github.com/meteor/meteor/tree/release-3.0/packages/accounts-password) {#accounts-password}
### [accounts-passwordless](https://github.com/meteor/meteor/tree/release-3.0/packages/accounts-passwordless) {#accounts-passwordless}
### [accounts-twitter](https://github.com/meteor/meteor/tree/release-3.0/packages/accounts-twitter) {#accounts-twitter}
### [accounts-ui](https://github.com/meteor/meteor/tree/release-3.0/packages/accounts-ui) {#accounts-ui}
### [accounts-ui-unstyled](https://github.com/meteor/meteor/tree/release-3.0/packages/accounts-ui-unstyled) {#accounts-ui-unstyled}
### [accounts-weibo](https://github.com/meteor/meteor/tree/release-3.0/packages/accounts-weibo) {#accounts-weibo}
### [allow-deny](https://github.com/meteor/meteor/tree/release-3.0/packages/allow-deny) {#allow-deny}
### [audit-argument-checks](https://github.com/meteor/meteor/tree/release-3.0/packages/audit-argument-checks) {#audit-argument-checks}
### [autopublish](https://github.com/meteor/meteor/tree/release-3.0/packages/autopublish) {#autopublish}
### [autoupdate](https://github.com/meteor/meteor/tree/release-3.0/packages/autoupdate) {#autoupdate}
### [babel-compiler](https://github.com/meteor/meteor/tree/release-3.0/packages/babel-compiler) {#babel-compiler}
### [babel-runtime](https://github.com/meteor/meteor/tree/release-3.0/packages/babel-runtime) {#babel-runtime}
### [base64](https://github.com/meteor/meteor/tree/release-3.0/packages/base64) {#base64}
### [binary-heap](https://github.com/meteor/meteor/tree/release-3.0/packages/binary-heap) {#binary-heap}
### [boilerplate-generator](https://github.com/meteor/meteor/tree/release-3.0/packages/boilerplate-generator) {#boilerplate-generator}
### [boilerplate-generator-tests](https://github.com/meteor/meteor/tree/release-3.0/packages/boilerplate-generator-tests) {#boilerplate-generator-tests}
### [browser-policy](https://github.com/meteor/meteor/tree/release-3.0/packages/browser-policy) {#browser-policy}
### [browser-policy-common](https://github.com/meteor/meteor/tree/release-3.0/packages/browser-policy-common) {#browser-policy-common}
### [browser-policy-content](https://github.com/meteor/meteor/tree/release-3.0/packages/browser-policy-content) {#browser-policy-content}
### [browser-policy-framing](https://github.com/meteor/meteor/tree/release-3.0/packages/browser-policy-framing) {#browser-policy-framing}
### [caching-compiler](https://github.com/meteor/meteor/tree/release-3.0/packages/caching-compiler) {#caching-compiler}
### [callback-hook](https://github.com/meteor/meteor/tree/release-3.0/packages/callback-hook) {#callback-hook}
### [check](https://github.com/meteor/meteor/tree/release-3.0/packages/check) {#check}
### [constraint-solver](https://github.com/meteor/meteor/tree/release-3.0/packages/constraint-solver) {#constraint-solver}
### [context](https://github.com/meteor/meteor/tree/release-3.0/packages/context) {#context}
### [core-runtime](https://github.com/meteor/meteor/tree/release-3.0/packages/core-runtime) {#core-runtime}
### [crosswalk](https://github.com/meteor/meteor/tree/release-3.0/packages/crosswalk) {#crosswalk}
### [ddp](https://github.com/meteor/meteor/tree/release-3.0/packages/ddp) {#ddp}
### [ddp-client](https://github.com/meteor/meteor/tree/release-3.0/packages/ddp-client) {#ddp-client}
### [ddp-common](https://github.com/meteor/meteor/tree/release-3.0/packages/ddp-common) {#ddp-common}
### [ddp-rate-limiter](https://github.com/meteor/meteor/tree/release-3.0/packages/ddp-rate-limiter) {#ddp-rate-limiter}
### [ddp-server](https://github.com/meteor/meteor/tree/release-3.0/packages/ddp-server) {#ddp-server}
### [deprecated](https://github.com/meteor/meteor/tree/release-3.0/packages/deprecated) {#deprecated}
### [dev-error-overlay](https://github.com/meteor/meteor/tree/release-3.0/packages/dev-error-overlay) {#dev-error-overlay}
### [diff-sequence](https://github.com/meteor/meteor/tree/release-3.0/packages/diff-sequence) {#diff-sequence}
### [disable-oplog](https://github.com/meteor/meteor/tree/release-3.0/packages/disable-oplog) {#disable-oplog}
### [dynamic-import](https://github.com/meteor/meteor/tree/release-3.0/packages/dynamic-import) {#dynamic-import}
### [ecmascript](https://github.com/meteor/meteor/tree/release-3.0/packages/ecmascript) {#ecmascript}
### [ecmascript-runtime](https://github.com/meteor/meteor/tree/release-3.0/packages/ecmascript-runtime) {#ecmascript-runtime}
### [ecmascript-runtime-client](https://github.com/meteor/meteor/tree/release-3.0/packages/ecmascript-runtime-client) {#ecmascript-runtime-client}
### [ecmascript-runtime-server](https://github.com/meteor/meteor/tree/release-3.0/packages/ecmascript-runtime-server) {#ecmascript-runtime-server}
### [ejson](https://github.com/meteor/meteor/tree/release-3.0/packages/ejson) {#ejson}
### [email](https://github.com/meteor/meteor/tree/release-3.0/packages/email) {#email}
### [es5-shim](https://github.com/meteor/meteor/tree/release-3.0/packages/es5-shim) {#es5-shim}
### [facebook-config-ui](https://github.com/meteor/meteor/tree/release-3.0/packages/facebook-config-ui) {#facebook-config-ui}
### [facebook-oauth](https://github.com/meteor/meteor/tree/release-3.0/packages/facebook-oauth) {#facebook-oauth}
### [facts-base](https://github.com/meteor/meteor/tree/release-3.0/packages/facts-base) {#facts-base}
### [facts-ui](https://github.com/meteor/meteor/tree/release-3.0/packages/facts-ui) {#facts-ui}
### [fetch](https://github.com/meteor/meteor/tree/release-3.0/packages/fetch) {#fetch}
### [force-ssl](https://github.com/meteor/meteor/tree/release-3.0/packages/force-ssl) {#force-ssl}
### [force-ssl-common](https://github.com/meteor/meteor/tree/release-3.0/packages/force-ssl-common) {#force-ssl-common}
### [geojson-utils](https://github.com/meteor/meteor/tree/release-3.0/packages/geojson-utils) {#geojson-utils}
### [github-config-ui](https://github.com/meteor/meteor/tree/release-3.0/packages/github-config-ui) {#github-config-ui}
### [github-oauth](https://github.com/meteor/meteor/tree/release-3.0/packages/github-oauth) {#github-oauth}
### [google-config-ui](https://github.com/meteor/meteor/tree/release-3.0/packages/google-config-ui) {#google-config-ui}
### [google-oauth](https://github.com/meteor/meteor/tree/release-3.0/packages/google-oauth) {#google-oauth}
### [hot-code-push](https://github.com/meteor/meteor/tree/release-3.0/packages/hot-code-push) {#hot-code-push}
### [hot-module-replacement](https://github.com/meteor/meteor/tree/release-3.0/packages/hot-module-replacement) {#hot-module-replacement}
### [id-map](https://github.com/meteor/meteor/tree/release-3.0/packages/id-map) {#id-map}
### [insecure](https://github.com/meteor/meteor/tree/release-3.0/packages/insecure) {#insecure}
### [inter-process-messaging](https://github.com/meteor/meteor/tree/release-3.0/packages/inter-process-messaging) {#inter-process-messaging}
### [launch-screen](https://github.com/meteor/meteor/tree/release-3.0/packages/launch-screen) {#launch-screen}
### [localstorage](https://github.com/meteor/meteor/tree/release-3.0/packages/localstorage) {#localstorage}
### [logging](https://github.com/meteor/meteor/tree/release-3.0/packages/logging) {#logging}
### [logic-solver](https://github.com/meteor/meteor/tree/release-3.0/packages/logic-solver) {#logic-solver}
### [meetup-config-ui](https://github.com/meteor/meteor/tree/release-3.0/packages/meetup-config-ui) {#meetup-config-ui}
### [meetup-oauth](https://github.com/meteor/meteor/tree/release-3.0/packages/meetup-oauth) {#meetup-oauth}
### [meteor](https://github.com/meteor/meteor/tree/release-3.0/packages/meteor) {#meteor}
### [meteor-base](https://github.com/meteor/meteor/tree/release-3.0/packages/meteor-base) {#meteor-base}
### [meteor-developer-config-ui](https://github.com/meteor/meteor/tree/release-3.0/packages/meteor-developer-config-ui) {#meteor-developer-config-ui}
### [meteor-developer-oauth](https://github.com/meteor/meteor/tree/release-3.0/packages/meteor-developer-oauth) {#meteor-developer-oauth}
### [meteor-platform](https://github.com/meteor/meteor/tree/release-3.0/packages/meteor-platform) {#meteor-platform}
### [meteor-tool](https://github.com/meteor/meteor/tree/release-3.0/packages/meteor-tool) {#meteor-tool}
### [minifier-css](https://github.com/meteor/meteor/tree/release-3.0/packages/minifier-css) {#minifier-css}
### [minifier-js](https://github.com/meteor/meteor/tree/release-3.0/packages/minifier-js) {#minifier-js}
### [minimongo](https://github.com/meteor/meteor/tree/release-3.0/packages/minimongo) {#minimongo}
### [mobile-experience](https://github.com/meteor/meteor/tree/release-3.0/packages/mobile-experience) {#mobile-experience}
### [mobile-status-bar](https://github.com/meteor/meteor/tree/release-3.0/packages/mobile-status-bar) {#mobile-status-bar}
### [modern-browsers](https://github.com/meteor/meteor/tree/release-3.0/packages/modern-browsers) {#modern-browsers}
### [modules](https://github.com/meteor/meteor/tree/release-3.0/packages/modules) {#modules}
### [modules-runtime](https://github.com/meteor/meteor/tree/release-3.0/packages/modules-runtime) {#modules-runtime}
### [modules-runtime-hot](https://github.com/meteor/meteor/tree/release-3.0/packages/modules-runtime-hot) {#modules-runtime-hot}
### [mongo](https://github.com/meteor/meteor/tree/release-3.0/packages/mongo) {#mongo}
### [mongo-dev-server](https://github.com/meteor/meteor/tree/release-3.0/packages/mongo-dev-server) {#mongo-dev-server}
### [mongo-id](https://github.com/meteor/meteor/tree/release-3.0/packages/mongo-id) {#mongo-id}
### [mongo-livedata](https://github.com/meteor/meteor/tree/release-3.0/packages/mongo-livedata) {#mongo-livedata}
### [npm-mongo](https://github.com/meteor/meteor/tree/release-3.0/packages/npm-mongo) {#npm-mongo}
### [oauth](https://github.com/meteor/meteor/tree/release-3.0/packages/oauth) {#oauth}
### [oauth-encryption](https://github.com/meteor/meteor/tree/release-3.0/packages/oauth-encryption) {#oauth-encryption}
### [oauth1](https://github.com/meteor/meteor/tree/release-3.0/packages/oauth1) {#oauth1}
### [oauth2](https://github.com/meteor/meteor/tree/release-3.0/packages/oauth2) {#oauth2}
### [ordered-dict](https://github.com/meteor/meteor/tree/release-3.0/packages/ordered-dict) {#ordered-dict}
### [package-stats-opt-out](https://github.com/meteor/meteor/tree/release-3.0/packages/package-stats-opt-out) {#package-stats-opt-out}
### [package-version-parser](https://github.com/meteor/meteor/tree/release-3.0/packages/package-version-parser) {#package-version-parser}
### [promise](https://github.com/meteor/meteor/tree/release-3.0/packages/promise) {#promise}
### [random](https://github.com/meteor/meteor/tree/release-3.0/packages/random) {#random}
### [rate-limit](https://github.com/meteor/meteor/tree/release-3.0/packages/rate-limit) {#rate-limit}
### [react-fast-refresh](https://github.com/meteor/meteor/tree/release-3.0/packages/react-fast-refresh) {#react-fast-refresh}
### [reactive-dict](https://github.com/meteor/meteor/tree/release-3.0/packages/reactive-dict) {#reactive-dict}
### [reactive-var](https://github.com/meteor/meteor/tree/release-3.0/packages/reactive-var) {#reactive-var}
### [reload](https://github.com/meteor/meteor/tree/release-3.0/packages/reload) {#reload}
### [reload-safetybelt](https://github.com/meteor/meteor/tree/release-3.0/packages/reload-safetybelt) {#reload-safetybelt}
### [retry](https://github.com/meteor/meteor/tree/release-3.0/packages/retry) {#retry}
### [routepolicy](https://github.com/meteor/meteor/tree/release-3.0/packages/routepolicy) {#routepolicy}
### [server-render](https://github.com/meteor/meteor/tree/release-3.0/packages/server-render) {#server-render}
### [service-configuration](https://github.com/meteor/meteor/tree/release-3.0/packages/service-configuration) {#service-configuration}
### [session](https://github.com/meteor/meteor/tree/release-3.0/packages/session) {#session}
### [sha](https://github.com/meteor/meteor/tree/release-3.0/packages/sha) {#sha}
### [shell-server](https://github.com/meteor/meteor/tree/release-3.0/packages/shell-server) {#shell-server}
### [socket-stream-client](https://github.com/meteor/meteor/tree/release-3.0/packages/socket-stream-client) {#socket-stream-client}
### [standard-app-packages](https://github.com/meteor/meteor/tree/release-3.0/packages/standard-app-packages) {#standard-app-packages}
### [standard-minifier-css](https://github.com/meteor/meteor/tree/release-3.0/packages/standard-minifier-css) {#standard-minifier-css}
### [standard-minifier-js](https://github.com/meteor/meteor/tree/release-3.0/packages/standard-minifier-js) {#standard-minifier-js}
### [standard-minifiers](https://github.com/meteor/meteor/tree/release-3.0/packages/standard-minifiers) {#standard-minifiers}
### [static-html](https://github.com/meteor/meteor/tree/release-3.0/packages/static-html) {#static-html}
### [test-helpers](https://github.com/meteor/meteor/tree/release-3.0/packages/test-helpers) {#test-helpers}
### [test-in-browser](https://github.com/meteor/meteor/tree/release-3.0/packages/test-in-browser) {#test-in-browser}
### [test-in-console](https://github.com/meteor/meteor/tree/release-3.0/packages/test-in-console) {#test-in-console}
### [test-server-tests-in-console-once](https://github.com/meteor/meteor/tree/release-3.0/packages/test-server-tests-in-console-once) {#test-server-tests-in-console-once}
### [tinytest](https://github.com/meteor/meteor/tree/release-3.0/packages/tinytest) {#tinytest}
### [tinytest-harness](https://github.com/meteor/meteor/tree/release-3.0/packages/tinytest-harness) {#tinytest-harness}
### [tracker](https://github.com/meteor/meteor/tree/release-3.0/packages/tracker) {#tracker}
### [twitter-config-ui](https://github.com/meteor/meteor/tree/release-3.0/packages/twitter-config-ui) {#twitter-config-ui}
### [twitter-oauth](https://github.com/meteor/meteor/tree/release-3.0/packages/twitter-oauth) {#twitter-oauth}
### [typescript](https://github.com/meteor/meteor/tree/release-3.0/packages/typescript) {#typescript}
### [underscore](https://github.com/meteor/meteor/tree/release-3.0/packages/underscore) {#underscore}
### [underscore-tests](https://github.com/meteor/meteor/tree/release-3.0/packages/underscore-tests) {#underscore-tests}
### [url](https://github.com/meteor/meteor/tree/release-3.0/packages/url) {#url}
### [webapp](https://github.com/meteor/meteor/tree/release-3.0/packages/webapp) {#webapp}
### [webapp-hashing](https://github.com/meteor/meteor/tree/release-3.0/packages/webapp-hashing) {#webapp-hashing}
### [weibo-config-ui](https://github.com/meteor/meteor/tree/release-3.0/packages/weibo-config-ui) {#weibo-config-ui}
### [weibo-oauth](https://github.com/meteor/meteor/tree/release-3.0/packages/weibo-oauth) {#weibo-oauth}

---

---
url: /packages/markdown.md
---
# Markdown

> Note: This package has been deprecated.

This package lets you use Markdown in your templates.

### Installation

```sh
meteor add markdown
```

### Usage

This package is lazy loaded. Is is not added into the initial Bundle.
So you need to import it in your template.

```js
// myTemplate.js
import 'meteor/markdown';
```

Then you can use the `markdown` helper in your templates:

```html
<!-- myTemplate.html -->
{{#markdown}}I am using __markdown__.{{/markdown}}
```

outputs

```html
<p>I am using <strong>markdown</strong>.</p>
```

---

---
url: /api/meteor.md
---
# Meteor API

Meteor global object has many functions and properties for handling utilities, network and much more.

### Core APIs {#core}

<ApiBox name="Meteor.startup" hasCustomExample/>

On a server, the function will run as soon as the server process is
finished starting. On a client, the function will run as soon as the DOM
is ready. Code wrapped in `Meteor.startup` always runs after all app
files have loaded, so you should put code here if you want to access
shared variables from other files.

The `startup` callbacks are called in the same order as the calls to
`Meteor.startup` were made.

On a client, `startup` callbacks from packages will be called
first, followed by `<body>` templates from your `.html` files,
followed by your application code.

::: code-group

```js [server.js]
import { Meteor } from "meteor/meteor";
import { LinksCollection } from "/imports/api/links";

Meteor.startup(async () => {
  // If the Links collection is empty, add some data.
  if ((await LinksCollection.find().countAsync()) === 0) {
    await LinksCollection.insertAsync({
      title: "Do the Tutorial",
      url: "https://www.meteor.com/tutorials/react/creating-an-app",
    });
  }
});
```

```js [client.js]
import React from "react";
import { createRoot } from "react-dom/client";
import { Meteor } from "meteor/meteor";
import { App } from "/imports/ui/App";

// Setup react root
Meteor.startup(() => {
  const container = document.getElementById("react-target");
  const root = createRoot(container);
  root.render(<App />);
});
```

:::

<ApiBox name="Meteor.promisify" />
<ApiBox name="Meteor.defer" />
<ApiBox name="Meteor.absoluteUrl" />
<ApiBox name="Meteor.settings" />
<ApiBox name="Meteor.release" />

<ApiBox name="Meteor.isClient" />

<ApiBox name="Meteor.isServer" />

::: danger
`Meteor.isServer` can be used to limit where code runs, but it does not prevent code from
being sent to the client. Any sensitive code that you don’t want served to the client,
such as code containing passwords or authentication mechanisms,
should be kept in the `server` directory.
:::

<ApiBox name="Meteor.isCordova" />
<ApiBox name="Meteor.isDevelopment" />
<ApiBox name="Meteor.isProduction" />
<ApiBox name="Meteor.isModern" />
<ApiBox name="Meteor.isTest" />
<ApiBox name="Meteor.isAppTest" />
<ApiBox name="Meteor.isPackageTest" />

<ApiBox name="Meteor.gitCommitHash" />

### Method APIs {#methods}

Meteor Methods are Remote Procedure Calls (RPCs) are functions defined by `Meteor.methods`
and called by [`Meteor.call`](#Meteor-call).

<ApiBox name="Meteor.methods" hasCustomExample/>

The most basic way to define a method is to provide a function:

::: code-group

```js [server.js]
import { Meteor } from "meteor/meteor";

Meteor.methods({
  sum(a, b) {
    return a + b;
  },
});
```

```js [client.js]
import { Meteor } from "meteor/meteor";

const result = await Meteor.callAsync("sum", 1, 2);
console.log(result); // 3
```

:::

You can use `Meteor.methods` to define multiple methods at once.

You can think of `Meteor.methods` as a way of defining a remote object that is your server API.

A more complete example:

::: code-group

```js [server.js]
import { Meteor } from "meteor/meteor";
import { check } from "meteor/check";
import { LinksCollection } from "/imports/api/links";

Meteor.methods({
  async addLink(link) {
    check(link, String); // check if the link is a string

    // Do stuff...
    const linkID = await LinksCollection.insertAsync(link);
    if (/* you want to throw an error */) {
      throw new Meteor.Error('Something is wrong', "Some details");
    }

    return linkID;
  },

  bar() {
    // Do other stuff...
    return 'baz';
  }
});
```

```js [client.js]
import React from "react";
import { Meteor } from "meteor/meteor";

function Component() {
  const addLink = () =>
    Meteor.callAsync(
      "addLink",
      "https://www.meteor.com/tutorials/react/creating-an-app"
    );

  return (
    <div>
      <button onClick={addLink}>Add Link</button>
    </div>
  );
}
```

:::

Calling `methods` on the server defines functions that can be called remotely by
clients. They should return an [EJSON](./EJSON)-able value or throw an
exception. Inside your method invocation, `this` is bound to a method
invocation object, which provides the following:

- `isSimulation`: a boolean value, true if this invocation is a stub.
- `unblock`: when called, allows the next method from this client to
  begin running.
- `userId`: the id of the current user.
- `setUserId`: a function that associates the current client with a user.
- `connection`: on the server, the [connection](#Meteor-onConnection) this method call was received on.

Calling `methods` on the client defines _stub_ functions associated with
server methods of the same name. You don't have to define a stub for
your method if you don't want to. In that case, method calls are just
like remote procedure calls in other systems, and you'll have to wait
for the results from the server.

If you do define a stub, when a client invokes a server method it will
also run its stub in parallel. On the client, the return value of a
stub is ignored. Stubs are run for their side-effects: they are
intended to _simulate_ the result of what the server's method will do,
but without waiting for the round trip delay. If a stub throws an
exception it will be logged to the console.

You use methods all the time, because the database mutators
([`insert`](./collections#Mongo-Collection-insert), [`update`](./collections#Mongo-Collection-update), [`remove`](./collections#Mongo-Collection-remove)) are implemented
as methods. When you call any of these functions on the client, you're invoking
their stub version that update the local cache, and sending the same write
request to the server. When the server responds, the client updates the local
cache with the writes that actually occurred on the server.

You don't have to put all your method definitions into a single `Meteor.methods`
call; you may call it multiple times, as long as each method has a unique name.

If a client calls a method and is disconnected before it receives a response,
it will re-call the method when it reconnects. This means that a client may
call a method multiple times when it only means to call it once. If this
behavior is problematic for your method, consider attaching a unique ID
to each method call on the client, and checking on the server whether a call
with this ID has already been made. Alternatively, you can use
[`Meteor.apply`](#Meteor-apply) with the noRetry option set to true.

Read more about methods and how to use them in the [Methods](http://guide.meteor.com/methods.html) article in the Meteor Guide.

<ApiBox name="Meteor.isAsyncCall" hasCustomExample/>

This method can be used to determine if the current method invocation is
asynchronous. It returns true if the method is running on the server and came from
an async call(`Meteor.callAsync`)

::: code-group

```js [server.js]
import { Meteor } from "meteor/meteor";

Meteor.methods({
  async foo() {
    return Meteor.isAsyncCall();
  },
});
```

```js [client.js]
import { Meteor } from "meteor/meteor";

const result = await Meteor.callAsync("foo");
console.log(result); // true

Meteor.call("foo", (err, result) => {
  console.log(result); // false
});
```

:::

## this.userId {#methods-userId}

The user id is an arbitrary string &mdash; typically the id of the user record
in the database. You can set it with the `setUserId` function. If you're using
the [Meteor accounts system](./accounts.md) then this is handled for you.

```js
import { Meteor } from "meteor/meteor";

Meteor.methods({
  foo() {
    console.log(this.userId);
  },
});
```

## this.setUserId {#methods-setUserId}

Call this function to change the currently logged-in user on the
connection that made this method call. This simply sets the value of
`userId` for future method calls received on this connection. Pass
`null` to log out the connection.

If you are using the [built-in Meteor accounts system](./accounts) then this
should correspond to the `_id` field of a document in the
[`Meteor.users`](./accounts.md#Meteor-user) collection.

`setUserId` is not retroactive. It affects the current method call and
any future method calls on the connection. Any previous method calls on
this connection will still see the value of `userId` that was in effect
when they started.

If you also want to change the logged-in user on the client, then after calling
`setUserId` on the server, call `Meteor.connection.setUserId(userId)` on the
client.

```js
import { Meteor } from "meteor/meteor";

Meteor.methods({
  foo() {
    this.setUserId("some-id");
  },
});
```

## this.connection {#methods-connection}

Access inside a method invocation. The [connection](#Meteor-onConnection) that this method was received on.
null if the method is not associated with a connection,
eg. a server initiated method call. Calls to methods
made from a server method which was in turn initiated from the client share the same
connection.

<ApiBox name="Meteor.Error" />

For example:

::: code-group

```js [server.js]
import { Meteor } from "meteor/meteor";
// on the server, pick a code unique to this error
// the reason field should be a useful debug message
Meteor.methods({
  methodName() {
    throw new Meteor.Error(
      "logged-out",
      "The user must be logged in to post a comment."
    );
  },
});
```

```js [client.js]
import { Meteor } from "meteor/meteor";
// on the client
Meteor.call("methodName", function (error) {
  // identify the error
  if (error && error.error === "logged-out") {
    // show a nice error message
    Session.set("errorMessage", "Please log in to post a comment.");
  }
});
```

:::

If you want to return an error from a method, throw an exception. Methods can
throw any kind of exception. But `Meteor.Error` is the only kind of error that
a server will send to the client. If a method function throws a different
exception, then it will be mapped to a sanitized version on the
wire. Specifically, if the `sanitizedError` field on the thrown error is set to
a `Meteor.Error`, then that error will be sent to the client. Otherwise, if no
sanitized version is available, the client gets
`Meteor.Error(500, 'Internal server error')`.

<ApiBox name="Meteor.call" hasCustomExample/>

This is how to invoke a method with a sync stub. It will run the method on the server. If a
stub is available, it will also run the stub on the client. (See also
[`Meteor.apply`](#Meteor-apply), which is identical to `Meteor.call` except that
you specify the parameters as an array instead of as separate arguments and you
can specify a few options controlling how the method is executed.)

If you include a callback function as the last argument (which can't be
an argument to the method, since functions aren't serializable), the
method will run asynchronously: it will return nothing in particular and
will not throw an exception. When the method is complete (which may or
may not happen before `Meteor.call` returns), the callback will be
called with two arguments: `error` and `result`. If an error was thrown,
then `error` will be the exception object. Otherwise, `error` will be
`undefined` and the return value (possibly `undefined`) will be in `result`.

```js
// Asynchronous call
Meteor.call('foo', 1, 2, (error, result) => { ... });
```

If you do not pass a callback on the server, the method invocation will
block until the method is complete. It will eventually return the
return value of the method, or it will throw an exception if the method
threw an exception. (Possibly mapped to 500 Server Error if the
exception happened remotely and it was not a `Meteor.Error` exception.)

```js
// Synchronous call
const result = Meteor.call("foo", 1, 2);
```

On the client, if you do not pass a callback and you are not inside a
stub, `call` will return `undefined`, and you will have no way to get
the return value of the method. That is because the client doesn't have
fibers, so there is not actually any way it can block on the remote
execution of a method.

Finally, if you are inside a stub on the client and call another
method, the other method is not executed (no RPC is generated, nothing
"real" happens). If that other method has a stub, that stub stands in
for the method and is executed. The method call's return value is the
return value of the stub function. The client has no problem executing
a stub synchronously, and that is why it's okay for the client to use
the synchronous `Meteor.call` form from inside a method body, as
described earlier.

Meteor tracks the database writes performed by methods, both on the client and
the server, and does not invoke `asyncCallback` until all of the server's writes
replace the stub's writes in the local cache. In some cases, there can be a lag
between the method's return value being available and the writes being visible:
for example, if another method still outstanding wrote to the same document, the
local cache may not be up to date until the other method finishes as well. If
you want to process the method's result as soon as it arrives from the server,
even if the method's writes are not available yet, you can specify an
`onResultReceived` callback to [`Meteor.apply`](#Meteor-apply).

::: warning
Use `Meteor.call` only to call methods that do not have a stub, or have a sync stub. If you want to call methods with an async stub, `Meteor.callAsync` can be used with any method.
:::


<ApiBox name="Meteor.callAsync" />

`Meteor.callAsync` is just like `Meteor.call`, except that it'll return a promise that you need to solve to get the server result. Along with the promise returned by `callAsync`, you can also handle `stubPromise` and `serverPromise` for managing client-side simulation and server response.

The following sections guide you in understanding these promises and how to manage them effectively.

#### serverPromise

```javascript
try {
	await Meteor.callAsync('greetUser', 'John');
	// 🟢 Server ended with success
} catch(e) {
	console.error("Error:", error.reason); // 🔴 Server ended with error
}

Greetings.findOne({ name: 'John' }); // 🗑️ Data is NOT available
```

#### stubPromise

```javascript
await Meteor.callAsync('greetUser', 'John').stubPromise;

// 🔵 Client simulation
Greetings.findOne({ name: 'John' }); // 🧾 Data is available (Optimistic-UI)
```

#### stubPromise and serverPromise

```javascript
const { stubPromise, serverPromise } = Meteor.callAsync('greetUser', 'John');

await stubPromise;

// 🔵 Client simulation
Greetings.findOne({ name: 'John' }); // 🧾 Data is available (Optimistic-UI)

try {
  await serverPromise;
  // 🟢 Server ended with success
} catch(e) {
  console.error("Error:", error.reason); // 🔴 Server ended with error
}

Greetings.findOne({ name: 'John' }); // 🗑️ Data is NOT available
```

#### Meteor 2.x contrast

For those familiar with legacy Meteor 2.x, the handling of client simulation and server response was managed using fibers, as explained in the following section. This comparison illustrates how async inclusion with standard promises has transformed the way Meteor operates in modern versions.

``` javascript
Meteor.call('greetUser', 'John', function(error, result) {
  if (error) {
    console.error("Error:", error.reason); // 🔴 Server ended with error
  } else {
    console.log("Result:", result); // 🟢 Server ended with success
  }

  Greetings.findOne({ name: 'John' }); // 🗑️ Data is NOT available
});

// 🔵 Client simulation
Greetings.findOne({ name: 'John' }); // 🧾 Data is available (Optimistic-UI)
```


<ApiBox name="Meteor.apply" />

`Meteor.apply` is just like `Meteor.call`, except that the method arguments are
passed as an array rather than directly as arguments, and you can specify
options about how the client executes the method.

::: warning
Use `Meteor.apply` only to call methods that do not have a stub, or have a sync stub. If you want to call methods with an async stub, `Meteor.applyAsync` can be used with any method.
:::

<ApiBox name="Meteor.applyAsync" />

`Meteor.applyAsync` is just like `Meteor.apply`, except it is an async function, and it will consider that the stub is async.

### Publish and subscribe {#pubsub}

These functions control how Meteor servers publish sets of records and
how clients can subscribe to those sets.

<ApiBox name="Meteor.publish" hasCustomExample>
To publish records to clients, call `Meteor.publish` on the server with
two parameters: the name of the record set, and a _publish function_
that Meteor will call each time a client subscribes to the name.

Publish functions can return a
[`Collection.Cursor`](./collections.md#mongo_cursor), in which case Meteor
will publish that cursor's documents to each subscribed client. You can
also return an array of `Collection.Cursor`s, in which case Meteor will
publish all of the cursors.

::: warning
If you return multiple cursors in an array, they currently must all be from
different collections. We hope to lift this restriction in a future release.
:::

</ApiBox>



```js
import { Meteor } from "meteor/meteor";
import { check } from "meteor/check";
import { Rooms } from "/imports/api/Rooms";
import { Messages } from "/imports/api/Messages";

// Server: Publish the `Rooms` collection, minus secret info...
Meteor.publish("rooms", function () {
  return Rooms.find(
    {},
    {
      fields: { secretInfo: 0 },
    }
  );
});

// ...and publish secret info for rooms where the logged-in user is an admin. If
// the client subscribes to both publications, the records are merged together
// into the same documents in the `Rooms` collection. Note that currently object
// values are not recursively merged, so the fields that differ must be top
// level fields.
Meteor.publish("adminSecretInfo", function () {
  return Rooms.find(
    { admin: this.userId },
    {
      fields: { secretInfo: 1 },
    }
  );
});

// Publish dependent documents and simulate joins.
Meteor.publish("roomAndMessages", function (roomId) {
  check(roomId, String);

  return [
    Rooms.find(
      { _id: roomId },
      {
        fields: { secretInfo: 0 },
      }
    ),
    Messages.find({ roomId }),
  ];
});
```

Alternatively, a publish function can directly control its published record set
by calling the functions [`added`](#Subscription-added) (to add a new document to the
published record set), [`changed`](#Subscription-changed) (to change or clear some
fields on a document already in the published record set), and
[`removed`](#Subscription-removed) (to remove documents from the published record
set). These methods are provided by `this` in your publish function.

If a publish function does not return a cursor or array of cursors, it is
assumed to be using the low-level `added`/`changed`/`removed` interface, and it
**must also call [`ready`](#Subscription-ready) once the initial record set is
complete**.

::: code-group

```js [collections.js]
import { Mongo } from "meteor/mongo";

export const Rooms = new Mongo.Collection("rooms");
export const SecretData = new Mongo.Collection("messages");
```

```js [server.js]
import { Meteor } from "meteor/meteor";
import { check } from "meteor/check";
import { Rooms, SecretData } from "/imports/api/collections";

// Publish the current size of a collection.
Meteor.publish("countsByRoom", function (roomId) {
  check(roomId, String);

  let count = 0;
  let initializing = true;

  // `observeChanges` only returns after the initial `added` callbacks have run.
  // Until then, we don't want to send a lot of `changed` messages—hence
  // tracking the `initializing` state.
  const handle = Messages.find({ roomId }).observeChanges({
    added: (id) => {
      count += 1;

      if (!initializing) {
        this.changed("counts", roomId, { count });
      }
    },

    removed: (id) => {
      count -= 1;
      this.changed("counts", roomId, { count });
    },

    // We don't care about `changed` events.
  });

  // Instead, we'll send one `added` message right after `observeChanges` has
  // returned, and mark the subscription as ready.
  initializing = false;
  this.added("counts", roomId, { count });
  this.ready();

  // Stop observing the cursor when the client unsubscribes. Stopping a
  // subscription automatically takes care of sending the client any `removed`
  // messages.
  this.onStop(() => handle.stop());
});

// Sometimes publish a query, sometimes publish nothing.
Meteor.publish("secretData", function () {
  if (this.userId === "superuser") {
    return SecretData.find();
  } else {
    // Declare that no data is being published. If you leave this line out,
    // Meteor will never consider the subscription ready because it thinks
    // you're using the `added/changed/removed` interface where you have to
    // explicitly call `this.ready`.
    return [];
  }
});
```

```js [client.js]
import { Meteor } from "meteor/meteor";
import { Mongo } from "meteor/mongo";
import { Session } from "meteor/session";
// Declare a collection to hold the count object.
const Counts = new Mongo.Collection("counts");

// Subscribe to the count for the current room.
Tracker.autorun(() => {
  Meteor.subscribe("countsByRoom", Session.get("roomId"));
});

// Use the new collection.
const roomCount = Counts.findOne(Session.get("roomId")).count;
console.log(`Current room has ${roomCount} messages.`);
```

::: warning

Meteor will emit a warning message if you call `Meteor.publish` in a
project that includes the `autopublish` package. Your publish function
will still work.

:::

Read more about publications and how to use them in the
[Data Loading](http://guide.meteor.com/data-loading.html) article in the Meteor Guide.

<ApiBox name="Subscription#userId" />

This is constant. However, if the logged-in user changes, the publish
function is rerun with the new value, assuming it didn't throw an error at the previous run.

<ApiBox name="Subscription#added" />
<ApiBox name="Subscription#changed" />
<ApiBox name="Subscription#removed" />
<ApiBox name="Subscription#ready" />
<ApiBox name="Subscription#onStop" />

If you call [`observe`](./collections.md#Mongo-Cursor-observe) or [`observeChanges`](./collections.md#Mongo-Cursor-observeChanges) in your
publish handler, this is the place to stop the observes.

<ApiBox name="Subscription#error" />
<ApiBox name="Subscription#stop" />
<ApiBox name="Subscription#connection" />

<ApiBox name="Meteor.subscribe" hasCustomExample/>

When you subscribe to a record set, it tells the server to send records to the
client. The client stores these records in local [Minimongo collections](./collections.md), with the same name as the `collection`
argument used in the publish handler's [`added`](#Subscription-added),
[`changed`](#Subscription-changed), and [`removed`](#Subscription-removed)
callbacks. Meteor will queue incoming records until you declare the
[`Mongo.Collection`](./collections.md) on the client with the matching
collection name.

```js
// It's okay to subscribe (and possibly receive data) before declaring the
// client collection that will hold it. Assume 'allPlayers' publishes data from
// the server's 'players' collection.
Meteor.subscribe("allPlayers");

// The client queues incoming 'players' records until the collection is created:
const Players = new Mongo.Collection("players");
```

The client will see a document if the document is currently in the published
record set of any of its subscriptions. If multiple publications publish a
document with the same `_id` for the same collection the documents are merged for
the client. If the values of any of the top level fields conflict, the resulting
value will be one of the published values, chosen arbitrarily.

::: warning
Currently, when multiple subscriptions publish the same document _only the top
level fields_ are compared during the merge. This means that if the documents
include different sub-fields of the same top level field, not all of them will
be available on the client. We hope to lift this restriction in a future release.
:::

The `onReady` callback is called with no arguments when the server [marks the subscription as ready](#Subscription-ready). The `onStop` callback is called with
a [`Meteor.Error`](#Meteor-Error) if the subscription fails or is terminated by
the server. If the subscription is stopped by calling `stop` on the subscription
handle or inside the publication, `onStop` is called with no arguments.

`Meteor.subscribe` returns a subscription handle, which is an object with the
following properties:

```ts
import { Meteor } from "meteor/meteor";
const handle = Meteor.subscribe("allPlayers");

handle.ready(); // True when the server has marked the subscription as ready

handle.stop(); // Stop this subscription and unsubscribe from the server

handle.subscriptionId; // The id of the subscription this handle is for.
```

When you run Meteor.subscribe inside of Tracker.autorun, the handles you get will always have the same subscriptionId field.
You can use this to deduplicate subscription handles if you are storing them in some data structure.

If you call `Meteor.subscribe` within a reactive computation,
for example using
[`Tracker.autorun`](./Tracker#Tracker-autorun), the subscription will automatically be
cancelled when the computation is invalidated or stopped; it is not necessary
to call `stop` on
subscriptions made from inside `autorun`. However, if the next iteration
of your run function subscribes to the same record set (same name and
parameters), Meteor is smart enough to skip a wasteful
unsubscribe/resubscribe. For example:

```js
Tracker.autorun(() => {
  Meteor.subscribe("chat", { room: Session.get("currentRoom") });
  Meteor.subscribe("privateMessages");
});
```

This subscribes you to the chat messages in the current room and to your private
messages. When you change rooms by calling `Session.set('currentRoom',
'newRoom')`, Meteor will subscribe to the new room's chat messages,
unsubscribe from the original room's chat messages, and continue to
stay subscribed to your private messages.

## Publication strategies

> The following features are available from Meteor 2.4 or `ddp-server@2.5.0`

Once you start scaling your application you might want to have more control on how the data from publications is being handled on the client.
There are three publications strategies:

#### SERVER_MERGE

`SERVER_MERGE` is the default strategy. When using this strategy, the server maintains a copy of all data a connection is subscribed to.
This allows us to only send deltas over multiple publications.

#### NO_MERGE_NO_HISTORY

The `NO_MERGE_NO_HISTORY` strategy results in the server sending all publication data directly to the client.
It does not remember what it has previously sent to client and will not trigger removed messages when a subscription is stopped.
This should only be chosen for special use cases like send-and-forget queues.

#### NO_MERGE

`NO_MERGE` is similar to `NO_MERGE_NO_HISTORY` but the server will remember the IDs it has
sent to the client so it can remove them when a subscription is stopped.
This strategy can be used when a collection is only used in a single publication.

When `NO_MERGE` is selected the client will be handling gracefully duplicate events without throwing an exception.
Specifically:

- When we receive an added message for a document that is already present in the client's collection, it will be changed.
- When we receive a change message for a document that is not in the client's collection, it will be added.
- When we receive a removed message for a document that is not in the client's collection, nothing will happen.

You can import the publication strategies from `DDPServer`.

```js
import { DDPServer } from "meteor/ddp-server";

const { SERVER_MERGE, NO_MERGE_NO_HISTORY, NO_MERGE } =
  DDPServer.publicationStrategies;
```

You can use the following methods to set or get the publication strategy for publications:

<ApiBox name="setPublicationStrategy" hasCustomExample/>

For the `foo` collection, you can set the `NO_MERGE` strategy as shown:

```js
import { DDPServer } from "meteor/ddp-server";
Meteor.server.setPublicationStrategy(
  "foo",
  DDPServer.publicationStrategies.NO_MERGE
);
```

<ApiBox name="getPublicationStrategy" />

### Server connections {#connections}

Functions to manage and inspect the network connection between the Meteor client and server.

<ApiBox name="Meteor.status" hasCustomExample/>

```js
import { Meteor } from "meteor/meteor";
const status = Meteor.status();

console.log(status);
//          ^^^^
// {
//   connected: Boolean,
//   status: String,
//   retryCount: Number,
//   retryTime: Number,
//   reason: String,
// }
```

Status object has the following fields:

- `connected` - _*Boolean*_ : True if currently connected to the server. If false, changes and
  method invocations will be queued up until the connection is reestablished.
- `status` - _*String*_: Describes the current reconnection status. The possible
  values are `connected` (the connection is up and
  running), `connecting` (disconnected and trying to open a
  new connection), `failed` (permanently failed to connect; e.g., the client
  and server support different versions of DDP), `waiting` (failed
  to connect and waiting to try to reconnect) and `offline` (user has disconnected the connection).
- `retryCount` - _*Number*_: The number of times the client has tried to reconnect since the
  connection was lost. 0 when connected.
- `retryTime` - _*Number or undefined*_: The estimated time of the next reconnection attempt. To turn this
  into an interval until the next reconnection, This key will be set only when `status` is `waiting`.
  You canuse this snippet:
  ```js
  retryTime - new Date().getTime();
  ```
- `reason` - _*String or undefined*_: If `status` is `failed`, a description of why the connection failed.

<ApiBox name="Meteor.reconnect" />

<ApiBox name="Meteor.disconnect" />

Call this method to disconnect from the server and stop all
live data updates. While the client is disconnected it will not receive
updates to collections, method calls will be queued until the
connection is reestablished, and hot code push will be disabled.

Call [Meteor.reconnect](#Meteor-reconnect) to reestablish the connection
and resume data transfer.

This can be used to save battery on mobile devices when real time
updates are not required.

<ApiBox name="Meteor.onConnection"  hasCustomExample/>

```js
import { Meteor } from "meteor/meteor";

const handle = Meteor.onConnection((connection) => {
  console.log(connection);
  //          ^^^^^^^^^^^
  // {
  //   id: String,
  //   close: Function,
  //   onClose: Function,
  //   clientAddress: String,
  //   httpHeaders: Object,
  // }
});

handle.stop(); // Unregister the callback
```

`onConnection` returns an object with a single method `stop`. Calling
`stop` unregisters the callback, so that this callback will no longer
be called on new connections.

The callback is called with a single argument, the server-side
`connection` representing the connection from the client. This object
contains the following fields:

- `id` - _*String*_: A globally unique id for this connection.
- `close` - _*Function*_: Close this DDP connection. The client is free to reconnect, but will
  receive a different connection with a new `id` if it does.
- `onClose` - _*Function*_: Register a callback to be called when the connection is closed.
  If the connection is already closed, the callback will be called immediately.
- `clientAddress` - _*String*_: The IP address of the client in dotted form (such as `127.0.0.1`). If you're running your Meteor server behind a proxy (so that clients
  are connecting to the proxy instead of to your server directly),
  you'll need to set the `HTTP_FORWARDED_COUNT` environment variable
  for the correct IP address to be reported by `clientAddress`.

  Set `HTTP_FORWARDED_COUNT` to an integer representing the number of
  proxies in front of your server. For example, you'd set it to `1`
  when your server was behind one proxy.

- `httpHeaders` - _*Object*_: When the connection came in over an HTTP transport (such as with
  Meteor's default SockJS implementation), this field contains
  whitelisted HTTP headers.

  Cookies are deliberately excluded from the headers as they are a
  security risk for this transport. For details and alternatives, see
  the [SockJS documentation](https://github.com/sockjs/sockjs-node#authorisation).

> Currently when a client reconnects to the server (such as after
> temporarily losing its Internet connection), it will get a new
> connection each time. The `onConnection` callbacks will be called
> again, and the new connection will have a new connection `id`.

> In the future, when client reconnection is fully implemented,
> reconnecting from the client will reconnect to the same connection on
> the server: the `onConnection` callback won't be called for that
> connection again, and the connection will still have the same
> connection `id`.

<ApiBox name="DDP.connect"  hasCustomExample/>

```js
import { DDP } from "meteor/ddp-client";
import { Mongo } from "meteor/mongo";
import { Meteor } from "meteor/meteor";
const options = {...};

const otherServer = DDP.connect("http://example.com", options);

otherServer.call("foo.from.other.server", 1, 2, function (err, result) {
  // ...
});

Metepr.call("foo.from.this.server", 1, 2, function (err, result) {
  // ...
});
const remoteColl = new Mongo.Collection("collectionName", { connection: otherServer });
remoteColl.find(...);


```

To call methods on another Meteor application or subscribe to its data
sets, call `DDP.connect` with the URL of the application.
`DDP.connect` returns an object which provides:

- `subscribe` -
  Subscribe to a record set. See
  [Meteor.subscribe](#Meteor-subscribe).
- `call` -
  Invoke a method. See [Meteor.call](#Meteor-call).
- `apply` -
  Invoke a method with an argument array. See
  [Meteor.apply](#Meteor-apply).
- `methods` -
  Define client-only stubs for methods defined on the remote server. See
  [Meteor.methods](#Meteor-methods).
- `status` -
  Get the current connection status. See
  [Meteor.status](#Meteor-status).
- `reconnect` -
  See [Meteor.reconnect](#Meteor-reconnect).
- `disconnect` -
  See [Meteor.disconnect](#Meteor-disconnect).

By default, clients open a connection to the server from which they're loaded.
When you call `Meteor.subscribe`, `Meteor.status`, `Meteor.call`, and
`Meteor.apply`, you are using a connection back to that default
server.

<ApiBox name="DDP.onReconnect" />

## Timers { #timers }

Meteor uses global environment variables
to keep track of things like the current request's user. To make sure
these variables have the right values, you need to use
`Meteor.setTimeout` instead of `setTimeout` and `Meteor.setInterval`
instead of `setInterval`.

These functions work just like their native JavaScript equivalents.
If you call the native function, you'll get an error stating that Meteor
code must always run within a Fiber, and advising to use
`Meteor.bindEnvironment`.

<ApiBox name="Meteor.setTimeout" />

Returns a handle that can be used by `Meteor.clearTimeout`.

<ApiBox name="Meteor.setInterval" />

Returns a handle that can be used by `Meteor.clearInterval`.

<ApiBox name="Meteor.clearTimeout" />
<ApiBox name="Meteor.clearInterval" />

## Enviroment variables {#envs}

Meteor implements `Meteor.EnvironmentVariable` with AsyncLocalStorage, which allows for maintaining context across asynchronous boundaries. `Meteor.EnvironmentVariable` works with `Meteor.bindEnvironment`, promises, and many other Meteor API's to preserve the context in async code. Some examples of how it is used in Meteor are to store the current user in methods, and record which arguments have been checked when using `audit-argument-checks`.

```js
import { Meteor } from "meteor/meteor";
const currentRequest = new Meteor.EnvironmentVariable();

function log(message) {
  const requestId = currentRequest.get() || "None";
  console.log(`[${requestId}]`, message);
}

currentRequest.withValue("12345", () => {
  log("Handling request"); // Logs: [12345] Handling request
});
```

<ApiBox name="Meteor.EnvironmentVariable" />
<ApiBox name="Meteor.EnvironmentVariableAsync" />
<ApiBox name="Meteor.EnvironmentVariable.get" />
<ApiBox name="Meteor.EnvironmentVariable.withValue" />

<ApiBox name="Meteor.bindEnvironment" />

---

---
url: /packages/index.md
---
# Meteor packaging system: Atmosphere packages

In this tutorial we will present the Meteor packaging system: Atmosphere packages. Atmosphere packages are a way to create reusable code that can shared by multiple apps. They can contain both client and server code, as well as assets like images and stylesheets.

Of course, you can also use npm packages in your Meteor apps. 
This tutorial only focuses on Meteor packages, which are a different system.

Two public repositories of Meteor packages exist:
- [Atmosphere](https://atmospherejs.com/): The original repository for Meteor packages, which hosts a wide variety of community-contributed packages.
- [Packosphere](https://packosphere.com/): A newer repository and community maintained alternative to Atmosphere. Packosphere has more information about package quality and maintenance status.

# Table of Contents

[[toc]]

<!-- @include: ./1.when-to-use-meteor-packages.md-->
<!-- @include: ./2.using-atmosphere-packages.md-->
<!-- @include: ./3.writing-atmosphere-packages.md-->

---

---
url: /community-packages/meteor-rpc.md
---
# Meteor-RPC

- `Who maintains the package` – [Grubba27](https://github.com/Grubba27), you can get in touch via [X](https://twitter.com/gab_grubba)

[[toc]]

## What is this package?

_Inspired on [zodern:relay](https://github.com/zodern/meteor-relay) and on [tRPC](https://trpc.io/)_

This package provides functions for building E2E type-safe RPCs focused on React front ends.

## How to download it?

::: warning

This package works only with Meteor 2.8 or higher.

If you are not sure about the version of Meteor you are using, you can check it by running the following command in your terminal within your project:

```bash
meteor --version
```

:::

```bash
meteor npm i meteor-rpc @tanstack/react-query zod
```

::: warning

Before continuing the installation, make sure you have `react-query` all set in your project; for more info, follow their [quick start guide](https://tanstack.com/query/latest/docs/framework/react/quick-start).

:::

## How to use it?

There are a few concepts that are important while using this package:

- This package is built on top of [`Meteor.methods`](../api/meteor.md#method-apis-methods) and [`Meteor.publish`](../api/meteor.md#publish-and-subscribe-pubsub) but with types and runtime validation, their understanding is important to use this package.
- Every method and publication uses `Zod` to validate the arguments, so you can be sure that the data you are receiving is what you expect.

::: tip
If you are accepting any type of data, you can use `z.any()` as the schema or `z.void` when there is no argument
:::

### `createModule`

This function is used to create a module that will be used to call our methods and publications

`subModule` without a namespace: `createModule()` is used to create the `main` server module, the one that will be exported to be used in the client.`

`subModule` with a namespace: `createModule("namespace")` is used to create a submodule that will be added to the main module.

> Remember to use `build` at the end of module creation to ensure that the module will be created.

Example:

::: code-group

```typescript [server/main.ts]
import { createModule } from "meteor-rpc";
import { Chat } from "./chat";

const server = createModule() // server has no namespace
  .addMethod("bar", z.string(), (arg) => "bar" as const)
  .addSubmodule(Chat)
  .build();

export type Server = typeof server;
```

```typescript [server/chat.ts]
import { createModule } from "meteor-rpc";
import { ChatCollection } from "/imports/api/chat";
import { z } from "zod";

export const Chat = createModule("chat")
  .addMethod("createChat", z.void(), async () => {
    return ChatCollection.insertAsync({ createdAt: new Date(), messages: [] });
  })
  .buildSubmodule();
```

```typescript [client/main.ts]
import { createClient } from "meteor-rpc";
// you must import the type of the server
import type { Server } from "/imports/api/server";

const api = createClient<Server>();
const bar: "bar" = await api.bar("some string");
// ?^ 'bar'
const newChatId = await api.chat.createChat(); // with intellisense
```

:::

### `module.addMethod`

Type:

```ts
addMethod(
  name: string,
  schema: ZodSchema,
  handler: (args: ZodTypeInput<ZodSchema>) => T,
  config?: Config<ZodTypeInput<ZodSchema>, T>
)
```

This is the equivalent of `Meteor.methods` but with types and runtime validation.

::: code-group

```typescript [server/with-meteor-rpc.ts]
import { createModule } from "meteor-rpc";
import { z } from "zod";

const server = createModule()
  .addMethod("foo", z.string(), (arg) => "foo" as const)
  .build();
```

```typescript [server/without-meteor-rpc.ts]
import { Meteor } from "meteor/meteor";
import { z } from "zod";

Meteor.methods({
  foo(arg: string) {
    z.string().parse(arg);
    return "foo";
  },
});
```

:::

### `module.addPublication`

Type:

```typescript
addPublication(
  name: string,
  schema: ZodSchema,
  handler: (args: ZodTypeInput<ZodSchema>) => Cursor<Result, Result>
)
```

This is the equivalent of `Meteor.publish` but with types and runtime validation.

::: code-group

```typescript [server/with-meteor-rpc.ts]
import { createModule } from "meteor-rpc";
import { ChatCollection } from "/imports/api/chat";
import { z } from "zod";

const server = createModule()
  .addPublication("chatRooms", z.void(), () => {
    return ChatCollection.find();
  })
  .build();
```

```typescript [server/without-meteor-rpc.ts]
import { Meteor } from "meteor/meteor";
import { ChatCollection } from "/imports/api/chat";

Meteor.publish("chatRooms", function () {
  return ChatCollection.find();
});
```

:::

### module.addSharedPublication

`addSharedPublication(name: string, schema: ZodSchema, handler: (args: ZodTypeInput<ZodSchema>) => Array<Mongo.Cursor<any>> | Promise<Array<Mongo.Cursor<any>>> )`

This is similar to [`addPublication`](#module-addpublication), but it allows you to create an array of cursors, which can be useful for shared queries that need to return multiple collections or different queries.

::: code-group

```typescript [server/with-meteor-rpc.ts]
// server/main.ts
import { createModule } from "meteor-rpc";
import { ChatCollection } from "/imports/api/chat";
import { UserCollection } from "/imports/api/user";
import { z } from "zod";

const server = createModule().addSharedPublication(
  "chatRooms",
  z.string(),
  (userId) => {
    return [ChatCollection.find({ userId }), UserCollection.find({ userId })];
  }
);

server.build();
```

```typescript [server/without-meteor-rpc.ts]
import { Meteor } from "meteor/meteor";
import { ChatCollection } from "/imports/api/chat";
import { UserCollection } from "/imports/api/user";
import { check } from "meteor/check";

Meteor.publish("chatRooms", function (userId) {
  check(userId, String);
  return [ChatCollection.find({ userId }), UserCollection.find({ userId })];
});
```

:::

### `module.addSubmodule`

This is used to add a submodule to the main module, adding namespaces for your methods and publications and making it easier to organize your code.

> Remember to use `submodule.buildSubmodule` when creating a submodule

::: code-group

```typescript [server/chat.ts]
import { ChatCollection } from "/imports/api/chat";
import { createModule } from "meteor-rpc";

export const chatModule = createModule("chat")
  .addMethod("createChat", z.void(), async () => {
    return ChatCollection.insertAsync({ createdAt: new Date(), messages: [] });
  })
  .buildSubmodule(); // <-- This is important so that this module can be added as a submodule
```

```typescript [server/chat.ts]
import { createModule } from "meteor-rpc";
import { chatModule } from "./server/chat";

const server = createModule()
  .addMethod("bar", z.string(), (arg) => "bar" as const)
  .addSubmodule(chatModule)
  .build();

server.chat; // <-- this is the namespace for the chat module
server.chat.createChat(); // <-- this is the method from the chat module and it gets autocompleted
```

:::

### `module.addMiddlewares`

Type:

```typescript
type Middleware = (raw: unknown, parsed: unknown) => void;

addMiddlewares(middlewares: Middleware[])
```

This is used to add middleware to the module; it should be used to add side effects logic to the methods and publications, which is ideal for logging or rate limiting.

The middleware ordering is last in, first out. Check the example below:

::: code-group

```typescript [server/chat.ts]
import { ChatCollection } from "/imports/api/chat";
import { createModule } from "meteor-rpc";

export const chatModule = createModule("chat")
  .addMiddlewares([
    (raw, parsed) => {
      console.log("runs first");
    },
  ])
  .addMethod("createChat", z.void(), async () => {
    return ChatCollection.insertAsync({ createdAt: new Date(), messages: [] });
  })
  .buildSubmodule();
```

```typescript [server/main.ts]
import { createModule } from "meteor-rpc";
import { chatModule } from "./server/chat";

const server = createModule()
  .addMiddlewares([
    (raw, parsed) => {
      console.log("runs second");
    },
  ])
  .addMethod("bar", z.string(), (arg) => "bar" as const)
  .addSubmodule(chatModule)
  .build();
```

```typescript [client/main.ts]
import { createClient } from "meteor-rpc";
import type { Server } from "/imports/api/server"; // you must import the type

const api = createClient<Server>();
await api.chat.createChat(); // logs "runs first" then "runs second"
await api.bar("str"); // logs "runs second"
```

:::

### `module.build`

This is used to build the module, it should be used at the end of the module creation to ensure that the exported type is correct.

::: code-group

```typescript [correct.ts]
// ✅ it has the build method
import { createModule } from "meteor-rpc";
import { z } from "zod";
const server = createModule()
  .addMethod("bar", z.string(), (arg) => "bar" as const)
  .build();

export type Server = typeof server;
```

```typescript [incorrect.ts]
// ❌ it is missing the build method
import { createModule } from "meteor-rpc";
import { z } from "zod";
const server = createModule().addMethod(
  "bar",
  z.string(),
  (arg) => "bar" as const
);

export type Server = typeof server;
```

:::

### `module.buildSubmodule`

This is used to build the submodule, it should be used at the end of the submodule creation and imported in the main module in the [`addSubmodule`](./meteor-rpc.md#module-addsubmodule) method.

::: code-group

```typescript [correct.ts]
import { createModule } from "meteor-rpc";
import { z } from "zod";

export const chatModule = createModule("chat")
  .addMethod("createChat", z.void(), async () => {
    return "chat" as const;
  })
  // ✅ it has the buildSubmodule method
  .buildSubmodule();
```

```typescript [incorrect.ts]
import { createModule } from "meteor-rpc";
import { z } from "zod";

export const otherSubmodule = createModule("other")
  .addMethod("otherMethod", z.void(), async () => {
    return "other" as const;
  })
  // ❌ it is missing the buildSubmodule method
  .build();

export const otherSubmodule = createModule("other").addMethod(
  "otherMethod",
  z.void(),
  async () => {
    return "other" as const;
  }
); // ❌ it is missing the buildSubmodule method
```

```typescript [server/main.ts]
import { createModule } from "meteor-rpc";
import { chatModule } from "./server/chat";

const server = createModule()
  .addMethod("bar", z.string(), (arg) => "bar" as const)
  .addSubmodule(chatModule)
  .build();
```

:::

## Using in the client

When using in the client, you _have_ to use the `createModule` and `build` methods to create a module that will be used in the client
and be sure that you are exporting the type of the module

_You should only create one client in your application_

You can have something like `api.ts` that will export the client and the type of the client

::: code-group

```typescript [server/main.ts]
import { createModule } from "meteor-rpc";

const server = createModule()
  .addMethod("bar", z.string(), (arg) => "bar" as const)
  .build();

export type Server = typeof server;
```

```typescript [client/main.ts]
// you must import the type
import type { Server } from "/imports/api/server";
const app = createClient<Server>();

await app.bar("str"); // it will return "bar"
```

:::

## React focused API

Our package has a React-focused API that uses `react-query` to handle the data fetching and mutations.

### `method.useMutation`

It uses the [`useMutation`](https://tanstack.com/query/latest/docs/framework/react/reference/useMutation#usemutation) from react-query to create a mutation that will call the method

::: code-group

```typescript [server/main.ts]
import { createModule } from "meteor-rpc";

const server = createModule()
  .addMethod("bar", z.string(), (arg) => {
    console.log("Server received", arg);
    return "bar" as const;
  })
  .build();

export type Server = typeof server;
```

```tsx [client.ts]
// you must import the type
import type { Server } from "/imports/api/server";
const app = createClient<Server>();

export const Component = () => {
  const { mutate, isLoading, isError, error, data } = app.bar.useMutation();

  return (
    <button
      onClick={() => {
        mutation.mutate("str");
      }}
    >
      Click me
    </button>
  );
};
```

:::

### `method.useQuery`

It uses the [`useQuery`](https://tanstack.com/query/latest/docs/framework/react/reference/useSuspenseQuery#usesuspensequery) from react-query to create a query that will call the method, it uses `suspense` to handle loading states

::: code-group

```typescript [server/main.ts]
import { createModule } from "meteor-rpc";

const server = createModule()
  .addMethod("bar", z.string(), (arg) => "bar" as const)
  .build();

export type Server = typeof server;
```

```tsx [client.ts]
// you must import the type of the server
import type { Server } from "/imports/api/server";
const app = createClient<Server>();

export const Component = () => {
  const { data } = app.bar.useQuery("str"); // this will trigger suspense

  return <div>{data}</div>;
};
```

:::

### `publication.useSubscription`

Subscriptions on the client have `useSubscription` method that can be used as a hook to subscribe to a publication. It uses `suspense` to handle loading states

::: code-group

```typescript [server/main.ts]
// server/main.ts
import { createModule } from "meteor-rpc";
import { ChatCollection } from "/imports/api/chat";
import { z } from "zod";

const server = createModule()
  .addPublication("chatRooms", z.void(), () => {
    return ChatCollection.find();
  })
  .build();

export type Server = typeof server;
```

```tsx [client.ts]
import type { Server } from "/imports/api/server"; // you must import the type
const app = createClient<Server>();

export const Component = () => {
  // it will trigger suspense and `rooms` is reactive in this context.
  // When there is a change in the collection it will rerender
  const { data: rooms, collection: chatCollection } =
    api.chatRooms.usePublication();

  return (
    <div>
      {rooms.map((room) => (
        <div key={room._id}>{room.name}</div>
      ))}
    </div>
  );
};
```

:::

## Examples

Currently, we have:

- [chat-app](https://github.com/Grubba27/testing-meteor-rpc) that uses this package to create a chat-app
- [askme](https://github.com/fredmaiaarantes/askme) that uses this package to create a Q&A app, you can check it live [here](https://askmeaquestion.meteorapp.com/)

## Advanced usage

You can take advantage of the hooks to add custom logic to your methods, checking the raw and parsed data and the result of the method,
If the method fails, you can also check the error.

::: code-group

```typescript [on-method-after-creation.ts]
import { createModule } from "meteor-rpc";
import { z } from "zod";

const server = createModule()
  .addMethod("bar", z.string(), (arg) => "bar" as const)
  .build();

// you can add hooks after the method has been created
server.bar.addBeforeResolveHook((raw, parsed) => {
  console.log("before resolve", raw, parsed);
});

server.bar.addAfterResolveHook((raw, parsed, result) => {
  console.log("after resolve", raw, parsed, result);
});

server.bar.addErrorResolveHook((err, raw, parsed) => {
  console.log("on error", err, raw, parsed);
});

export type Server = typeof server;
```

```typescript [on-method-creation.ts]
import { createModule } from "meteor-rpc";
import { z } from "zod";

const server = createModule()
  // Or you can add hooks when creating the method
  .addMethod("bar", z.any(), () => "str", {
    hooks: {
      onBeforeResolve: [
        (raw, parsed) => {
          console.log("before resolve", raw, parsed);
        },
      ],
      onAfterResolve: [
        (raw, parsed, result) => {
          console.log("after resolve", raw, parsed, result);
        },
      ],
      onErrorResolve: [
        (err, raw, parsed) => {
          console.log("on error", err, raw, parsed);
        },
      ],
    },
  })
  .build();

export type Server = typeof server;
```

:::

## Known issues

if you are getting a similar error like this one:

```text

=> Started MongoDB.
Typescript processing requested for web.browser using Typescript 5.7.2
Creating new Typescript watcher for /app
Starting compilation in watch mode...
Compiling server/chat/model.ts
Compiling server/chat/module.ts
Compiling server/main.ts
Writing .meteor/local/plugin-cache/refapp_meteor-typescript/0.5.6/v2cache/buildfile.tsbuildinfo
Compilation finished in 0.3 seconds. 3 files were (re)compiled.
did not find /app/.meteor/local/plugin-cache/refapp_meteor-typescript/0.5.6/v2cache/out/client/main.js
did not find /app/.meteor/local/plugin-cache/refapp_meteor-typescript/0.5.6/v2cache/out/client/main.js
Nothing emitted for client/main.tsx
node:internal/crypto/hash:115
    throw new ERR_INVALID_ARG_TYPE(
          ^

TypeError [ERR_INVALID_ARG_TYPE]: The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received null
    at Hash.update (node:internal/crypto/hash:115:11)
    at /Users/user/.meteor/packages/meteor-tool/.3.0.4.1tddsze.as7rh++os.osx.arm64+web.browser+web.browser.legacy+web.cordova/mt-os.osx.arm64/tools/fs/tools/fs/watch.ts:329:28
    at Array.forEach (<anonymous>)
    at /Users/user/.meteor/packages/meteor-tool/.3.0.4.1tddsze.as7rh++os.osx.arm64+web.browser+web.browser.legacy+web.cordova/mt-os.osx.arm64/tools/fs/tools/fs/watch.ts:329:8
    at JsOutputResource._get (/tools/isobuild/compiler-plugin.js:1002:19) {
  code: 'ERR_INVALID_ARG_TYPE'
}

Node.js v20.18.0
```

Please check if you are using `refapp:meteor-typescript` package, if so, you can remove it and use the `typescript` package instead.
The `refapp:meteor-typescript` package is currently incompatible with the `meteor-rpc` package.

If it is still not working, please open an issue in the [repo](https://github.com/Grubba27/meteor-rpc)

---

---
url: /tutorials/react/index.md
---
# Meteor.js 3 + React

In this tutorial, we will create a simple To-Do app using [React](https://react.dev/) and Meteor 3.0. Meteor works well with other frameworks like [Blaze](https://www.blazejs.org/), [Vue 3](https://vuejs.org/), [Solid](https://www.solidjs.com/), and [Svelte](https://svelte.dev/).

React is a popular JavaScript library for building user interfaces. It allows you to create dynamic and interactive applications by composing UI components. React uses a declarative approach, where you define how the UI should look based on the state, and it efficiently updates the view when the state changes. With JSX, a syntax extension that combines JavaScript and HTML, React makes it easy to create reusable components that manage their own state and render seamlessly in the browser.

To start building your React app, you'll need a code editor. If you're unsure which one to choose, [Visual Studio Code](https://code.visualstudio.com/) is a good option.

Let’s begin building your app!

# Table of Contents

[[toc]]

<!-- @include: ./1.creating-the-app.md-->
<!-- @include: ./2.collections.md-->
<!-- @include: ./3.forms-and-events.md-->
<!-- @include: ./4.update-and-remove.md-->
<!-- @include: ./5.styles.md-->
<!-- @include: ./6.filter-tasks.md-->
<!-- @include: ./7.adding-user-accounts.md-->
<!-- @include: ./8.deploying.md-->
<!-- @include: ./9.next-steps.md-->

---

---
url: /tutorials/vue/meteorjs3-vue3-vue-meteor-tracker.md
---
# Meteor.js 3 + Vue 3 and `vue-meteor-tracker`

In this tutorial, we will create a simple To-Do app using [Vue 3](https://vuejs.org/) and Meteor 3.0. Meteor works well with other frameworks like [Blaze](https://www.blazejs.org/), [React](https://react.dev/), [Solid](https://www.solidjs.com/), and [Svelte](https://svelte.dev/).

Vue.js is a powerful JavaScript framework for making user interfaces. It helps you build interactive applications by using templates that connect to data and update automatically when the data changes. Vue.js templates use a simple syntax similar to HTML and work with Vue’s reactivity system to show components in the browser.

To start building your Vue.js app, you'll need a code editor. If you're unsure which one to choose, [Visual Studio Code](https://code.visualstudio.com/) is a good option.
:::warning
This tutorial uses the `vue-meteor-tracker` package, which is currently in beta and does not support async calls yet. However, it is still a valuable package, and we hope it will be updated soon. We are also working on a new tutorial that will use Meteor core packages instead.
:::

Let’s begin building your app!

# Table of Contents

[[toc]]

## 1: Creating the app

### 1.1: Install Meteor.js

First, ensure you have Node.js version 20 installed. You can install the latest version of Meteor by using the command:

```shell
npx meteor
```

If you encounter any issues, please refer to the requirements and details in [our documentation](https://v3-docs.meteor.com/about/install.html).


### 1.2: Create a Meteor.js Project

To set up Meteor with Vue easily, run the following command, replacing `simple-todos-vue` with your chosen project name:

```shell
meteor create --vue simple-todos-vue --release=3.0.2
```

::: info
You can find the final version of this app in our [GitHub repository](https://github.com/meteor/meteor3-vue3).
:::

Meteor will create all the necessary files for you. The `--vue` flag generates a project using Vue, Vite and Tailwind CSS.

You will find the `client` directory contains files for your client-side setup. Inside, there should be an empty `main.js` file required for Meteor's import mode. However, with Vite, the entry point is set in the `vite.config.js` file, pointing to `imports/ui/main.js`, which is where Meteor renders the main component.

Check the server directory for the server setup where you will see `server/main.js` populating your MongoDB database with some default data. There's no need to install MongoDB separately, as Meteor includes an embedded version.

To run your app, use:

```shell
meteor npm run start
```

Your Vue code will be located in the `imports/ui directory`, with `App.vue` as the root component of your app.

Take a moment to explore the files created by Meteor. You don’t have to understand everything right away, but it helps to know where they are.


### 1.3: Cleaning the UI Folder


Let's remove some unnecessary files for a cleaner start. Keep only `App.vue`, `main.js`, and `router.js` in the `imports/ui` folder. Delete the following files: `About.vue`, `AppMenu.vue`, `Hello.vue`, `Home.vue`, and `Info.vue`.

Next, update `router.js` to remove references to the deleted components:

::: code-group
```javascript [imports/ui/router.js]
import { createRouter, createWebHistory } from 'vue-router';
import App from './App.vue';

export const router = createRouter({
  history: createWebHistory(),
  routes: [
    {
      path: '/',
      name: 'home',
      component: App,
    },
  ],
});
```
:::

This file is where you set up your routes and decide which component to render for each path.

Also, update the App component since some components no longer exist.

::: code-group
```vue [imports/ui/App.vue]
<template>
  <div class="p-8">
    <h1>Hello Meteor</h1>
  </div>
</template>
```
:::

### 1.4: Creating Sample Tasks


We’ll create our Vue components in the `imports/ui/components` folder. Start by making this folder and adding a file named `Task.vue` inside it.

This file will export a Vue component called `Task`, representing an individual task in your To-Do list.


::: code-group
```vue [imports/ui/components/Task.vue]
<script setup>
defineProps({
  task: {
    type: Object,
    required: true,
  },
});
</script>

<template>
  <li>{{ task.text }}</li>
</template>
```
:::

Since the `Task` component will be part of a list, it returns a `li` element.

For now, we won’t connect to our database, so define some sample data in the `App.vue` file to display a list of tasks. Create an array and a function to return this array.


::: code-group
```vue [imports/ui/App.vue]
<script setup>
import Task from './components/Task.vue'

const getTasks = () => {
    return [
      { _id: 1, text: 'Install Node.js 20' },
      { _id: 2, text: 'Install Meteor 3' },
      { _id: 3, text: 'Create and run your project' },
    ];
}
</script>

<template>
  <div class="p-8">
    <h1>Hello Meteor</h1>
  </div>
</template>
```
:::

### 1.5: Rendering Tasks


Now let's add some simple rendering logic with Vue to display our list items using the `Task` component.

Update the template of the `App` component to include the list of tasks:


::: code-group
```vue [imports/ui/App.vue]
<script setup>
import Task from './components/Task.vue'

const getTasks = () => {
    return [
      { _id: 1, text: 'Install Node.js 20' },
      { _id: 2, text: 'Install Meteor 3' },
      { _id: 3, text: 'Create and run your project' },
    ];
}
</script>
<template>
  <div class="container">
    <header>
      <h1 class="text-4xl font-bold text-gray-800 my-4">Todo List</h1>
    </header>
    <ul class="list-disc list-inside p-4">
      <Task v-for="task in getTasks()" :key="task._id" :task="task" />
    </ul>
  </div>
</template>
```
:::

For more information on Vue iterations, you can read [here](https://vuejs.org/api/built-in-directives.html#v-for).

In the next step, we will connect to the MongoDB database to store our tasks.


## 2: Collections


Meteor already sets up MongoDB for you. In order to use our database we need to create a *collection*, which is where we will store our *documents*, in our case our `tasks`.
You can read more about collections [here](http://guide.meteor.com/collections.html).


In this step we will implement all the necessary code to have a basic collection for our tasks up and running.

### 2.1: Create Tasks Collection


Before creating our collection, let's remove the `links.js` file from the `imports/api`  folder because we won't use it. Now, you can create a new collection to store our tasks by creating a new file named `tasksCollection.js` inside the `imports/api` folder.


::: code-group
```javascript [imports/api/tasksCollection.js]
import { Mongo } from 'meteor/mongo';

export const TasksCollection = new Mongo.Collection('tasks');
```
:::

The code above instantiates a new MongoDB collection and exports it. You can read more about app structure and imports/exports [here](https://guide.meteor.com/structure.html).

### 2.2: Initialize Tasks Collection


To make our collection work, you need to import it on the server to set things up.

You can use import `'./imports/api/tasksCollection'` or `import { TasksCollection } from './imports/api/tasksCollection'` if you plan to use `TasksCollection` in the same file. Just make sure it's imported.

Now, it’s easy to check if there is data in our collection, or we can easily add some sample data.

Replace the old content in `server/main.js` with the code below.

::: code-group
```javascript [server/main.js]
import { Meteor } from 'meteor/meteor';
import { TasksCollection } from '../imports/api/tasksCollection';

const insertTask = async text => await TasksCollection.insertAsync({text});

Meteor.startup(async () => {
  const tasksCount = await TasksCollection.find().countAsync();
  if (tasksCount === 0) {
    await insertTask('First Task');
    await insertTask('Second Task');
    await insertTask('Third Task');
    await insertTask('Fourth Task');
    await insertTask('Fifth Task');
    await insertTask('Sixth Task');
    await insertTask('Seventh Task');
  }
});
```
:::

So you are importing the `TasksCollection` and adding a few tasks on it calling a function to insert this string as our `text` field in our `task` document.

### 2.3: Render Tasks Collection


Now comes the fun part, you will render the tasks using a “data container” to feed Meteor’s reactive data into Vue’s component hierarchy. We will use the [vue-meteor-tracker](https://www.npmjs.com/package/vue-meteor-tracker) package for this.

::: info
Meteor works with Meteor packages and NPM packages, usually Meteor packages are using Meteor internals or other Meteor packages.
:::

The `vue-meteor-tracker` package is already included in the Vue skeleton, so you don’t need to add it.

When importing code from a Meteor package the only difference from NPM modules is that you need to prepend `meteor/` in the from part of your import.
First we need to implement a subscription at the `App` component to get the tasks updated from the server. It can be done simply by using the `subscribe` and `autorun` functions from `vue-meteor-tracker`.

::: info
The `vue-meteor-tracker` package doesn't support async calls yet, so we need to use sync functions. This is not an issue, but it's important to know.
:::


::: code-group
```vue [imports/ui/App.vue]
<script setup>
import Task from './components/Task.vue';
import { subscribe, autorun } from 'vue-meteor-tracker';
import { TasksCollection } from '../api/tasksCollection';

subscribe('tasks');
const tasks = autorun(() => TasksCollection.find({}).fetch()).result;
</script>

<template>
  <div class="container">
    <header>
      <h1 class="text-4xl font-bold text-gray-800 my-4">Todo List</h1>
    </header>
    <ul class="list-disc list-inside p-4">
      <Task v-for="task of tasks" :key="task._id" :task="task" />
    </ul>
  </div>
</template>
```
:::

To be able to fetch data in the client, you need to publish it in the server. To do it, create a file called `tasksPublications.js` and add the following code:


::: code-group
```javascript [imports/api/tasksPublications.js]
import { Meteor } from 'meteor/meteor';
import { TasksCollection } from './tasksCollection';

Meteor.publish('tasks', function publishTasks() {
    return TasksCollection.find();
});
```
:::

Now, import it on the server:


::: code-group
```javascript [server/main.js]
import '../imports/api/tasksPublications';
```
:::

> If you want to learn more about how publications works, you can read [here](/api/meteor.html#pubsub).

Now, your app should look like this:

![image](https://vue3-tutorial.meteor.com/simple-todos/assets/step02-task-list.png)

You can change your data on MongoDB in the server and your app will react and re-render for you.

You can connect to your MongoDB running `meteor mongo` in the terminal from your app folder or using a MongoDB UI client, like [NoSQLBooster](https://nosqlbooster.com/downloads) or [MongoDB Compass](https://www.mongodb.com/products/tools/compass). Your embedded MongoDB is running in the port `3001`.

See how to connect:

![image](https://vue3-tutorial.meteor.com/simple-todos/assets/new-screenshots/step02/nosql-new-connection.png)

See your database:

![image](https://vue3-tutorial.meteor.com/simple-todos/assets/new-screenshots/step02/nosql-connection-editor.png)

You can double-click your collection to see the documents stored on it:

![image](https://vue3-tutorial.meteor.com/simple-todos/assets/new-screenshots/step02/nosql-tasks-query.png)

## 3: Forms and Events


Now, we need to let users interact with the stored data. In our case, the first interaction is to add new tasks. One of the main ways in which a user can insert or edit data in a website is through forms, using the `<form>` tag.

### 3.1: Create Task Form


First, we need to create a simple form component to encapsulate our logic.

Create a new file `TaskForm.vue` in your `ui/components` folder.


::: code-group
```vue [imports/ui/components/TaskForm.vue]
<script setup>
import { ref } from 'vue';

const newTask = ref('');

const addTask = () => {
  console.log(newTask.value);
}
</script>

<template>
    <form @submit.prevent="addTask">
        <input
            v-model="newTask"
            class=" border border-gray-300 rounded-md py-2 px-4 mr-2 text-gray-600 text-sm focus:outline-none focus:border-gray-400 focus:ring-0"
            type="text" placeholder="Type to add new tasks" />
        <button class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded" type="submit">Add Task</button>
    </form>
</template>
```
:::

This form will have an input element that has a `v-model` attribute. The `newTask` data field will now be bound via two-way binding to the input element’s value.

You can see that the form element has a `@submit.prevent` attribute. This will call the `addTask` method, which will print the text to the console when the form is submitted. The `@` symbol is a shorthand for `v-on:`. The prevent modifier stops the form's default behavior, which is to reload the page.

### 3.2: Update the App component


Then we can simply add this to our `App` component above your list of tasks:


::: code-group
```vue [imports/ui/App.vue]
<script setup>
import Task from './components/Task.vue';
import TaskForm from './components/TaskForm.vue';
import { subscribe, autorun } from 'vue-meteor-tracker';
import { TasksCollection } from '../api/tasksCollection';

subscribe('tasks');
const tasks = autorun(() => TasksCollection.find({}).fetch()).result;
</script>

<template>
  <div class="container">
    <header>
      <h1 class="text-4xl font-bold text-gray-800 my-4">Todo List</h1>
    </header>
    <TaskForm />
    <ul class="list-disc list-inside p-4">
      <Task v-for="task of tasks" :key="task._id" :task="task" />
    </ul>
  </div>
</template>
```
:::

### 3.3: Add Insert Operation


Now you can edit the `addTask` function to insert a new task into the database. To do it, we will need to implement a Meteor Method.

Methods are essentially RPC calls to the server that let you perform operations on the server side securely. You can read more about Meteor Methods [here](https://guide.meteor.com/methods.html).

To create your methods, you can create a file called `tasksMethods.js`.


::: code-group
```javascript [imports/api/tasksMethods.js]
import { Meteor } from 'meteor/meteor';
import { check } from 'meteor/check';
import { TasksCollection } from './tasksCollection';

async function insertTask(text) {
    check(text, String);
    return await TasksCollection.insertAsync({
        text,
        createdAt: new Date,
    });
}

Meteor.methods({ insertTask });
```
:::

Remember to import your method on the `main.js` server file.


::: code-group
```javascript [server/main.js]
import { Meteor } from 'meteor/meteor';
import { TasksCollection } from '../imports/api/tasksCollection';
import '../imports/api/tasksPublications';
import '../imports/api/tasksMethods';
```
:::

Now, we can call this method from our `TaskForm.vue` component.


::: code-group
```vue [imports/ui/components/TaskForm.vue]
<script setup>
import { ref } from 'vue';
import { Meteor } from 'meteor/meteor';

const newTask = ref('');

const addTask = async () => {
  await Meteor.callAsync('insertTask', newTask.value.trim());
  newTask.value = '';
}
</script>
```
:::

Inside the function, we are adding a task to the `tasks` collection by calling `Meteor.callAsync()`. The first argument is the name of the method we want to call, and the second argument is the text of the task. We are also trimming the text to remove any extra spaces.

### 3.5: Show Newest Tasks First


Now, you just need to make a change which will improve user experience: we will show the newest tasks first. We can accomplish this quickly by sorting our [MongoDB](https://guide.meteor.com/collections.html#mongo-collections) query.


::: code-group
```javascript [imports/ui/App.vue]
...

const tasks = autorun(() => {
  return TasksCollection.find({}, { sort: { createdAt: -1 } }).fetch();
}).result;

...
```
:::

Your app should look like this:

![image](https://vue3-tutorial.meteor.com/simple-todos/assets/new-screenshots/step03/newest-task.png)

## 4: Update and Remove

Until now, you have only inserted documents to our collection. Let’s see how you can update and remove them using the user interface.


### 4.1: Add Checkbox


First, you need to add a `checkbox` element to your `Task` component, and we need to add the `v-model` directive to the checkbox. This will allow us to bind the value of the checkbox to the `checked` field of the task document.
To do this, we need to add a `ref` to the task document. This will allow us to access the task document in the template. And add a computed property `isChecked` for the state management of the checkbox.

We also have a prop called `task` that is passed to the component. This prop is an object that represents the task document.


::: code-group
```vue [imports/ui/components/Task.vue]
<script setup>
import { ref, computed } from 'vue';

const props = defineProps({
  task: {
    type: Object,
    required: true,
  },
});

const taskRef = ref({ ...props.task }); // Create a reactive copy of the task

const isChecked = computed(() => taskRef.value.checked);

</script>

<template>
  <div class="flex items-center rounded px-4 py-2 mb-2">
    <li>
      <input v-model="taskRef.checked" type="checkbox" :checked="isChecked" @change="handleCheckboxChange" />
    </li>
    <span class="text-gray-600 pl-2" :class="{ 'text-gray-400 italic line-through': taskRef.checked }">
      {{ task.text }}
    </span>
  </div>
</template>
 ..
```
:::

### 4.2: Toggle Checkbox


We need to implement the method to update the task document. So, update the `tasksMethods.js` file with the following code:


::: code-group
```javascript [imports/api/tasksMethods.js]
import { Meteor } from 'meteor/meteor';
import { check } from 'meteor/check';
import { TasksCollection } from './tasksCollection';

async function insertTask(text) {
    check(text, String);
    return await TasksCollection.insertAsync({
        text,
        createdAt: new Date,
    });
}

async function removeTask(taskId) {
    check(taskId, String);
    await TasksCollection.removeAsync(taskId);
}

async function setIsCheckedTask(taskId, checked) {
    check(taskId, String);
    check(checked, Boolean);

    await TasksCollection.updateAsync(taskId, {
        $set: {
            checked
        }
    });
}

Meteor.methods({ insertTask, removeTask, setIsCheckedTask });
```
:::

The `updateAsync` function on a collection takes two arguments. The first is a selector that identifies a subset of the collection, and the second is an update parameter that specifies what should be done to the matched objects.

In this case, the selector is just the `_id` of the relevant task. The update parameter uses `$set`, on our method, to toggle the `checked` field, which will represent whether the task has been completed.

On the client side, you need to add a function to handle the checkbox change event. This method updates the local `taskRef.checked` state and handles the Meteor call to update the task's checked status. It encapsulate any logic you want to perform when the checkbox is checked or unchecked.


::: code-group
```vue [imports/ui/components/Task.vue]
<script setup>
import { ref, computed } from 'vue';

const props = defineProps({
    task: {
      type: Object,
      required: true,
    },
});

const taskRef = ref({ ...props.task });

const isChecked = computed(() => taskRef.value.checked);

const handleCheckboxChange = async (event) => {
    const newCheckedValue = event.target.checked;
    taskRef.value.checked = newCheckedValue;

    try {
      await Meteor.callAsync('setIsCheckedTask', taskRef.value._id, newCheckedValue);
    } catch (error) {
      console.error('Error updating task checked state:', error);
    }
};
</script>

<template>
  <div class="flex items-center rounded px-4 py-2 mb-2">
    <li>
      <input v-model="taskRef.checked" type="checkbox" :checked="isChecked" @change="handleCheckboxChange" />
    </li>
    <span class="text-gray-600 pl-2" :class="{ 'text-gray-400 italic line-through': taskRef.checked }">
      {{ task.text }}
    </span>
  </div>
</template>
```
:::

Your app should look like this:

![image](https://vue3-tutorial.meteor.com/simple-todos/assets/new-screenshots/step04/checked-tasks.png)

### 4.3: Remove tasks


You can remove tasks with just a few lines of code.

First add a button after the text in your `Task` component and receive a callback function.

::: code-group
```vue [imports/ui/components/Task.vue]
...
<span class="text-gray-600 pl-2" :class="{ 'text-gray-400 italic line-through': taskRef.checked }">
  {{ task.text }}
</span>

<button
    class="ml-auto bg-red-500 hover:bg-red-600 text-white font-bold py-0.5 px-2 rounded"
    @click="deleteTask"> &times;
</button>
...
```
:::

Now add the removal logic into methods:


::: code-group
```javascript [imports/ui/components/Task.vue]
...
const deleteTask = async () => {
  try {
    await Meteor.callAsync('removeTask', taskRef.value._id);
  } catch (error) {
    console.error('Error deleting task:', error);
  }
};
...
```
:::

Your app should look like this:

![image](https://vue3-tutorial.meteor.com/simple-todos/assets/new-screenshots/step04/remove-button.png)

## 5: Styles


### 5.1: Tailwind CSS


Our user interface has not looked great so far. Let’s add some basic styling to create a foundation for a more professional app. We'll start with the App component.


::: code-group
```vue [imports/ui/App.vue]
<template>
  <header class="flex items-center justify-between px-4 py-4 bg-gray-100 border-t border-b border-gray-200">
    <h1 class="text-4xl font-bold text-gray-800 my-4">🚀 To-Do List</h1>
  </header>
  <div class="mx-auto max-w-2xl px-4 py-8 sm:px-6 lg:px-8">
    <div class="mb-8 md:w-96 md:mx-auto md:mb-0 md:mt-8 md:px-4 md:py-8 text-center md:bg-gray-100 md:rounded-lg">
      <TaskForm />
      <ul class="list-none list-inside pt-4 md:w-96">
        <Task v-for="task of tasks" :key="task._id" :task="task" />
      </ul>
    </div>
  </div>
</template>
```
:::

> Flexbox is an excellent tool to distribute and align elements in your UI. Check this [article](https://tailwindcss.com/docs/) to learn more about [Tailwind CSS](https://tailwindcss.com/), the CSS framework we are using in this tutorial.

We’ll also update the `TaskForm` component and the `Task` component.


::: code-group
```vue [imports/ui/components/TaskForm.vue]
<template>
  <form @submit.prevent="addTask">
    <input
        v-model="newTask"
        class=" border border-gray-300 rounded-md py-2 px-4 mr-2 text-gray-600 text-sm focus:outline-none focus:border-gray-400 focus:ring-0"
        type="text" placeholder="Type to add new tasks" />
    <button class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-1.5 px-4 rounded" type="submit">Add Task</button>
  </form>
</template>
```

```vue [imports/ui/components/Task.vue]
<template>
  <div class="flex items-center rounded p-4 py-2 mb-2 shadow-sm border border-gray-200 md:mr-8">
    <li>
      <input v-model="taskRef.checked" type="checkbox" readonly :checked="isChecked" @change="handleCheckboxChange" />
    </li>
    <span class="text-gray-600 pl-2" :class="{ 'text-gray-400 italic line-through': taskRef.checked }">
      {{ task.text }}
    </span>
    <button class="ml-auto bg-red-500 hover:bg-red-600 text-white font-bold py-0.5 px-2 rounded" @click="deleteTask">
      &times;
    </button>
  </div>
</template>
```
:::

Your app should look like this:

![image](https://vue3-tutorial.meteor.com/simple-todos/assets/new-screenshots/step05/new-ui.png)

In the next step we will make this task list more interactive providing a way to filter tasks.


## 6: Filter tasks


In this step you will filter your tasks by status and show the quantity of pending tasks.

### 6.1: Filter tasks


First, you will add a button to show or hide the completed tasks from the list:


::: code-group
```vue [imports/ui/App.vue]
<div class="mb-8 md:w-96 md:mx-auto md:mb-0 md:mt-8 md:px-4 md:py-8 text-center md:bg-gray-100 md:rounded-lg">
    <TaskForm />
    <div>
      <button class="text-sm font-semibold text-gray-600 hover:text-gray-800" @click="toggleHideCompleted">
        <span v-if="hideCompleted">Show all</span>
        <span v-else>Hide completed</span>
      </button>
    </div>
    <ul class="list-none list-inside pt-4 md:w-96">
      <Task v-for="task of tasks" :key="task._id" :task="task" />
    </ul>
</div>
```
:::

You can see that it reads from `hideCompleted`. We’ll need to initialize the value of `hideCompleted` using `ref` in the script section:


::: code-group
```javascript [imports/ui/App.vue]
...
import { ref } from 'vue';

const hideCompleted = ref(false);

subscribe('tasks');
...
```
:::

We can update `hideCompleted` from an event handler directly, which will then cause the component to re-render:

::: code-group
```javascript [imports/ui/App.vue]
...
const toggleHideCompleted = () => {
  hideCompleted.value = !hideCompleted.value
};
</script>
...
```
:::

Now, we need to update the list of tasks to filter out completed tasks when `hideCompleted` is `true`.

`imports/ui/App.vue`

```javascript
...

subscribe('tasks');

const tasks = autorun(() => {
  const filter = hideCompleted.value ? { checked: { $ne: true } } : {};
  return TasksCollection.find(filter, { sort: { createdAt: -1 } }).fetch();
}).result;

...
```


Mark a few tasks as completed so you can check the filter behaviour.

### 6.2: Pending tasks


Update the App component in order to show the number of pending tasks in the app bar.

You should avoid adding zero to your app bar when there are no pending tasks.


::: code-group
```vue [imports/ui/App.vue]
<script setup>
...
const incompleteTasksCount = autorun(() => {
  return TasksCollection.find({ checked: { $ne: true } }).count();
}).result;
...
</script>

<template>
...
  <h1 class="text-4xl font-bold text-gray-800 my-4">🚀 To-Do List
    <span v-if="incompleteTasksCount > 0" class="text-xl font-light text-gray-600">({{ incompleteTasksCount }})</span>
  </h1>
...
</template>
```
:::

At this point, your app should look like this:

![image](https://vue3-tutorial.meteor.com/simple-todos/assets/new-screenshots/step06/showing-all.png)


## 7: Adding User Accounts


### 7.1: Password Authentication


Meteor already comes with authentication and account management system out of the box, so you only need to add the `accounts-password` package to enable username and password authentication:

```shell
meteor add accounts-password
```

> There are many more authentication methods supported. You can read more about the accounts system [here](https://docs.meteor.com/api/accounts.html).



We also recommend you to install `bcrypt` node module, otherwise you are going to see a warning saying that you are using pure-Javascript implementation of it.

```shell
meteor npm install --save bcrypt
```

> You should always use `meteor npm` instead of only `npm` so you always use the `npm` version pinned by Meteor, this helps you to avoid problems due to different versions of npm installing different modules.


### 7.2: Create User Account


Now, you can create a default user for our app. We will create a new user when the server starts if we don’t find one in the database. Let's make specific functions for user creation and task creation, and then call both in `Meteor.startup()`.


::: code-group
```javascript [server/main.js]
import { Meteor } from 'meteor/meteor';
import { Accounts } from 'meteor/accounts-base';
import { TasksCollection } from '../imports/api/tasksCollection';
import '../imports/api/tasksPublications';
import '../imports/api/tasksMethods';

const SEED_USERNAME = 'meteorite';
const SEED_PASSWORD = 'password';

const createFirstUser = async () => {
  const user = await Accounts.findUserByUsername(SEED_USERNAME);
  if (!user) {
    await Accounts.createUserAsync({
      username: SEED_USERNAME,
      password: SEED_PASSWORD,
    });
  }
}

const insertTask = async text => await TasksCollection.insertAsync({text});

const createTasks = async () => {
  const tasksCount = await TasksCollection.find().countAsync();
  if (tasksCount === 0) {
    await insertTask('First Task');
    await insertTask('Second Task');
    await insertTask('Third Task');
    await insertTask('Fourth Task');
    await insertTask('Fifth Task');
    await insertTask('Sixth Task');
    await insertTask('Seventh Task');
  }
}

Meteor.startup(async () => {
  await createFirstUser();
  await createTasks();
});
```
:::

You should not see anything different in your app UI yet.

### 7.3: Login Form


You need to give users a way to enter their credentials and log in. For this, we need a form.

Create a new file called `LoginForm.vue` and add a form to it. Use `Meteor.loginWithPassword(username, password)` to log in the user with the provided information.


::: code-group
```vue [imports/ui/components/LoginForm.vue]
<script setup>
import { Meteor } from 'meteor/meteor';
import { ref } from 'vue';

const username = ref('');
const password = ref('');

const login = () => {
  Meteor.loginWithPassword(username.value, password.value);
}
</script>

<template>
  <form class="flex flex-col justify-center items-center w-full max-w-md mx-auto my-8" @submit.prevent="login">
    <div>
      <label for="username" class="block text-gray-700 text-sm font-bold mb-2">Username</label>
      <input v-model="username" type="text" name="username" placeholder="Username" required
             class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
    </div>

    <div class="mt-4">
      <label for="password" class="block text-gray-700 text-sm font-bold mb-2">Password</label>
      <input v-model="password" type="password" name="password" placeholder="Password" required
             class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
    </div>

    <div>
      <button type="submit"
              class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 mt-4 px-4 rounded focus:outline-none focus:shadow-outline">
        Log in
      </button>
    </div>
  </form>
</template>
```
:::

### 7.4: Require Authentication


Our app should only let authenticated users access the task management features.

We can achieve this by showing the `LoginForm` component when there is no authenticated user. If the user is logged in, we will show the tasks list.

We’ll need a `ref` to check if the user is logged in, a `userId` variable to store user data, and some logic using `watch` to update the `isLogged` `ref` when the user changes.


::: code-group
```javascript [imports/ui/App.vue]
...
import { Meteor } from 'meteor/meteor';
import { ref, watch } from 'vue';

const hideCompleted = ref(false);
const isLogged = ref(false);

const userId = autorun(() => Meteor.userId()).result;

watch(
  () => userId.value,
  (newUser) => {
    isLogged.value = !!newUser
  },
  { immediate: true }
);
...
```
:::

Next, we can wrap our user features in a `<div>` tag and use the `v-if` directive to show these features only when a user is logged in:


::: code-group
```vue [imports/ui/App.vue]
<script setup>
...
import LoginForm from './components/LoginForm.vue';
...
</script>

<template>
  <div v-if="isLogged">
    <header class="flex items-center justify-between px-4 py-4 bg-gray-100 border-t border-b border-gray-200">
      <h1 class="text-4xl font-bold text-gray-800 my-4">🚀 To-Do List
        <span v-if="incompleteTasksCount > 0" class="text-xl font-light text-gray-600">({{ incompleteTasksCount }})</span>
      </h1>
    </header>
    <div class="mx-auto max-w-2xl px-4 py-8 sm:px-6 lg:px-8">
      <div class="mb-8 md:w-96 md:mx-auto md:mb-0 md:mt-8 md:px-4 md:py-8 text-center md:bg-gray-100 md:rounded-lg">
        <TaskForm />
        <div>
          <button class="text-sm font-semibold text-gray-600 hover:text-gray-800" @click="toggleHideCompleted">
            <span v-if="hideCompleted">Show all</span>
            <span v-else>Hide completed</span>
          </button>
        </div>
        <ul class="list-none list-inside pt-4 md:w-96">
          <Task v-for="task of tasks" :key="task._id" :task="task" />
        </ul>
      </div>
    </div>
  </div>

  <div v-else>
    <LoginForm />
  </div>
</template>
```
:::

### 7.5: Server startup


From now on, every task must have an owner. Please go to your database and remove all the tasks:

`db.tasks.remove({});`

Then, update your `server/main.js` to add the seed tasks with your `meteoriote` user as the owner.


::: code-group
```javascript [server/main.js]
import { Meteor } from 'meteor/meteor';
import { Accounts } from 'meteor/accounts-base';
import { TasksCollection } from '../imports/api/tasksCollection';
import '../imports/api/tasksPublications';
import '../imports/api/tasksMethods';

const SEED_USERNAME = 'meteorite';
const SEED_PASSWORD = 'password';

const createFirstUser = async () => {
  const user = await Accounts.findUserByUsername(SEED_USERNAME);
  if (!user) {
    await Accounts.createUserAsync({
      username: SEED_USERNAME,
      password: SEED_PASSWORD,
    });
  }
}

const insertTask = async (text, userId) => {
  await TasksCollection.insertAsync({text, userId, createdAt: new Date()});
}

const createTasks = async () => {
  const tasksCount = await TasksCollection.find().countAsync();
  if (tasksCount === 0) {
    const user = await Accounts.findUserByUsername(SEED_USERNAME);

    await insertTask('First Task', user._id);
    await insertTask('Second Task', user._id);
    await insertTask('Third Task', user._id);
    await insertTask('Fourth Task', user._id);
    await insertTask('Fifth Task', user._id);
    await insertTask('Sixth Task', user._id);
    await insertTask('Seventh Task', user._id);
  }
}

Meteor.startup(async () => {
  await createFirstUser();
  await createTasks();
});
```
:::

See that we are using a new field called `userId` with our user `_id` field, we are also setting `createdAt` field.

Go to the tasks publication and add the `userId` to the find selector, so users will be able to see only their own tasks.


::: code-group
```javascript [imports/api/tasksPublications.js]
import { Meteor } from 'meteor/meteor';
import { TasksCollection } from './tasksCollection';

Meteor.publish('tasks', function publishTasks() {
  return TasksCollection.find({ userId: Meteor.userId() });
});
```
:::

Before testing, make sure to restart the server after making this change so that the `Meteor.startup` block runs again. This will likely happen automatically since you're changing the server-side code.

### 7.7: Task owner


Tasks are filtered by their owner in the publication using the authenticated user, but we should also filter the tasks in the UI. Use the user's `_id` to add the `userId` field to your MongoDB selector when retrieving tasks from Minimongo.

Your `tasks` function should look like this:


::: code-group
```vue [imports/ui/App.vue]
<script setup>
...
const userId = autorun(() => Meteor.userId()).result;

watch(
  () => userId.value,
  (newUserId) => {
    isLogged.value = !!newUserId
  },
  { immediate: true }
);

subscribe('tasks');

const tasks = autorun(() => {
  const filter = hideCompleted.value ? { checked: { $ne: true }, userId: userId.value } : { userId: userId.value };
  return TasksCollection.find(filter, { sort: { createdAt: -1 } }).fetch();
}).result;

const incompleteTasksCount = autorun(() => {
  return TasksCollection.find({ checked: { $ne: true }, userId: userId.value }).count()
}).result;

...
</script>
```
:::

### 7.8: Log out


We can include a new `button` right after our `h1`. On this button you can add an `onClick` handler to logout the user. It is very straightforward, just call `Meteor.logout()` on it.


::: code-group
```vue [imports/ui/App.vue]
<script setup>
...
const logout = () => Meteor.logout();
...
</script>

<h1 class="text-4xl font-bold text-gray-800 my-4">🚀 To-Do List
  <span v-if="incompleteTasksCount > 0" class="text-xl font-light text-gray-600">({{ incompleteTasksCount }})</span>
</h1>

<button
  class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
  @click="logout">
      Logout
</button>
...
```
:::

Now that we have authentication, we can add a check on the server side to ensure only logged-in users can delete, update, or add new tasks.

We can do this by adding the code below to each on `tasksMethods`:


```javascript
if (!Meteor.userId()) {
 throw new Meteor.Error('Not authorized.');
}
```


Follow how your `tasksMethods` should look like:


::: code-group
```javascript [/imports/api/tasksMethods.js]
import { Meteor } from 'meteor/meteor';
import { check } from 'meteor/check';
import { TasksCollection } from './tasksCollection';

async function insertTask(text) {
    check(text, String);
    if (!Meteor.userId()) {
        throw new Meteor.Error('Not authorized.');
    }
    return await TasksCollection.insertAsync({
        text,
        userId: Meteor.userId(),
        createdAt: new Date,
    });
}

async function removeTask(taskId) {
    check(taskId, String);
    if (!Meteor.userId()) {
        throw new Meteor.Error('Not authorized.');
    }
    await TasksCollection.removeAsync(taskId);
}

async function setIsCheckedTask(taskId, checked) {
    check(taskId, String);
    check(checked, Boolean);

    if (!Meteor.userId()) {
        throw new Meteor.Error('Not authorized.');
    }

    await TasksCollection.updateAsync(taskId, {
        $set: {
            checked
        }
    });
}

Meteor.methods({ insertTask, removeTask, setIsCheckedTask });
```
:::

Phew! You have done quite a lot in this step. Authenticated the user, set the user in the tasks and provided a way for the user to log out.

Your app should look like this:

![image](https://vue3-tutorial.meteor.com/simple-todos/assets/new-screenshots/step07/login-page.png)

![image](https://vue3-tutorial.meteor.com/simple-todos/assets/new-screenshots/step07/logged-page.png)


## 8: Deploying

Deploying a Meteor application is similar to deploying any other Node.js app that uses websockets. You can find deployment options in [our guide](https://guide.meteor.com/deployment), including Meteor Up, Docker, and our recommended method, Galaxy.

In this tutorial, we will deploy our app on [Galaxy](https://www.meteor.com/hosting), which is our own cloud solution. Galaxy offers a free plan, so you can deploy and test your app. Pretty cool, right?


### 8.1: Create your account


You need a Meteor account to deploy your apps. If you don’t have one yet, you can [sign up here](https://cloud.meteor.com/?isSignUp=true).
With this account, you can access our package manager, [Atmosphere](https://atmospherejs.com/), [Forums](https://forums.meteor.com/) and more.



### 8.2: Set up MongoDB (Optional)


As your app uses MongoDB the first step is to set up a MongoDB database, Galaxy offers MongoDB hosting on a free plan for testing purposes, and you can also request for a production ready database that allows you to scale.

In any MongoDB provider you will have a MongoDB URL which you must use it. If you use the free option provided by Galaxy, the initial setup is done for you.

Galaxy MongoDB URL will be like this: `mongodb://username:<password>@org-dbname-01.mongodb.galaxy-cloud.io` .
> You can read more about Galaxy MongoDB [here](https://galaxy-support.meteor.com/en/article/mongodb-general-1syd5af/).


### 8.3: Set up settings


You need to create a setting file, it’s a JSON file that Meteor apps can read configurations from. Create this file in a new folder called `private` in the root of your project. It is important to notice that `private` is a special folder that is not going to be published to the client side of your app.

Make sure you replace `Your MongoDB URL` by your own MongoDB URL :)


::: code-group
```json [private/settings.json]
{
  "galaxy.meteor.com": {
    "env": {
      "MONGO_URL": "Your MongoDB URL"
    }
  }
}
```
:::

### 8.4: Deploy it


Now you are ready to deploy, run `meteor npm install` before deploying to make sure all your dependencies are installed.

You also need to choose a subdomain to publish your app. We are going to use the main domain `meteorapp.com` that is free and included on any Galaxy plan.

In this example we are going to use `vue3-meteor-3.meteorapp.com` but make sure you select a different one, otherwise you are going to receive an error.


> You can learn how to use custom domains on Galaxy [here](https://galaxy-support.meteor.com/en/article/domains-16cijgc/). Custom domains are available starting with the Essentials plan.


Run the deployment command:

```shell
meteor deploy vue3-meteor-3.meteorapp.com --free --mongo
```

> If you are not using the free hosting with MongoDB on Galaxy, then remove the `--mongo` flag from the deploy script and add `--settings private/settings.json` with the proper setting for your app.


Make sure you replace `vue3-meteor-3` by a custom name that you want as subdomain. You will see a log like this:

```shell
meteor deploy vue3-meteor-3.meteorapp.com --settings private/settings.json
Talking to Galaxy servers at https://us-east-1.galaxy-deploy.meteor.com
Preparing to build your app...
Preparing to upload your app...
Uploaded app bundle for new app at vue-tutorial.meteorapp.com.
Galaxy is building the app into a native image.
Waiting for deployment updates from Galaxy...
Building app image...
Deploying app...
You have successfully deployed the first version of your app.
For details, visit https://galaxy.meteor.com/app/vue3-meteor-3.meteorapp.com
```


This process usually takes just a few minutes, but it depends on your internet speed as it’s going to send your app bundle to Galaxy servers.

> Galaxy builds a new Docker image that contains your app bundle and then deploy containers using it, [read more](https://galaxy-support.meteor.com/en/article/container-environment-lfd6kh/).

You can check your logs on Galaxy, including the part that Galaxy is building your Docker image and deploying it.

### 8.5: Access the app and enjoy


Now you should be able to access your Galaxy dashboard at `https://galaxy.meteor.com/app/vue3-meteor-3.meteorapp.com`.

You can also access your app on Galaxy 2.0 which is currently in beta at `https://galaxy-beta.meteor.com/<your-username>/us-east-1/apps/<your-app-name>.meteorapp.com`. Remember to use your own subdomain instead of `vue3-meteor-3`.

You can access the app at [vue3-meteor-3.meteorapp.com](https://vue3-meteor-3.meteorapp.com/)! Just use your subdomain to access yours!

> We deployed to Galaxy running in the US (us-east-1), we also have Galaxy running in other regions in the world, check the list [here](https://galaxy-support.meteor.com/en/article/regions-1vucejm/).

This is huge, you have your app running on Galaxy, ready to be used by anyone in the world!

## 9: Next Steps

You have completed the tutorial!

By now, you should have a good understanding of working with Meteor and Vue.

::: info
You can find the final version of this app in our [GitHub repository](https://github.com/meteor/meteor3-vue3).
:::

Here are some options for what you can do next:

- Check out the complete [documentation](https://v3-docs.meteor.com/) to learn more about Meteor 3.
- Read the [Galaxy Guide](https://galaxy-support.meteor.com/en/article/deploy-to-galaxy-18gd6e2/) to learn more about deploying your app.
- Join our community on the [Meteor Forums](https://forums.meteor.com/) and the [Meteor Lounge on Discord](https://discord.gg/hZkTCaVjmT) to ask questions and share your experiences.

We can't wait to see what you build next!

---

---
url: /api/app.md
---
# Mobile Configuration



If your Meteor application targets mobile platforms such as iOS or
Android, you can configure your app's metadata and build process
in a special top-level file called
`mobile-config.js` which is *not* included in your application and is used only
for this configuration.

The code snippet below is an example `mobile-config.js` file. The rest of this
section will explain the specific API commands in greater detail.

```js
// This section sets up some basic app metadata, the entire section is optional.
App.info({
  id: 'com.example.matt.uber',
  name: 'über',
  description: 'Get über power in one button click',
  author: 'Matt Development Group',
  email: 'contact@example.com',
  website: 'http://example.com'
});

// Set up resources such as icons and launch screens.
App.icons({
  'iphone_2x': 'icons/icon-60@2x.png',
  'iphone_3x': 'icons/icon-60@3x.png',
  // More screen sizes and platforms...
});

// Before Meteor 2.6 we had to pass device specific splash screens for iOS, but this behavior was dropped in favor of story board images.
App.launchScreens({
    // iOS
    // For most cases you will only need to use the 'ios_universal' and 'ios_universal_3x'.
    'ios_universal': { src: 'splash/Default@2x.png', srcDarkMode: 'splash/Default@2x~dark.png' }, // (2732x2732) - All @2x devices, if device/mode specific is not declared
    'ios_universal_3x': 'splash/Default@3x.png', // (2208x2208) - All @3x devices, if device/mode specific is not declared

    // If you still want to use a universal splash, but want to fine-tune for the device mode (landscape, portrait), then use the following keys:
    'Default@2x~universal~comany': 'splash/Default@2x~universal~comany.png', // (1278x2732) - All @2x devices in portrait mode.
    'Default@2x~universal~comcom': 'splash/Default@2x~universal~comcom.png', // (1334x750) - All @2x devices in landscape (narrow) mode.
    'Default@3x~universal~anycom': 'splash/Default@3x~universal~anycom.png', // (2208x1242) - All @3x devices in landscape (wide) mode.
    'Default@3x~universal~comany': 'splash/Default@3x~universal~comany.png', // (1242x2208) - All @3x devices in portrait mode.

    // However, if you need to fine tune the splash screens for the device idiom (iPhone, iPad, etc).
    'Default@2x~iphone~anyany': 'splash/Default@2xiphoneanyany.png', // (1334x1334) - iPhone SE/6s/7/8/XR
    'Default@2x~iphone~comany': 'splash/Default@2xiphonecomany.png', // (750x1334) - iPhone SE/6s/7/8/XR - portrait mode
    'Default@2x~iphone~comcom': 'splash/Default@2xiphonecomcom.png', // (1334x750) - iPhone SE/6s/7/8/XR - landscape (narrow) mode
    'Default@3x~iphone~anyany': 'Default@3xiphoneanyany.png', // (2208x2208) - iPhone 6s Plus/7 Plus/8 Plus/X/XS/XS Max
    'Default@3x~iphone~anycom': { src: 'splash/Default@3xiphoneanycom.png', srcDarkMode: 'splash/Default@3xiphoneanycom~dark.png' }, // (2208x1242) - iPhone 6s Plus/7 Plus/8 Plus/X/XS/XS Max - landscape (wide) mode
    'Default@3x~iphone~comany': 'Default@3xiphonecomany.png', // (1242x2208) - iPhone 6s Plus/7 Plus/8 Plus/X/XS/XS Max - portrait mode
    'Default@2x~ipad~anyany': 'Default@2xipadanyany.png', // (2732x2732) - iPad Pro 12.9"/11"/10.5"/9.7"/7.9"
    'Default@2x~ipad~comany': 'Default@2xipadcomany.png', // (1278x2732) - iPad Pro 12.9"/11"/10.5"/9.7"/7.9" - portrait mode

    // Android
    'android_universal': 'splash/android_universal.png', // (320x480)
});

// Set PhoneGap/Cordova preferences.
App.setPreference('BackgroundColor', '0xff0000ff');
App.setPreference('HideKeyboardFormAccessoryBar', true);
App.setPreference('Orientation', 'default');
App.setPreference('Orientation', 'all', 'ios');

// Pass preferences for a particular PhoneGap/Cordova plugin.
App.configurePlugin('com.phonegap.plugins.facebookconnect', {
  APP_ID: '1234567890',
  API_KEY: 'supersecretapikey'
});

// Add custom tags for a particular PhoneGap/Cordova plugin to the end of the
// generated config.xml. 'Universal Links' is shown as an example here.
App.appendToConfig(`
  <universal-links>
    <host name="localhost:3000" />
  </universal-links>
`);
```

<ApiBox name="App.info" />
<ApiBox name="App.setPreference" />
<ApiBox name="App.accessRule" />

For example this Cordova whitelist syntax:

```xml
<access origin="https://www.google-analytics.com" />
<allow-navigation href="https://example.com" />
```

is equivalent to:

```js
App.accessRule('https://www.google-analytics.com');
App.accessRule('https://example.com', { type: 'navigation' });
```

<ApiBox name="App.configurePlugin" />

> Note: When using `App.configurePlugin` to re-configure a plugin which has been previously configured, the changes may not be reflected without manually clearing the existing Cordova build.  To clear the existing Cordova build, remove the `.meteor/local/cordova-build` directory and re-build the application using either `meteor run` or `meteor build`.

<ApiBox name="App.icons" />
<ApiBox name="App.launchScreens" />
<ApiBox name="App.appendToConfig" />
<ApiBox name="App.addResourceFile" />

> Note: The resource file is copied in two steps : from the **src** of your meteor project to the root of the cordova project, then to the **target**

---

---
url: /about/modern-build-stack.md
---
# Modern Build Stack

The Meteor bundler is made up of several key components that enhance your experience both during development and when deploying to production. These include:

- **Transpiler**: Responsible for converting each file into a syntax compatible across different browsers and runtime environments.
- **Bundler**: Handles discovering your app’s files and dependencies, including Meteor packages and core modules, then links them into production-ready bundles. It also applies optimizations to produce lighter builds and faster processes.
- **Dev Server**: During development, it watches for file changes, and supports fast feedback via HMR, bundle visualizers, debug tools, and more. At runtime, it provides a full-featured server environment with support for SSR and modern APIs powered by Express.

To improve the development and deployment experience for all Meteor projects, we’re revamping each of these components with a focus on better performance, smarter tooling, and leaner bundle sizes:

- **Modern Transpiler**: Meteor is adopting **SWC** as a faster alternative to Babel.
- **Modern Bundler**: A new bundler will handle only your app’s code, supporting tree-shaking, popular plugins, and better features for both development and production. Meanwhile, Meteor’s core bundler will continue handling Meteor-specific tasks, such as compiling Atmosphere packages, with optimized workflows.
- **Modern Dev Server**: The dev server remains a core part of Meteor, now with ongoing improvements in performance and developer features. A new bundler will complement the dev server, providing additional enhancements.

## Quick start

Start using the new build stack by creating a Meteor app, or add this to your `package.json` in an existing one:

```json
"meteor": {
  "modern": true
}
```

With this configuration, you enable all improvements from the modern build stack in your Meteor app.

See the following sections to learn about each component and its settings:

- [Transpiler](modern-build-stack/transpiler-swc.md)
- [Bundler](modern-build-stack/bundler.md)
- [Dev Server](modern-build-stack/dev-server.md)

---

---
url: /packages/modern-browsers.md
---
# Modern-browsers

API for defining the boundary between modern and legacy JavaScript clients.

You can use this package to define the minimum browser versions for which
a browser engine will be considered modern. All browsers that do not meet
the threshold will receive the legacy bundle. This way you can easily keep
on using modern features that you need.

You can read more about this in [Meteor 1.7 announcement blog](https://blog.meteor.com/meteor-1-7-and-the-evergreen-dream-a8c1270b0901).

<ApiBox name="ModernBrowsers.isModern" isDefaultImport/>

<ApiBox name="ModernBrowsers.setMinimumBrowserVersions" isDefaultImport/>

<ApiBox name="ModernBrowsers.getMinimumBrowserVersions" isDefaultImport/>

<ApiBox name="ModernBrowsers.calculateHashOfMinimumVersions" isDefaultImport/>

## Configure Unknown Browsers to default to Modern

Browsers not explicitly listed in `setMinimumBrowserVersions` are considered "legacy" by default.

To change this and treat unknown browsers as "modern," update the relevant option in your settings file:

```js
Meteor.settings.packages = {
  "modern-browsers": {
    unknownBrowsersAssumedModern: true,
  },
};
```

---

---
url: /packages/modules.md
---
# Modules

This document explains the usage and key features of the module system used by Meteor.

> Meteor 1.2 introduced support for [many new ECMAScript 2015 features](https://github.com/meteor/meteor/blob/devel/packages/ecmascript/README.md#supported-es2015-features), one of the most notable omissions was [ES2015 `import` and `export` syntax](http://exploringjs.com/es6/ch_modules.html).

> Meteor 1.3 filled the gap with a fully standards-compliant module system that works on both the client and the server.

> Meteor 1.7 introduced `meteor.mainModule` and `meteor.testModule` to `package.json` so Meteor doesn't need special folders anymore for js resources. Also doesn't need to eager load js resources.

By design, `meteor.mainModule` only affect js resources. For non-js resources, there are still some things that can only be done within imports:

- only stylesheets within imports can be dynamically imported
- you can only control the load order of stylesheets by importing them in js if the stylesheets are within imports

Any non-js resource outside of imports (and some other special folders) are still eagerly loaded.

> You can read more about these differences in this [comment](https://github.com/meteor/meteor/pull/11381#issuecomment-818816052).

## Enabling modules

It is installed by default for all new apps and packages. Nevertheless, the `modules` package is totally optional.

If you want to add it to existent apps or packages:

For apps, this is as easy as `meteor add modules`, or (even better) `meteor add ecmascript`, since the `ecmascript` package *implies* the `modules` package.

For packages, you can enable `modules` by adding `api.use('modules')` to the `Package.onUse` or `Package.onTest` sections of your `package.js` file.

Now, you might be wondering what good the `modules` package is without the `ecmascript` package, since `ecmascript` enables `import` and `export` syntax. By itself, the `modules` package provides the CommonJS `require` and `exports` primitives that may be familiar if you’ve ever written Node code, and the `ecmascript` package simply compiles `import` and `export` statements to CommonJS. The `require` and `export` primitives also allow Node modules to run within Meteor application code without modification. Furthermore, keeping `modules` separate allows us to use `require` and `exports` in places where using `ecmascript` is tricky, such as the implementation of the `ecmascript` package itself.

While the `modules` package is useful by itself, we very much encourage using the `ecmascript` package (and thus `import` and `export`) instead of using `require` and `exports` directly. If you need convincing, here's a [presentation](http://benjamn.github.io/empirenode-2015) that explains the differences.

## Basic syntax

### ES2015

Although there are a number of different variations of `import` and `export` syntax, this section describes the essential forms that everyone should know.

First, you can `export` any named declaration on the same line where it was declared:

```js
// exporter.js
export var a = ...;
export let b = ...;
export const c = ...;
export function d() { ... }
export function* e() { ... }
export class F { ... }
```

These declarations make the variables `a`, `b`, `c` (and so on) available not only within the scope of the `exporter.js` module, but also to other modules that `import` from `exporter.js`.

If you prefer, you can `export` variables by name, rather than prefixing their declarations with the `export` keyword:

```js
// exporter.js
function g() { ... }
let h = g();

// At the end of the file
export { g, h };
```

All of these exports are *named*, which means other modules can import them using those names:

```js
// importer.js
import { a, c, F, h } from './exporter';
new F(a, c).method(h);
```

If you’d rather use different names, you’ll be glad to know `export` and `import` statements can rename their arguments:

```js
// exporter.js
export { g as x };
g(); // Same as calling `y()` in importer.js
```

```js
// importer.js
import { x as y } from './exporter';
y(); // Same as calling `g()` in exporter.js
```

As with CommonJS `module.exports`, it is possible to define a single *default* export:

```js
// exporter.js
export default any.arbitrary(expression);
```

This default export may then be imported without curly braces, using any name the importing module chooses:

```js
// importer.js
import Value from './exporter';
// Value is identical to the exported expression
```

Unlike CommonJS `module.exports`, the use of default exports does not prevent the simultaneous use of named exports. Here is how you can combine them:

```js
// importer.js
import Value, { a, F } from './exporter';
```

In fact, the default export is conceptually just another named export whose name happens to be "default":

```js
// importer.js
import { default as Value, a, F } from './exporter';
```

These examples should get you started with `import` and `export` syntax. For further reading, here is a very detailed [explanation](http://www.2ality.com/2014/09/es6-modules-final.html) by [Axel Rauschmayer](https://twitter.com/rauschma) of every variation of `import` and `export` syntax.

### CommonJS

You don’t need to use the `ecmascript` package or ES2015 syntax in order to use modules. Just like Node.js in the pre-ES2015 days, you can use `require` and `module.exports`—that’s what the `import` and `export` statements are compiling into, anyway.

ES2015 `import` lines like these:

```js
import { AccountsTemplates } from 'meteor/useraccounts:core';
import '../imports/startup/client/routes.js';
```

can be written with CommonJS like this:

```js
var UserAccountsCore = require('meteor/useraccounts:core');
require('../imports/startup/client/routes.js');
```

and you can access `AccountsTemplates` via `UserAccountsCore.AccountsTemplates`.

Note that files don’t need a `module.exports` if they’re required like `routes.js` is in this example, without assignment to any variable. The code in `routes.js` will simply be included and executed in place of the above `require` statement.

ES2015 `export` statements like these:

```js
export const insert = new ValidatedMethod({ ... });
export default incompleteCountDenormalizer;
```

can be rewritten to use CommonJS `module.exports`:

```js
module.exports.insert = new ValidatedMethod({ ... });
module.exports.default = incompleteCountDenormalizer;
```

You can also simply write `exports` instead of `module.exports` if you prefer. If you need to `require` from an ES2015 module with a `default` export, you can access the export with `require('package').default`.

There is a case where you might *need* to use CommonJS, even if your project has the `ecmascript` package: if you want to conditionally include a module. `import` statements must be at top-level scope, so they cannot be within an `if` block. If you’re writing a common file, loaded on both client and server, you might want to import a module in only one or the other environment:

```js
if (Meteor.isClient) {
  require('./client-only-file.js');
}
```

Note that dynamic calls to `require()` (where the name being required can change at runtime) cannot be analyzed correctly and may result in broken client bundles. This is also discussed in [the guide](http://guide.meteor.com/structure.html#using-require).

### CoffeeScript

CoffeeScript has been a first-class supported language since Meteor’s early days. Even though today we recommend ES2015, we still intend to support CoffeeScript fully.

As of CoffeeScript 1.11.0, [CoffeeScript supports `import` and `export` statements natively](http://coffeescript.org/#modules). Make sure you are using the latest version of the [CoffeeScript package](https://atmospherejs.com/meteor/coffeescript) in your project to get this support. New projects created today will get this version with `meteor add coffeescript`. Make sure you don’t forget to include the `ecmascript` and `modules` packages: `meteor add ecmascript`. (The `modules` package is implied by `ecmascript`.)

CoffeeScript `import` syntax is nearly identical to the ES2015 syntax you see above:

```coffee
import { Meteor } from 'meteor/meteor'
import SimpleSchema from 'simpl-schema'
import { Lists } from './lists.coffee'
```

You can also use traditional CommonJS syntax with CoffeeScript.

## Modular application structure

Use in your application `package.json` file the section `meteor`.

> This is available since Meteor 1.7

```json
{
  "meteor": {
    "mainModule": {
      "client": "client/main.js",
      "server": "server/main.js"
    }
  }
}
```

When specified, these entry points will define in which files Meteor is going to start the evaluation process for each architecture (client and server).

This way Meteor is not going to eager load any other js files.

There is also an architecture for the `legacy` client, which is useful if you want to load polyfills or other code for old browsers before importing the main module for the modern client.

In addition to `meteor.mainModule`, the `meteor` section of `package.json` may also specify `meteor.testModule` to control which test modules are loaded by `meteor test` or `meteor test --full-app`:

```json
{
  "meteor": {
    "mainModule": {
      "client": "client/main.js",
      "server": "server/main.js"
    },
    "testModule": "tests.js"
  }
}
```

If your client and server test files are different, you can expand the testModule configuration using the same syntax as mainModule:

```json
{
  "meteor": {
    "mainModule": {
      "client": "client/main.js",
      "server": "server/main.js"
    },
    "testModule": {
      "client": "client/tests.js",
      "server": "server/tests.js"
    }
  }
}
```

The same test module will be loaded whether or not you use the `--full-app` option.

Any tests that need to detect `--full-app` should check `Meteor.isAppTest`.

The module(s) specified by `meteor.testModule` can import other test modules at runtime, so you can still distribute test files across your codebase; just make sure you import the ones you want to run.

To disable eager loading of modules on a given architecture, simply provide a mainModule value of false:

```json
{
  "meteor": {
    "mainModule": {
      "client": false,
      "server": "server/main.js"
    }
  }
}
```

### Historic behind Modular application structure

If you want to understand how Meteor works without `meteor.mainModule` on `package.json` keep reading this section, but we don't recommend this approach anymore.

Before the release of Meteor 1.3, the only way to share values between files in an application was to assign them to global variables or communicate through shared variables like `Session` (variables which, while not technically global, sure do feel syntactically identical to global variables). With the introduction of modules, one module can refer precisely to the exports of any other specific module, so global variables are no longer necessary.

If you are familiar with modules in Node, you might expect modules not to be evaluated until the first time you import them. However, because earlier versions of Meteor evaluated all of your code when the application started, and we care about backwards compatibility, eager evaluation is still the default behavior.

If you would like a module to be evaluated *lazily* (in other words: on demand, the first time you import it, just like Node does it), then you should put that module in an `imports/` directory (anywhere in your app, not just the root directory), and include that directory when you import the module: `import {stuff} from './imports/lazy'`. Note: files contained by `node_modules/` directories will also be evaluated lazily (more on that below).

## Modular package structure

If you are a package author, in addition to putting `api.use('modules')` or `api.use('ecmascript')` in the `Package.onUse` section of your `package.js` file, you can also use a new API called `api.mainModule` to specify the main entry point for your package:

```js
Package.describe({
  name: 'my-modular-package'
});

Npm.depends({
  moment: '2.10.6'
});

Package.onUse((api) => {
  api.use('modules');
  api.mainModule('server.js', 'server');
  api.mainModule('client.js', 'client');
  api.export('Foo');
});
```

Now `server.js` and `client.js` can import other files from the package source directory, even if those files have not been added using the `api.addFiles` function.

When you use `api.mainModule`, the exports of the main module are exposed globally as `Package['my-modular-package']`, along with any symbols exported by `api.export`, and thus become available to any code that imports the package. In other words, the main module gets to decide what value of `Foo` will be exported by `api.export`, as well as providing other properties that can be explicitly imported from the package:

```js
// In an application that uses 'my-modular-package':
import { Foo as ExplicitFoo, bar } from 'meteor/my-modular-package';
console.log(Foo); // Auto-imported because of `api.export`.
console.log(ExplicitFoo); // Explicitly imported, but identical to `Foo`.
console.log(bar); // Exported by server.js or client.js, but not auto-imported.
```

Note that the `import` is `from 'meteor/my-modular-package'`, not `from 'my-modular-package'`. Meteor package identifier strings must include the prefix `meteor/...` to disambiguate them from npm packages.

Finally, since this package is using the new `modules` package, and the package `Npm.depends` on the "moment" npm package, modules within the package can `import moment from 'moment'` on both the client and the server. This is great news, because previous versions of Meteor allowed npm imports only on the server, via `Npm.require`.

### Lazy loading modules from a package

Packages can also specify a *lazy* main module:

```js
Package.onUse(function (api) {
  api.mainModule("client.js", "client", { lazy: true });
});
```

This means the `client.js` module will not be evaluated during app
startup unless/until another module imports it, and will not even be
included in the client bundle if no importing code is found.

To import a method named `exportedPackageMethod`, simply:

```js
import { exportedPackageMethod } from "meteor/<package name>";
```

> Note: Packages with `lazy` main modules cannot use `api.export` to export global
symbols to other packages/apps.  Also, prior to Meteor 1.4.4.2 it is necessary to explicitly name the file containing the module: `import "meteor/<package name>/client.js"`.


## Local `node_modules`

Before Meteor 1.3, the contents of `node_modules` directories in Meteor application code were completely ignored. When you enable `modules`, those useless `node_modules` directories suddenly become infinitely more useful:

```sh
meteor create modular-app
cd modular-app
mkdir node_modules
npm install moment
echo "import moment from 'moment';" >> modular-app.js
echo 'console.log(moment().calendar());' >> modular-app.js
meteor
```

When you run this app, the `moment` library will be imported on both the client and the server, and both consoles will log output similar to: `Today at 7:51 PM`. Our hope is that the possibility of installing Node modules directly within an app will reduce the need for npm wrapper packages such as https://atmospherejs.com/momentjs/moment.

A version of the `npm` command comes bundled with every Meteor installation, and (as of Meteor 1.3) it's quite easy to use: `meteor npm ...` is synonymous with `npm ...`, so `meteor npm install moment` will work in the example above. (Likewise, if you don't have a version of `node` installed, or you want to be sure you're using the exact same version of `node` that Meteor uses, `meteor node ...` is a convenient shortcut.) That said, you can use any version of `npm` that you happen to have available. Meteor's module system only cares about the files installed by `npm`, not the details of how `npm` installs those files.

## File load order

Before Meteor 1.3, the order in which application files were evaluated was dictated by a set of rules described in the [Application Structure - Default file load order](http://guide.meteor.com/structure.html#load-order) section of the Meteor Guide. These rules could become frustrating when one file depended on a variable defined by another file, particularly when the first file was evaluated after the second file.

Thanks to modules, any load-order dependency you might imagine can be resolved by adding an `import` statement. So if `a.js` loads before `b.js` because of their file names, but `a.js` needs something defined by `b.js`, then `a.js` can simply `import` that value from `b.js`:

```js
// a.js
import { bThing } from './b';
console.log(bThing, 'in a.js');
```

```js
// b.js
export var bThing = 'a thing defined in b.js';
console.log(bThing, 'in b.js');
```

Sometimes a module doesn’t actually need to import anything from another module, but you still want to be sure the other module gets evaluated first. In such situations, you can use an even simpler `import` syntax:

```js
// c.js
import './a';
console.log('in c.js');
```

No matter which of these modules is imported first, the order of the `console.log` calls will always be:

```js
console.log(bThing, 'in b.js');
console.log(bThing, 'in a.js');
console.log('in c.js');
```

---

---
url: /community-packages/mongo-transactions.md
---
# Mongo-transactions

- `Who maintains the package` – [Jam](https://github.com/jamauro)

[[toc]]

## What is this package?

`jam:mongo-transactions` enables an easy way to work with Mongo Transactions in Meteor apps. Here are a few of the benefits:

* Write with the standard Meteor collection methods you're accustomed to. You don't need to worry about using `rawCollection()`, though if you need a particular `rawCollection()` method, you can still use it.
* You don't need to worry about passing `session` around. This package takes care of that for you.
* Because it's a low-level solution, ID generation works as expected.
* Works out-of-the-box with other packages that automatically validate on DB writes, like `jam:easy-schema` and `aldeed:collection2`.
* One simple API to use. Mongo has made things complicated with two APIs for Transactions, the Callback API and the Core API. This package defaults to using the Callback API as recommended by Mongo, but allows you to use the Core API by passing in `autoRetry: false`.
* Can be used isomorphically.
* Compatible with Meteor 2.8.1 and up, including support for Meteor 3.0+

> **Important**: This package expects that you'll use the promise-based `*Async` Meteor collection methods introduced in `v2.8.1` though it will technically work with the older syntax without the `*Async` suffix as long as you don't use callbacks. It does **not** cover using callbacks with Meteor collection methods.

## How to download it?
Add the package to your app
```bash
meteor add jam:mongo-transactions
```
### Sources

* [GitHub repository](https://github.com/jamauro/mongo-transactions)

## How to use it?

### Create a Transaction

> **Note**: there's no need to pass `session` into the `*Async` collection methods. This package handles that for you.

```js
import { Mongo } from 'meteor/mongo';

async function purchase(purchaseData) {
  try {
    const { invoiceId } = await Mongo.withTransaction(async () => {
      const invoiceId = await Invoices.insertAsync(purchaseData);
      const changeQuantity = await Items.updateAsync(purchaseData.itemId, { $set: {...} });
      return { invoiceId, changeQuantity } // you can return whatever you'd like
    });
    return invoiceId;
  } catch (error) {
    // something went wrong with the transaction and it could not be automatically retried
    // handle the error as you see fit
  }
}
```

### Passing Transaction options
If you want to customize how the Transaction runs, pass in the Transaction options as the second argument, for example:
```js
await Mongo.withTransaction(async () => {
  ...
}, { writeConcern: { w: 1 } });
```
Refer to the [Mongo Node API docs](https://mongodb.github.io/node-mongodb-native/6.3/interfaces/TransactionOptions.html) for more information about Transaction options.

### Preventing automatic retries if the Transaction fails
Most of the time, you'll want the default behavior where the Transaction is automatically retried for a `TransientTransactionError` or `UnknownTransactionCommitResult` commit error. But if you don't want that behavior, simply pass in `{ autoRetry: false }` like this:

```js
await Mongo.withTransaction(async () => {
  ...
}, { autoRetry: false });
```

Setting `{ autoRetry: false }`, means the Transactions Core API will be used rather than the Callback API and you'll be responsible for handling all errors. You can read more about the differences in the [Mongo Docs](https://www.mongodb.com/docs/manual/core/transactions-in-applications/).

### Determine if you're in a Transaction
To determine if the code is currently running in a Transaction, use:
```js
Mongo.inTransaction(); // returns true or false
```

### Using Isomorphically for Optimistic UI
You can write `Mongo.withTransaction` and `Mongo.inTransaction` isomorphically for Optimistic UI however note that the Transaction will only truly be performed on the server.

As with any isomorphic code, you should be aware that it may fail because the operation can't succeed on the client but will succeed on the server. For example, let's say you're using `.find` within the Transaction and Minimongo on the client doesn't have that particular data, the client will fail but the server should still succeed. You can wrap specific server-only code with `if (Meteor.isServer)`, but in these cases, you'll likely want to avoid isomorphic code and make sure the entire Transaction code only runs on the server.

## Using Mongo Atlas as your DB?
> **Important**: In my experience, you must use a paid tier for Transactions to work as expected with Meteor. The free tier would not tail the oplog for Transactions. So if you're trying this out in production, be sure to use a paid tier.

---

---
url: /packages/oauth-encryption.md
---
# OAuth Encryption
Encrypts sensitive login secrets stored in the database such as a
login service's application secret key and users' access tokens.


## Generating a Key

The encryption key is 16 bytes, encoded in Base64.

To generate a key:

```bash
$ meteor node -e 'console.log(require("crypto").randomBytes(16).toString("base64"))'
```


## Using oauth-encryption with accounts

On the server only, use the `oauthSecretKey` option to `Accounts.config`:

```js
Accounts.config({ oauthSecretKey: 'onsqJ+1e4iGFlV0nhZYobg==' });
```

This call to `Accounts.config` should be made at load time (place at
the top level of your source file), not called from inside of a
`Meteor.startup` block.

To avoid storing the secret key in your application's source code, you
can use [`Meteor.settings`](../api/meteor.md#Meteor-settings):

```js
Accounts.config({ oauthSecretKey: Meteor.settings.oauthSecretKey });
```


## Migrating unencrypted user tokens

This example for Twitter shows how existing unencrypted user tokens
can be encrypted.  The query finds user documents which have a Twitter
access token but not the `algorithm` field which is created when the
token is encrypted.  The relevant fields in the service data are then
encrypted.

```js
const cursor = Meteor.users.find({
  $and: [
    { 'services.twitter.accessToken': { $exists: true } },
    { 'services.twitter.accessToken.algorithm': { $exists: false } }
  ]
});

cursor.forEach((userDoc) => {
  const set = {};

  ['accessToken', 'accessTokenSecret', 'refreshToken'].forEach((field) => {
    const plaintext = userDoc.services.twitter[field];

    if (!_.isString(plaintext)) {
      return;
    }

    set[`services.twitter.${field}`] = OAuthEncryption.seal(
      plaintext,
      userDoc._id
    );
  });

  Meteor.users.update(userDoc._id, { $set: set });
});
```

## Using oauth-encryption without accounts

If you're using the oauth packages directly instead of through the
Meteor accounts packages, you can load the OAuth encryption key
directly using `OAuthEncryption.loadKey`:

```js
OAuthEncryption.loadKey('onsqJ+1e4iGFlV0nhZYobg==');
```

If you call `retrieveCredential` (such as
`Twitter.retrieveCredential`) as part of your process, you'll find
when using oauth-encryption that the sensitive service data fields
will be encrypted.

You can decrypt them using `OAuth.openSecrets`:

```js
const credentials = Twitter.retrieveCredential(token);
const serviceData = OAuth.openSecrets(credentials.serviceData);
```

## Using oauth-encryption on Windows

This package depends on [npm-node-aes-gcm](https://github.com/meteor/meteor/tree/devel/packages/non-core/npm-node-aes-gcm), which requires you to have OpenSSL installed on your system to run. To install OpenSSL on Windows, use one of the binaries on [this page](http://slproweb.com/products/Win32OpenSSL.html). Don't forget to install the Visual Studio 2008 redistributables if you don't have them yet.

---

---
url: /community-packages/offline.md
---
# Offline

- `Who maintains the package` – [Jam](https://github.com/jamauro)

[[toc]]

## What is this package?

Offline is an easy way to give your Meteor app offline capabilities and make it feel instant. Its key features are:

* Offline access – Saves Minimongo data in IndexedDB for offline access and instant reloading when reconnected.
* Automatic syncing – Syncs offline actions automatically once reconnected.
* Cross-Tab syncing – Keeps changes in sync across multiple tabs while offline.
* Seamless reconciliation – Reconciles data with the server when reconnected.

## How to download it?

Add the package to your app
```bash
meteor add jam:offline
```

### Sources

* [GitHub repository](https://github.com/jamauro/offline)

## How to use it?

### Keeping data offline
By default, offline data will be kept for all collections using the global defaults in [Offline.config](#configuring-optional) without any configuration needed. To change the data that is kept for a specific collection, define `.keep` for the collection in a file that's imported on both client and server.

If you don't want all collections to be kept, be sure to configure `keepAll: false`. See [Configuring](#configuring-optional) for more details.

`.keep` accepts a `filter`, and `sort` and `limit` options much like a `.find`. For example:

```js
const Todos = new Mongo.Collection('todos');
Todos.keep({ $or: [ { isPrivate: { $ne: true } }, { owner: Meteor.userId() } ]}, { limit: 200 }) // this will override any global defaults
```

If you have specific restrictions on what should be kept, e.g. permissions to a document like in the example above, these should be included in the `.keep` filter. Be aware that when the user comes back online, this filter will be used to reconcile with the server. In general, it's recommended that you only use the `.keep` filter where absolutely needed.

**`Note`**: You can use `Meteor.userId()` in your `.keep` filter if needed.

### Clearing offline data for a specific collection
If you ever need to clear offline data for a specific collection, call `clear`:

```js
Todos.clear();
```

### Clearing all offline data
If you ever need to completely clear all offline data, you can use `clearAll`:

```js
import { clearAll } from 'meteor/jam:offline';

clearAll();
```

### Queuing methods when offline
When a user is offline, you can queue any actions they take for replay when they come back online using `queueMethod`:

```js
import { queueMethod } from 'meteor/jam:offline';

if (!Meteor.status().connected) { // check that the user is offline
  queueMethod(name, arg1, arg2...) // the arguments should be the same form that you'd use for Meteor.callAsync
}
```
where name is the method's name and the arguments are what the method expects. You'll still want to call the method when offline and it's recommended that you use [Meteor.applyAsync](https://docs.meteor.com/api/methods.html#Meteor-applyAsync) with the option `noRetry: true` to avoid using Meteor's built-in retry mechanism since we'll be handling replay separately. For this to work as intended, the methods that you call should be isomorphic so that they're availble to the client.

**`Note`**: If you're using [jam:method](https://github.com/jamauro/method), queuing methods for replay is handled automatically for you. 🎉

**`Note`**: When queuing methods than involve an `insert` to a collection, make sure the method returns the new document's `_id`. By doing this, you ensure that any subsequent changes made to the document while still offline are handled correctly.

### Auto syncing
By default, the package auto syncs when the user comes back online. This includes:

1. Replaying queued methods
2. Removing offline data for each collection that no longer belongs because it doesn't match the configured `filter` or the collection's `.keep` filter

The benefit of this sequential-replay syncing strategy is any business logic contained in your methods will be respected. For example, if a user makes changes to a document but loses permission to it while offline, when they come back online, that permission will be respected when the attempted replay occurs. If there are any errors during auto sync, they will be made available in the `handleSyncErrors` function. You can use it to make your user aware that their changes failed. See [Configuring](#configuring-optional) for more details on how to customize this.

When reconciling with the server, this package assumes that you'll use one of the following mechanisms when removing documents:

1. `archive`. With this mechanism, when a document is removed from its original collection, it's placed in an `archive` collection. If your app doesn't already employ an archive mechanism, check out the [jam:archive](https://github.com/jamauro/archive) package to make this easy. By simply adding the `jam:archive` package, you won't need to do any further configuration.

Otherwise, be sure to check out the `archive` configuration options. **`Note`**: it's assumed that the data in your `archive` collection will include the original document data at the root level, e.g.:
```js
{
  _id, // auto-generated by Meteor as with other collection _ids
  _collection, // the name of the collection, e.g. 'todos', that the doc belonged to originally
  archivedAt, // the timestamp when the document was removed from its original collection and inserted into the archive
  id, // the original doc _id renamed to prevent conflict with the auto-generated one above. when restored, it will be renamed back to _id automatically by this package
  /*
  ...rest of original doc
  */
}
```

2. `soft delete`. If your app doesn't already employ a soft delete mechanism, check out the [jam:soft-delete](https://github.com/jamauro/soft-delete) package to make this easy. If you're using something other than `deleted` as the flag name for your soft deletes, be sure to configure `filter` appropriately. See [Configuring](#configuring-optional) for more details.

To know when an auto sync is processing, you can use `isSyncing()` which is a reactive variable.

```js
import { isSyncing } from 'meteor/jam:offline';

isSyncing(); // you can wrap this in a Tracker.autorun to detect when it changes
```

If you prefer not to have the behavior provided by auto sync, be sure to configure `autoSync: false`. When `autoSync` is false, Minimongo data from when the user disconnects will be kept offline so you still benefit from faster reloads on reconnects but you'll be responsible for designing any syncing logic needed. If the user hasn't refreshed the page and has a brief disconnect / reconnect, then you'll still benefit from Meteor's built-in retry mechanism for methods. But if they do refresh or exit the app and come back later, any actions performed while offline will be lost.

I think it would be great to have better support for custom syncing. If you have ideas here, let me know. At this time, I'm not sure what primitives would be most useful for you.

## Configuring (optional)
If you like the defaults, then you won't need to configure anything. But there is some flexibility in how you use this package. You may want to pay special attention to `filter` and `handleSyncErrors` to customize the experience for your users.

Here are the global defaults:
```js
const config = {
  filter: /** {} or { deleted: false } **/ // filter the documents to keep across all collections. if you're not using jam:archive or don't have the archive config below set, it will assume you're using soft deletes.
  sort: { updatedAt: -1 }, // keep the most recent documents assuming you have an updatedAt on each doc. if you're using a different field name for timestamps, you'll want to change this.
  limit: 100, // limit offline documents to a max of 100 for each collection
  keepAll: true, // keep data for offline use for all collections using the global filter, sort, limit. to keep data for only certain collections, set this to false and then use collection.keep() for the collections you want to use offline.
  autoSync: true, // auto sync changes made offline when the user comes back online
  handleSyncErrors: async ({ replayErrors, keepErrors }) => {
    if (replayErrors) console.error('replay', replayErrors); // if there are errors when the Meteor methods are replayed, they will be in array here with the name of the method, the method's args, and the error itself. you can use it to alert your user, logging purposes, etc.

    if (keepErrors) { // when syncing, if you're using a .keep filter or you have a global filter in the config that isn't an empty object, and there are errors reconciling with the server, they will be in an array here with the name of the collection and the error itself. you can customize how you handle these. by default, we clear the offline database for the collection since it could have stale data and reload the page.
      await Promise.allSettled(keepErrors.map(({ name }) => clear(name)));
      console.error('keep', keepErrors)
    }

    return;
  },
  ...(Archive && { // Archive is provided by jam:archive. if you're using a different archive mechanism, you'll need to configure these manually
    archive: {
      name: 'archives',
      collectionKey: '_collection',
      primaryIdKey: 'id',
      timestampKey: 'archivedAt'
    }
  })
};
````

To change the global defaults, use:
```js
// put this in a file that's imported on both the client and server
import { Offline } from 'meteor/jam:offline';

Offline.configure({
  // ... change the defaults here ... //
});
```

## Adding a service worker
You'll likely want to add a service worker as well to cache your HTML, CSS, Javascript so your users can continue to use the app offline, even if they accidentally click refresh.

Follow these [instructions](https://github.com/jamauro/pwa-kit) to add a service worker and go even further by making it a PWA (progressive web app).

---

---
url: /api/package.md
---
# Package.js

A package is a directory containing a package.js file, which
contains roughly three major sections: a basic description, a package
definition, and a test definition. By default, the directory name is the name of
the package.

The `package.js` file below is an example of how to use the packaging API. The
rest of this section will explain the specific API commands in greater detail.

```js
// Information about this package:
Package.describe({
  // Short two-sentence summary
  summary: 'What this does',
  // Version number
  version: '1.0.0',
  // Optional, default is package directory name
  name: 'username:package-name',
  // Optional GitHub URL to your source repository
  git: 'https://github.com/something/something.git'
});

// This defines your actual package:
Package.onUse((api) => {
  // If no version is specified for an `api.use` dependency, use the one defined
  // in Meteor 1.12.1.
  api.versionsFrom('1.12.1');
  // Use the `underscore` package, but only on the server. Version not
  // specified, so it will be as of Meteor 1.12.1.
  api.use('underscore', 'server');
  // Use `ostrio:flow-router-extra`, version 3.9.0 or newer.
  api.use('ostrio:flow-router-extra@3.9.0');
  // Give users of this package access to active-route's JavaScript helpers.
  api.imply('zimme:active-route@2.3.2')
  // Export the object `Email` to packages or apps that use this package.
  api.export('Email', 'server');
  // Specify the source code for the package.
  api.addFiles('email.js', 'server');
  // When using `ecmascript` or `modules` packages, you can use this instead of
  // `api.export` and `api.addFiles`.
  api.mainModule('email.js', 'server');
});

// This defines the tests for the package:
Package.onTest((api) => {
  // Sets up a dependency on this package.
  api.use('username:package-name');
  // Use the Mocha test framework.
  api.use('practicalmeteor:mocha@2.4.5_6');
  // Specify the source code for the package tests.
  api.addFiles('email_tests.js', 'server');
});

// This lets you use npm packages in your package:
Npm.depends({
  simplesmtp: '0.3.10',
  'stream-buffers': '0.2.5'
});
```

`api.mainModule` is documented in the [modules](../packages/modules.md#modular-application-structure) section.

Build plugins are created with
[`Package.registerBuildPlugin`](#PackageNamespace-registerBuildPlugin). See the
coffeescript package for an example. Build plugins are fully-fledged Meteor
programs in their own right and have their own namespace, package dependencies,
source files and npm requirements.

> You can use local packages to define custom build plugins
for your app, with one caveat. In published packages, build plugins are already
bundled with their transitive dependencies. So if you want a dependency of a
build plugin to be satisfied by a local package, you must use a local copy of
the package that defines the plugin (even if you make no changes to that
package) so that Meteor will pick up the local dependency.

> In a lifecycle of a package there might come time to end the development for various reasons, or
it gets superseded. In either case Meteor allows you to easily notify the users of the package by
setting the deprecated flag to true: `deprecated: true` in the package description. In addition, you
replace it with a string that tells the users where to find replacement or what to do.

Provide basic package information with `Package.describe(options)`. To publish a
package, you must define `summary` and `version`.

<ApiBox name="PackageNamespace#describe"  instanceName="api"/>

Define dependencies and expose package methods with the
`Package.onUse` handler. This section lets you define what packages your package
depends on, what packages are implied by your package, and what object your
package is exported to.

<ApiBox name="PackageNamespace#onUse"  instanceName="api"/>

<ApiBox name="PackageAPI#versionsFrom" instanceName="api"/>

> Choose Meteor versions carefully. First determine the minimum version of Meteor you need for the API you use in your package.
 This should be based on specific needs of your package like needed the *Async calls, which would require minimum version to be
 at least 2.8. Another example are where packages had a major version bump, for example this has happened with the accounts packages
 in Meteor 2.3. If you want to be backward and forward compatible it is good to include Meteor version before 2.3 and then 2.3.6 in the array.
 A general recommendation for most compatibility for accounts packages (unless you need API that was affected in Meteor 2.3) is to have the following
 array in `versionsFrom`: `['1.12.1', '2.3.6', '2.8.1']`, this gives us the widest range. For general packages you can leave out version `2.3.6`.
 If you want the widest compatibility range it is recommended that the lowest be `1.12.1` and that you also include another
 version near the current version of Meteor.

<ApiBox name="PackageAPI#use" instanceName="api"/>
<ApiBox name="PackageAPI#imply" instanceName="api"/>
<ApiBox name="PackageAPI#export" instanceName="api"/>
<ApiBox name="PackageAPI#addFiles" instanceName="api"/>
<ApiBox name="PackageAPI#addAssets" instanceName="api"/>

Set up your tests with the `Package.onTest` handler, which has an interface
that's parallel to that of the `onUse` handler. The tests will need to depend on
the package that you have just created. For example, if your package is the
`email` package, you have to call `api.use('email')` in order to test the
package.

If you used `meteor create` to set up your package, Meteor will create the
required scaffolding in `package.js`, and you'll only need to add unit test code
in the `_test.js` file that was created.

<ApiBox name="PackageNamespace#onTest"  instanceName="api"/>

Meteor packages can include NPM packages and Cordova plugins by using
`Npm.depends` and `Cordova.depends` in the `package.js` file.

<ApiBox name="PackageNpm#depends"  instanceName="api"/>
<ApiBox name="Npm.require" />
<ApiBox name="PackageCordova#depends"  instanceName="api"/>
<ApiBox name="PackageNamespace#registerBuildPlugin"  instanceName="api"/>


## Options

In some cases we need to offer options in packages where these options are not going to change in runtime.

We prefer to have these options defined in a configuration file instead of using JS code to call specific functions to define options in runtime.

For example, in `quave:collections` package you can force collections to be available only in the server like this:

```json
  "packages": {
    "quave:collections": {
      "isServerOnly": true
    }
  }
```

We encourage every package author to follow this standard to offer options:

1. Use the official Meteor `settings` file
2. Inside the `settings` file read from a `Meteor`.`packages`.`<package name>`.`<your option name>`
   > If it needs to be available in the client follow the same structure inside the `public` key.

You can use [quave:settings](https://github.com/quavedev/settings) package to read options in the format above already merging the private and public options.

This way we avoid having to call a specific code before another specific code in a package as the setting is stored in the settings, and the package can load it when necessary instead of relying on a specific order of calls from the developer in the app code.

> We've started to adopt this standard also in core packages on Meteor 1.10.2.

<ApiBox name="Plugin.registerSourceHandler" true />

## Build Plugins API {#build-plugin-api}

Meteor packages can provide build plugins - programs that integrate with the
build tool Isobuild used to compile and bundle your application.

Starting with Meteor 1.2, the API used to plug into the build process is called
"Build Plugins". There are 3 phases when a package's plugin can run: linting,
compilation and minification. Here is an overview of operations Isobuild
performs on the application and packages source:

1. Gather source files from the app folder or read `package.js` file for a
  package.
2. Lint all source files and print the linting warnings.
3. Compile the source files like CoffeeScript, ES2015, Less, or Templates to plain
  JavaScript and CSS.
4. Link the JavaScript files: wrap them into closures and provide necessary
  package imports.
5. Minify JavaScript and CSS files. Can also include concatenation of all files.

Build plugins fill the phases 2, 3 and 5.

Usually build plugins implement a class that is given a list of files to
process. Commonly, such files have the following methods:

 - `getContentsAsBuffer` - Returns the full contents of the file as a buffer.
 - `getContentsAsString` - Returns the full contents of the file as a string.
 - `getPackageName` - Returns the name of the package or `null` if the file is not in a package.
 - `getPathInPackage` - Returns the relative path of file to the package or app root directory. The returned path always uses forward slashes.
 - `getSourceHash` - Returns a hash string for the file that can be used to implement caching.
 - `getArch` - Returns the architecture that is targeted while processing this file.
 - `getBasename` - Returns the filename of the file.
 - `getDirname` - Returns the directory path relative to the package or app root. The returned path always uses forward slashes.
 - `error` - Call this method to raise a compilation or linting error for the file.


## Linters {#build-plugin-linters}

Linters are programs that check the code for undeclared variables or find code
that doesn't correspond to certain style guidelines. Some of the popular
examples of linters are [JSHint](http://jshint.com/about/) and
[ESLint](http://eslint.org/). Some of the non-JavaScript linter examples include
[CoffeeLint](https://github.com/clutchski/coffeelint) for CoffeeScript and
[CSSLint](http://csslint.net/) for CSS.

To register a linter build plugin in your package, you need to do a couple of
things in your `package.js`:
- depend on the `isobuild:linter-plugin@1.0.0` package
- register a build plugin: `Package.registerBuildPlugin({ name, sources, ... });`
  (see [docs](#PackageNamespace-registerBuildPlugin))

In your build plugin sources, register a Linter Plugin: provide details such as
a name, list of extensions and filenames the plugin will handle and a factory
function that returns an instance of a linter class. Example:

```js
Plugin.registerLinter({
  extensions: ['js'],
  filenames: ['.linterrc']
}, () => new MyLinter);
```

In this example, we register a linter that runs on all `js` files and also reads
a file named `.linterrc` to get a configuration.

The `MyLinter` class should now implement the `processFilesForPackage`
method. The method should accept two arguments: a list of files and an options
object.

```js
class MyLinter {
  processFilesForPackage(files, options) {
    files.forEach((file) => {
      // Lint the file.
      const lint = lintFile(file.getContentsAsString());

      if (lint) {
        // If there are linting errors, output them.
        const { message, line, column } = lint;
        file.error({ message, line, column });
      }
    });
  }
}
```

The globals are passed in the options object so that the linters can omit the
warnings about the package imports that look like global variables.

Each file in the list is an object that has all the methods provided by all
build plugins, described above.

See an example of a linting plugin implemented in Core: [jshint](https://github.com/meteor/meteor/tree/devel/packages/jshint).


## Compilers {#build-plugin-compilers}

Compilers are programs that take the source files and output JavaScript or
CSS. They also can output parts of HTML that is added to the `<head>` tag and
static assets. Examples for the compiler plugins are: CoffeeScript, Babel.js,
JSX compilers, Pug templating compiler and others.

To register a compiler plugin in your package, you need to do the following in
your `package.js` file:
- depend on the `isobuild:compiler-plugin@1.0.0` package
- register a build plugin: `Package.registerBuildPlugin({ name, sources, ... });`
  (see [docs](#PackageNamespace-registerBuildPlugin))

In your build plugin source, register a Compiler Plugin: similar to other types
of build plugins, provide the details, extensions and filenames and a factory
function that returns an instance of the compiler. Ex.:

```js
Plugin.registerCompiler({
  extensions: ['pug', 'tpl.pug'],
  filenames: []
}, () => new PugCompiler);
```

The compiler class must implement the `processFilesForTarget` method that is
given the source files for a target (server or client part of the package/app).

```js
class PugCompiler {
  processFilesForTarget(files) {
    files.forEach((file) => {
      // Process and add the output.
      const output = compilePug(file.getContentsAsString());

      file.addJavaScript({
        data: output,
        path: `${file.getPathInPackage()}.js`
      });
    });
  }
}
```

Besides the common methods available on the input files' class, the following
methods are available:

 - `getExtension` - Returns the extension that matched the compiler plugin. The
   longest prefix is preferred.
 - `getDeclaredExports` - Returns a list of symbols declared as exports in this
   target. The result of `api.export('symbol')` calls in target's control file
   such as package.js.
 - `getDisplayPath` Returns a relative path that can be used to form error
 messages or other display properties. Can be used as an input to a source map.
 - `addStylesheet` - Web targets only. Add a stylesheet to the document. Not
   available for linter build plugins.
 - `addJavaScript` - Add JavaScript code. The code added will only see the
   namespaces imported by this package as runtime dependencies using
   ['api.use'](#PackageAPI-use). If the file being compiled was added with the
   bare flag, the resulting JavaScript won't be wrapped in a closure.
 - `addAsset` - Add a file to serve as-is to the browser or to include on the
   browser, depending on the target. On the web, it will be served at the exact
   path requested. For server targets, it can be retrieved using
   `Assets.getTextAsync` or `Assets.getBinaryAsync`.
 - `addHtml` - Works in web targets only. Add markup to the `head` or `body`
   section of the document.
 - `hmrAvailable` - Returns true if the file can be updated with HMR. Among other things,
   it checks if HMR supports the current architecture and build mode, and that the unibuild
   uses the `hot-module-replacement` package. There are rare situations where `hmrAvailable`
   returns true, but when more information is available later in the build process Meteor
   decides the file can not be updated with HMR.
 - `readAndWatchFileWithHash` - Accepts an absolute path, and returns { contents, hash }
    Makes sure Meteor watches the file so any changes to it will trigger a rebuild

Meteor implements a couple of compilers as Core packages, good examples would be
the
[Blaze templating](https://github.com/meteor/meteor/tree/devel/packages/templating)
package and the
[ecmascript](https://github.com/meteor/meteor/tree/devel/packages/ecmascript)
package (compiles ES2015+ to JavaScript that can run in the browsers).

## Minifiers {#build-plugin-minifiers}

Minifiers run last after the sources has been compiled and JavaScript code has
been linked. Minifiers are only ran for the client programs (`web.browser` and
`web.cordova`).

There are two types of minifiers one can add: a minifier processing JavaScript
(registered extensions: `['js']`) and a minifier processing CSS (extensions:
`['css']`).

To register a minifier plugin in your package, add the following in your
`package.js` file:
- depend on `isobuild:minifier-plugin@1.0.0` package
- register a build plugin: `Package.registerBuildPlugin({ name, sources, ... });`
  (see [docs](#PackageNamespace-registerBuildPlugin))

In your build plugin source, register a Minifier Plugin. Similar to Linter and
Compiler plugin, specify the interested extensions (`css` or `js`). The factory
function returns an instance of the minifier class.

```js
Plugin.registerMinifier({
  extensions: ['js']
}, () => new UglifyJsMinifier);
```

The minifier class must implement the method `processFilesForBundle`. The first
argument is a list of processed files and the options object specifies if the
minifier is ran in production mode or development mode.

::: info
This method can be asynchronous. If it returns a Promise, the build process will
wait for it to resolve before continuing.
:::

```js
class UglifyJsMinifier {
  processFilesForBundle(files, options) {
    const { minifyMode } = options;

    if (minifyMode === 'development') {
      // Don't minify in development.
      file.forEach((file) => {
        file.addJavaScript({
          data: file.getContentsAsBuffer(),
          sourceMap: file.getSourceMap(),
          path: file.getPathInBundle()
        });
      });

      return;
    }

    // Minify in production.
    files.forEach((file) => {
      file.addJavaScript({
        data: uglifyjs.minify(file.getContentsAsBuffer()),
        path: file.getPathInBundle()
      });
    });
  }
}
```

In this example, we re-add the same files in the development mode to avoid
unnecessary work and then we minify the files in production mode.

Besides the common input files' methods, these methods are available:
- `getPathInBundle` - returns a path of the processed file in the bundle.
- `getSourcePath` - returns absolute path of the input file if available, or null.
- `getSourceMap` - returns the source-map for the processed file if there is such.
- `addJavaScript` - same as compilers
- `addStylesheet` - same as compilers
- `readAndWatchFileWithHash` - only available for css minifiers. Same as compilers.

Right now, Meteor Core ships with the `standard-minifiers` package that can be
replaced with a custom one. The
[source](https://github.com/meteor/meteor/tree/devel/packages/standard-minifiers)
of the package is a good example how to build your own minification plugin.

In development builds, minifiers must meet these requirements to not prevent hot module replacement:

- Call `addJavasScript` once for each file to add the file's contents
- The contents of the files are not modified

In the future Meteor will allow minifiers to concatenate or modify files in development without affected hot module replacement.


## Caching {#build-plugin-caching}

Since the API allows build plugins to process multiple files at once, we encourage package authors to implement at least some in-memory caching for their plugins. Using the `getSourceHash` function for linters and compilers will allow quick incremental recompilations if the file is not reprocessed even when the contents didn't change.

For the fast rebuilds between the Isobuild process runs, plugins can implement on-disk caching. If a plugin implements the `setDiskCacheDirectory` method, it will be called from time to time with a new path on disk where the plugin can write its offline cache. The folder is correctly reset when the plugin is rebuilt or cache should be invalidated for any reason (for example, picked package versions set has changed).

### Caching Compiler {#build-plugin-caching-compiler}

There is a core package called `caching-compiler` that implements most of the common logic of keeping both in-memory and on-disk caches. The easiest way to implement caching correctly is to subclass the `CachingCompiler` or `MultiFileCachingCompiler` class from this package in your build plugin. `CachingCompiler` is for compilers that consider each file completely independently; `MultiFileCachingCompiler` is for compilers that allow files to reference each other. To get this class in your plugin namespace, add a dependency to the plugin definition:

```js
Package.registerBuildPlugin({
  name: 'compileGG',
  use: ['caching-compiler@1.0.0'],
  sources: ['plugin/compile-gg.js']
});
```

## Accessing File System {#build-plugin-file-system}

Since the build plugins run as part of the Meteor tool, they follow the same file-system access convention - all file system paths always look like a Unix path: using forward slashes and having a root at '/', even on Windows. For example: paths `/usr/bin/program` and `/C/Program Files/Program/program.exe` are valid paths, and `C:\Program Files\Program\program.exe` is not.

So whenever you get a path in your build plugin implementation, via `getPathInPackage` or in an argument of the `setDiskCacheDirectory` method, the path will be a Unix path.

Now, on running on Windows, the usual node modules `fs` and `path` expect to get a DOS path. To assist you to write correct code, the `Plugin` symbol provides its own versions of `fs` and `path` that you can use instead (note that all methods on `fs` are fiberized and sync versions prefer using Fibers rather than freezing the whole event loop).

Also `Plugin` provides helper functions `convertToStandardPath` and `convertToOSPath` to convert to a Unix path or to the path expected by the node libraries regardless of the path origin.

Example:

```js
// On Windows
const fs = Plugin.fs;
const path = Plugin.path;

const filePath = path.join('/C/Program Files', 'Program/file.txt');
console.log(filePath); // Prints '/C/Program Files/Program/file.txt'

fs.writeFileSync(filePath, 'Hello.'); // Writes to 'C:\Program Files\Program\file.txt'

console.log(Plugin.convertToOsPath(filePath)); // Prints 'C:\Program Files\Program\file.txt'
```


## Isobuild Feature Packages {#isobuild-features}

Starting with Meteor 1.2, packages can declare that they need a version of the Meteor tool whose Isobuild build system supports a certain feature. For example, packages must write `api.use('isobuild:compiler-plugin@1.0.0')` in order to call `Plugin.registerCompiler`. This means that a package can transition from the old `registerSourceHandler` API to `registerCompiler` and Version Solver will properly prevent the `registerCompiler` version from being chosen by older tools that don't know how to handle it.

This is the known Isobuild feature "packages" sorted by the first release of Meteor which supports them.

### Introduced in Meteor 1.2s {#isobuild-features-1.2}

- `compiler-plugin@1.0.0`: Allows use of `Plugin.registerCompiler`.
- `linter-plugin@1.0.0`: Allows use of `Plugin.registerLinter`.
- `minifier-plugin@1.0.0`: Allows use of `Plugin.registerMinifier`.
- `isopack-2@1.0.0`: This package is published only in `isopack-2` format and won't work in versions
of Meteor that don't support that format.
- `prod-only@1.0.0`: Allows use of the `prodOnly` flag in `Package.describe`.
- `isobuild:cordova@5.4.0`: This package depends on a specific version of Cordova, most likely as a result of the Cordova plugins it depends on.

---

---
url: /packages/accounts-passwordless.md
---
# Passwordless

Passwordless package allows you to create a login for users without the need for user to provide password. Upon registering or login an email is sent to the user's email with a code to enter to confirm login and a link to login directly. Since the user is responding to the email it will also verify the email.

The first step to in the passwordless process is for the user to sign-up or request a token to their email address. You can do that with the following:
<ApiBox name="Accounts.requestLoginTokenForUser" from="accounts-base"/>

If the user is signing up you can pass in the `userData` object like in [Accounts.createUser](/api/accounts#Accounts-createUser).

<ApiBox name="Meteor.passwordlessLoginWithToken" />
The second step in the passwordless flow. Like all the other `loginWith` functions call this method to login the user with the token they have inputted.

<ApiBox name="Accounts.sendLoginTokenEmail"  from="accounts-base" />
Use this function if you want to manually send the email to users to login with token from the server. Do note that you will need to create the token/sequence and save it in the DB yourself. This is good if you want to change how the tokens look or are generated, but unless you are sure of what you are doing we don't recommend it.

<h3 id="config-options">Settings Options</h3>

You can use the function `Accounts.config` in the server to change some settings on this package:

- **tokenSequenceLength**: use `Accounts.config({tokenSequenceLength: _Number_})` to the size of the token sequence generated. The default is 6.

- **loginTokenExpirationHours**: use `Accounts.config({loginTokenExpirationHours: _Number_})` to set the amount of time a token sent is valid. As it's just a number, you can use, for example, 0.5 to make the token valid for just half hour. The default is 1 hour.

<h3 id="passwordless-email-templates">E-mail templates</h3>

`accounts-passwordless` brings new templates that you can edit to change the look of emails which send code to users. The email template is named `sendLoginToken` and beside `user` and `url`, the templates also receive a data object with `sequence` which is the user's code.

```javascript
sendLoginToken: {
  text: (user, url, { sequence }) => {
    /* text template */
  };
}
```

<h3 id="enabling-2fa">Enable 2FA for this package</h3>

You can add 2FA to your login flow by using the package [accounts-2fa](./accounts-2fa.md).
You can find an example showing how this would look like [here](./accounts-2fa.md#working-with-accounts-passwordless).

---

---
url: /community-packages/pub-sub.md
---
# Pub-sub

- `Who maintains the package` – [Jam](https://github.com/jamauro)

[[toc]]

## What is this package?

`jam:pub-sub` brings three key features to Meteor apps:

1. Method-based publish / subscribe
2. Change Streams-based publish / subscribe
3. Subscription caching

> **Important**: This package expects that you'll use the promise-based `*Async` Meteor collection methods introduced in `v2.8.1`.

## Method-based publish / subscribe
Meteor's traditional `publish / subscribe` is truly wonderful. However, there is a cost to pushing updates reactively to all connected clients – it's resource intensive and will eventually place limits on your ability to scale your app.

One way to reduce the need for the traditional `publish / subscribe` is to fetch the data via a `Meteor Method` but there's a big problem here: the data **won't** be automatically merged into Minimongo and you completely lose Meteor's magical reactivity. Minimongo is great to work with and makes things easy as the source of truth on the client. Without it, you'll need to create your own stores on the client and essentially duplicate Minimongo.

With `jam:pub-sub`, you use `Meteor.publish.once` and the same `Meteor.subscribe` to have the data fetched via a Meteor Method and merged automatically in Minimongo so you can work with it as you're accustomed to. It also automatically preserves reactivity for the user when they make database writes. Note that these writes will **not** be broadcast in realtime to all connected clients by design but in many cases you might find that you don't need that feature of Meteor's traditional `publish / subscribe`.

## How to download it?

Add the package to your app
```bash
meteor add jam:pub-sub
```
### Sources

* [GitHub repository](https://github.com/jamauro/pub-sub)

## How to use it?

## Change Streams-based publish / subscribe
**`Alpha`**

With `jam:pub-sub` and MongoDB Change Streams, you can preserve Meteor's magical reactivity for all clients while opting out of the traditional `publish / subscribe` and its use of the `oplog`. Use `Meteor.publish.stream` instead of using `Meteor.publish` and subscribe using the same `Meteor.subscribe` on the client.

**Important**: Change Streams will work best when the filter you use can be shared. To that end, if you have a publication that includes a `userId`, this package will filter out that condition when setting up the Change Stream because it will result in too many unique change streams. As an example, lets say you have this publication:

```js
Meteor.publish.stream('todos', function() {
  return Todos.find({
    $or: [
      { isPrivate: false },
      { owner: this.userId }
    ]
  });
});
```

When this publication is invoked, it will pull all the `Todos` that match the filter above and then begin watching a Change Stream with this filter:
```js
  { isPrivate: false }
```

For this particular filter, it should behave as you'd expect so you wouldn't need to make changes. However, if you have complex filters involving the `userId`, you'll need to be sure that the behavior you expect remains when using `.stream`. If it's not meeting your needs, you could split the one publication into two publications, using a `.stream` with a filter than can be shared and a `.once` for the `userId`:

```js
Meteor.publish.stream('todos.public', function() {
  return Todos.find({ isPrivate: false });
});

Meteor.publish.once('todos.owned', function() {
  return Todos.find({ owner: this.userId });
});
```

The downside by splitting into two is it could result in over-fetching but the data will be merged correctly into Minimongo.

**Note**: In most cases, you'd likely benefit the most from using `Meteor.publish.once` anywhere you can and using `Meteor.publish.stream` only when you really need it and with a filter than can be shared.

**Note**: If you decide to entirely opt-out of using the traditional `Meteor.publish`, then you'll also want to disable the `oplog` entirely &mdash; add the `disable-oplog` package with `meteor add disable-oplog`.

At the moment, this feature is considered in an `alpha` state. Based on previous [Change Streams experiments](https://github.com/meteor/meteor/discussions/11842#discussioncomment-4061112) by the Meteor Community, it seems that using Change Streams as a wholesale replacement for the traditional `publish / subscribe` could "just work". However, in practice it may be a "Your Mileage May Vary" type of situation depending on the frequency of writes, number of connected clients, how you model your data, and how you set up the cursors inside of `Meteor.publish.stream`. With that said, if you're interested in this feature, I'd encourage you to try it out and share your findings.

## Subscription caching
Normally, when a user moves between routes or components, the subscriptions will be stopped. When a user is navigating back and forth in your app, each time will result in a re-subscribe which means more spinners, a slower experience, and is generally a waste.

By caching your subscriptions, you can create a better user experience for your users. Since the subscription itself is being cached, the data in Minimongo will be updated in the background until the `cacheDuration` expires for that subscription at which point it will be stopped and the data will be removed from Minimongo as expected.

## Usage

### Add the package to your app
`meteor add jam:pub-sub`

### Define a Method-based publication
Define a publication using `Meteor.publish.once` and subscribe just as you do currently. `Meteor.publish.once` expects you to return a cursor or an array of cursors just like `Meteor.publish`.

```js
// server
Meteor.publish.once('notes.all', function() {
  return Notes.find();
});
```

```js
// client
// Since each view layer (Blaze, React, Svelte, Vue, etc) has a different way of using `Tracker.autorun`, I've omitted it for brevity. You'd subscribe just as you do currently in your view layer of choice.
Meteor.subscribe('notes.all')

// work with the Notes collection in Minimongo as you're accustomed to
Notes.find().fetch();
```
That's it. By using `Meteor.publish.once`, it will fetch the data initally and automatically merge it into Minimongo. Any database writes to the `Notes` collection will be sent reactively to the user that made the write.

> **Important**: when naming your publications be sure to include the collection name(s) in it. This is generally common practice and this package relies on that convention. If you don't do this and you're caching the subscription, Minimongo data may be unexpectedly removed or retained when the subscription stops. It's recommended that you follow this convention for all publications including `Meteor.publish`. Here are some examples of including the collection name in the publication name:
```js
// the name you assign inside Mongo.Collection should be in your publication name(s), in this example 'notes'
const Notes = new Mongo.Collection('notes')

// as long as it appears somewhere in your publication name, you're good to go. here are some examples:
Meteor.publish.once('notes');
Meteor.publish.once('notes.all');
Meteor.publish.once('notes/single');
Meteor.publish.once('somethingAndNotes');
```

It also works just as you'd expect for an array of cursors:

```js
// server
Meteor.publish.once('notes.todos.all', function() {
  return [Notes.find(), Todos.find()];
});
```

```js
// client
Meteor.subscribe('notes.todos.all');

// work with the Notes collection in Minimongo as you're accustomed to
Notes.find().fetch();

// work with the Todos collection in Minimongo as you're accusomted to
Todos.find().fetch();
```

Inside `Meteor.publish.once`, `this.userId` and [this.added](https://docs.meteor.com/api/pubsub.html#Subscription-added) can still be used. The added document will be included in the final result data. The rest of the low-level `publish` API will be disregarded, as they no longer fit into the context of a Method-based data fetch.

```js
Meteor.publish.once('notes.all', function() {
  // ... //
  const userId = this.userId;

  this.added('notes', _id, fields);
  // ... //
  return Notes.find();
})
```

### Define a Change Streams-based publication
Define a publication using `Meteor.publish.stream` and subscribe just as you do currently. `Meteor.publish.stream` expects you to return a cursor or an array of cursors just like `Meteor.publish`.

```js
// server
Meteor.publish.stream('notes.all', function() {
  return Notes.find();
});
```

```js
// client
// Since each view layer (Blaze, React, Svelte, Vue, etc) has a different way of using `Tracker.autorun`, I've omitted it for brevity. You'd subscribe just as you do currently in your view layer of choice.
Meteor.subscribe('notes.all')

// work with the Notes collection in Minimongo as you're accustomed to
Notes.find().fetch();
```
That's it. By using `Meteor.publish.stream`, any database writes to the `Notes` collection will be sent reactively to **all** connected clients just as with `Meteor.publish`.

#### Setting the `maxPoolSize` for Change Streams
`maxPoolSize` defaults to `100` which may not need adjusting. If you need to adjust it, you can set it in [Meteor.settings](https://docs.meteor.com/api/collections.html#mongo_connection_options_settings) like this:
```js
{
  //...//
  "packages": {
    "mongo": {
      "options": {
        "maxPoolSize": 200 // or whatever is appropriate for your application
      }
    }
  }
  // ... //
}
```

### Turn on subscription caching
With `jam:pub-sub`, you can enable subscription caching globally or at a per-subscription level. Subscription caching is turned off by default to preserve the current behavior in Meteor. Any subscription can be cached, regardless of how it's published.

To enable subscription caching globally for every subscription:
```js
// put this in a file that's imported on the client at a minimum. it can be used isomorphically but the configuration only applies to the client.
import { PubSub } from 'meteor/jam:pub-sub';

PubSub.configure({
  cache: true // defaults to false
});
```

The global `cacheDuration` is set to `60 seconds` by default. This is from when the subscription was originally set to be stopped, i.e. when the component housing the subscription was destroyed because the user navigated away. If the user comes right back, then the cache will be used. If they don't, after `60 seconds`, the subscription cache will be removed. If you want to change the global `cacheDuration`, change it with a value in `seconds`:

```js
import { PubSub } from 'meteor/jam:pub-sub';

PubSub.configure({
  cacheDuration: 5 * 60 // sets the cacheDuration to 5 minutes. defaults to 1 min
});
```

You can also configure `cache` and `cacheDuration` for each individual subscription when you use `Meteor.subscribe`. For example:
```js
Meteor.subscribe('todos.single', _id, { cacheDuration: 30 }) // caches for 30 seconds, overriding the global default
Meteor.subscribe('notes.all', { cache: true }) // turns caching on, overriding the global default, and uses the global default cacheDuration
```

> **Note**: the rest of the [Meteor.subscribe](https://docs.meteor.com/api/pubsub.html#Meteor-subscribe) API (e.g. `onStop`, `onReady`) works just as you'd expect.

> **Note**: Because the data will remain in Minimongo while the subscription is cached, you should be mindful of your Minimongo `.find` selectors. Be sure to use specific selectors to `.find` the data you need for that particular subscription. This is generally considered [best practice](https://guide.meteor.com/data-loading#fetching) so this is mainly a helpful reminder.

#### Clearing the cache
Each individual subcription will be automatically removed from the cache when its `cacheDuration` elapses.

Though it shouldn't be necessary, you can programmatically clear all cached subscriptions:

```js
import { PubSub } from 'meteor/jam:pub-sub';

PubSub.clearCache();
```

---

---
url: /packages/random.md
---
# Random


The `random` package provides several functions for generating random
numbers. It uses a cryptographically strong pseudorandom number generator when
possible, but falls back to a weaker random number generator when
cryptographically strong randomness is not available (on older browsers or on
servers that don't have enough entropy to seed the cryptographically strong
generator).

<ApiBox name="Random.id" />
<ApiBox name="Random.secret" />
<ApiBox name="Random.fraction" />
<ApiBox name="Random.choice" />
<ApiBox name="Random.hexString" />

---

---
url: /packages/react-meteor-data.md
---
# react-meteor-data

This package provides an integration between React and [`Tracker`](https://atmospherejs.com/meteor/tracker), Meteor's reactive data system.

## Table of Contents

[[toc]]

## Install

::: tip

This package is included with `meteor create` on react options. No need to install it manually.

:::

To install the package, use `meteor add`:

```bash
meteor add react-meteor-data
```

You'll also need to install `react` if you have not already:

```bash
meteor npm install react
```

### Changelog

[check recent changes here](https://github.com/meteor/react-packages/blob/master/packages/react-meteor-data/CHANGELOG.md)

## Usage

This package provides two ways to use Tracker reactive data in your React components:

- a hook: `useTracker` (v2 only, requires React `^16.8`)
- a higher-order component (HOC): `withTracker` (v1 and v2).

The `useTracker` hook, introduced in version 2.0.0, embraces the [benefits of hooks](https://reactjs.org/docs/hooks-faq.html). Like all React hooks, it can only be used in function components, not in class components.

The `withTracker` HOC can be used with all components, function or class based.

It is not necessary to rewrite existing applications to use the `useTracker` hook instead of the existing `withTracker` HOC.

### `useTracker(reactiveFn)`

You can use the `useTracker` hook to get the value of a Tracker reactive function in your React "function components." The reactive function will get re-run whenever its reactive inputs change, and the component will re-render with the new value.

`useTracker` manages its own state, and causes re-renders when necessary. There is no need to call React state setters from inside your `reactiveFn`. Instead, return the values from your `reactiveFn` and assign those to variables directly. When the `reactiveFn` updates, the variables will be updated, and the React component will re-render.

Arguments:

- `reactiveFn`: A Tracker reactive function (receives the current computation).

The basic way to use `useTracker` is to simply pass it a reactive function, with no further fuss. This is the preferred configuration in many cases.

#### `useTracker(reactiveFn, deps)`

You can pass an optional deps array as a second value. When provided, the computation will be retained, and reactive updates after the first run will run asynchronously from the react render execution frame. This array typically includes all variables from the outer scope "captured" in the closure passed as the 1st argument. For example, the value of a prop used in a subscription or a minimongo query; see example below.

This should be considered a low level optimization step for cases where your computations are somewhat long running - like a complex minimongo query. In many cases it's safe and even preferred to omit deps and allow the computation to run synchronously with render.

Arguments:

- `reactiveFn`
- `deps`: An optional array of "dependencies" of the reactive function. This is very similar to how the `deps` argument for [React's built-in `useEffect`, `useCallback` or `useMemo` hooks](https://reactjs.org/docs/hooks-reference.html) work.

```jsx
import { useTracker } from 'meteor/react-meteor-data';

// React function component.
function Foo({ listId }) {
  // This computation uses no value from the outer scope,
  // and thus does not needs to pass a 'deps' argument.
  // However, we can optimize the use of the computation
  // by providing an empty deps array. With it, the
  // computation will be retained instead of torn down and
  // rebuilt on every render. useTracker will produce the
  // same results either way.
  const currentUser = useTracker(() => Meteor.user(), []);

  // The following two computations both depend on the
  // listId prop. When deps are specified, the computation
  // will be retained.
  const listLoading = useTracker(() => {
    // Note that this subscription will get cleaned up
    // when your component is unmounted or deps change.
    const handle = Meteor.subscribe('todoList', listId);
    return !handle.ready();
  }, [listId]);
  const tasks = useTracker(() => Tasks.find({ listId }).fetch(), [listId]);

  return (
    <h1>Hello {currentUser.username}</h1>
    {listLoading ? (
        <div>Loading</div>
      ) : (
        <div>
          Here is the Todo list {listId}:
          <ul>
            {tasks.map(task => (
              <li key={task._id}>{task.label}</li>
            ))}
          </ul>
        </div>
      )}
  );
}
```

**Note:** the [eslint-plugin-react-hooks](https://www.npmjs.com/package/eslint-plugin-react-hooks) package provides ESLint hints to help detect missing values in the `deps` argument of React built-in hooks. It can be configured to also validate the `deps` argument of the `useTracker` hook or some other hooks, with the following `eslintrc` config:

```json
"react-hooks/exhaustive-deps": ["warn", { "additionalHooks": "useTracker|useSomeOtherHook|..." }]
```

#### `useTracker(reactiveFn, deps, skipUpdate)` or `useTracker(reactiveFn, skipUpdate)`

You may optionally pass a function as a second or third argument. The `skipUpdate` function can evaluate the return value of `reactiveFn` for changes, and control re-renders in sensitive cases. _Note:_ This is not meant to be used with a deep compare (even fast-deep-equals), as in many cases that may actually lead to worse performance than allowing React to do it's thing. But as an example, you could use this to compare an `updatedAt` field between updates, or a subset of specific fields, if you aren't using the entire document in a subscription. As always with any optimization, measure first, then optimize second. Make sure you really need this before implementing it.

Arguments:

- `reactiveFn`
- `deps?` - optional - you may omit this, or pass a "falsy" value.
- `skipUpdate` - A function which receives two arguments: `(prev, next) => (prev === next)`. `prev` and `next` will match the type or data shape as that returned by `reactiveFn`. Note: A return value of `true` means the update will be "skipped". `false` means re-render will occur as normal. So the function should be looking for equivalence.

```jsx
import { useTracker } from 'meteor/react-meteor-data';

// React function component.
function Foo({ listId }) {
  const tasks = useTracker(
    () => Tasks.find({ listId }).fetch(), [listId],
    (prev, next) => {
      // prev and next will match the type returned by the reactiveFn
      return prev.every((doc, i) => (
        doc._id === next[i] && doc.updatedAt === next[i]
      )) && prev.length === next.length;
    }
  );

  return (
    <h1>Hello {currentUser.username}</h1>
    <div>
      Here is the Todo list {listId}:
      <ul>
        {tasks.map(task => (
          <li key={task._id}>{task.label}</li>
        ))}
      </ul>
    </div>
  );
}
```

### `withTracker(reactiveFn)`

You can use the `withTracker` HOC to wrap your components and pass them additional props values from a Tracker reactive function. The reactive function will get re-run whenever its reactive inputs change, and the wrapped component will re-render with the new values for the additional props.

Arguments:

- `reactiveFn`: a Tracker reactive function, getting the props as a parameter, and returning an object of additional props to pass to the wrapped component.

```jsx
import { withTracker } from 'meteor/react-meteor-data';

// React component (function or class).
function Foo({ listId, currentUser, listLoading, tasks }) {
  return (
    <h1>Hello {currentUser.username}</h1>
    {listLoading ?
      <div>Loading</div> :
      <div>
        Here is the Todo list {listId}:
        <ul>{tasks.map(task => <li key={task._id}>{task.label}</li>)}</ul>
      </div}
  );
}

export default withTracker(({ listId }) => {
  // Do all your reactive data access in this function.
  // Note that this subscription will get cleaned up when your component is unmounted
  const handle = Meteor.subscribe('todoList', listId);

  return {
    currentUser: Meteor.user(),
    listLoading: !handle.ready(),
    tasks: Tasks.find({ listId }).fetch(),
  };
})(Foo);
```

The returned component will, when rendered, render `Foo` (the "lower-order" component) with its provided props in addition to the result of the reactive function. So `Foo` will receive `{ listId }` (provided by its parent) as well as `{ currentUser, listLoading, tasks }` (added by the `withTracker` HOC).

For more information, see the [React article](http://guide.meteor.com/react.html) in the Meteor Guide.

### `withTracker({ reactiveFn, pure, skipUpdate })`

The `withTracker` HOC can receive a config object instead of a simple reactive function.

- `getMeteorData` - The `reactiveFn`.
- `pure` - `true` by default. Causes the resulting Container to be wrapped with React's `memo()`.
- `skipUpdate` - A function which receives two arguments: `(prev, next) => (prev === next)`. `prev` and `next` will match the type or data shape as that returned by `reactiveFn`. Note: A return value of `true` means the update will be "skipped". `false` means re-render will occur as normal. So the function should be looking for equivalence.

```jsx
import { withTracker } from 'meteor/react-meteor-data';

// React component (function or class).
function Foo({ listId, currentUser, listLoading, tasks }) {
  return (
    <h1>Hello {currentUser.username}</h1>
    {listLoading ?
      <div>Loading</div> :
      <div>
        Here is the Todo list {listId}:
        <ul>{tasks.map(task => <li key={task._id}>{task.label}</li>)}</ul>
      </div}
  );
}

export default withTracker({
  getMeteorData ({ listId }) {
    // Do all your reactive data access in this function.
    // Note that this subscription will get cleaned up when your component is unmounted
    const handle = Meteor.subscribe('todoList', listId);

    return {
      currentUser: Meteor.user(),
      listLoading: !handle.ready(),
      tasks: Tasks.find({ listId }).fetch(),
    };
  },
  pure: true,
  skipUpdate (prev, next) {
    // prev and next will match the shape returned by the reactiveFn
    return (
      prev.currentUser?._id === next.currentUser?._id
    ) && (
      prev.listLoading === next.listLoading
    ) && (
      prev.tasks.every((doc, i) => (
        doc._id === next[i] && doc.updatedAt === next[i]
      ))
      && prev.tasks.length === next.tasks.length
    );
  }
})(Foo);
```

### `useSubscribe(subName, ...args)`

`useSubscribe` is a convenient short hand for setting up a subscription. It is particularly useful when working with `useFind`, which should NOT be used for setting up subscriptions. At its core, it is a very simple wrapper around `useTracker` (with no deps) to create the subscription in a safe way, and allows you to avoid some of the ceremony around defining a factory and defining deps. Just pass the name of your subscription, and your arguments.

`useSubscribe` returns an `isLoading` function. You can call `isLoading()` to react to changes in the subscription's loading state. The `isLoading` function will both return the loading state of the subscription, and set up a reactivity for the loading state change. If you don't call this function, no re-render will occur when the loading state changes.

```jsx
// Note: isLoading is a function!
const isLoading = useSubscribe("posts", groupId);
const posts = useFind(() => Posts.find({ groupId }), [groupId]);

if (isLoading()) {
  return <Loading />;
} else {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post._id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

If you want to conditionally subscribe, you can set the `name` field (the first argument) to a falsy value to bypass the subscription.

```jsx
const needsData = false;
const isLoading = useSubscribe(needsData ? "my-pub" : null);

// When a subscription is not used, isLoading() will always return false
```

### `useFind(cursorFactory, deps)`

The `useFind` hook can substantially speed up the rendering (and rerendering) of lists coming from mongo queries (subscriptions). It does this by controlling document object references. By providing a highly tailored cursor management within the hook, using the `Cursor.observe` API, `useFind` carefully updates only the object references changed during a DDP update. This approach allows a tighter use of core React tools and philosophies to turbo charge your list renders. It is a very different approach from the more general purpose `useTracker`, and it requires a bit more set up. A notable difference is that you should NOT call `.fetch()`. `useFind` requires its factory to return a `Mongo.Cursor` object. You may also return `null`, if you want to conditionally set up the Cursor.

Here is an example in code:

```jsx
import React, { memo } from "react";
import { useFind } from "meteor/react-meteor-data";
import TestDocs from "/imports/api/collections/TestDocs";

// Memoize the list item
const ListItem = memo(({ doc }) => {
  return (
    <li>
      {doc.id},{doc.updated}
    </li>
  );
});

const Test = () => {
  const docs = useFind(() => TestDocs.find(), []);
  return (
    <ul>
      {docs.map((doc) => (
        <ListItem key={doc.id} doc={doc} />
      ))}
    </ul>
  );
};

// Later on, update a single document - notice only that single component is updated in the DOM
TestDocs.update({ id: 2 }, { $inc: { someProp: 1 } });
```

If you want to conditionally call the find method based on some props configuration or anything else, return `null` from the factory.

```jsx
const docs = useFind(() => {
  if (props.skip) {
    return null;
  }
  return TestDocs.find();
}, []);
```

### Concurrent Mode, Suspense and Error Boundaries

There are some additional considerations to keep in mind when using Concurrent Mode, Suspense and Error Boundaries, as
each of these can cause React to cancel and discard (toss) a render, including the result of the first run of your
reactive function. One of the things React developers often stress is that we should not create "side-effects" directly
in the render method or in functional components. There are a number of good reasons for this, including allowing the
React runtime to cancel renders. Limiting the use of side-effects allows features such as concurrent mode, suspense and
error boundaries to work deterministically, without leaking memory or creating rogue processes. Care should be taken to
avoid side effects in your reactive function for these reasons. (Note: this caution does not apply to Meteor specific
side-effects like subscriptions, since those will be automatically cleaned up when `useTracker`'s computation is
disposed.)

Ideally, side-effects such as creating a Meteor computation would be done in `useEffect`. However, this is problematic
for Meteor, which mixes an initial data query with setting up the computation to watch those data sources all in one
initial run. If we wait to do that in `useEffect`, we'll end up rendering a minimum of 2 times (and using hacks for the
first one) for every component which uses `useTracker` or `withTracker`, or not running at all in the initial render and
still requiring a minimum of 2 renders, and complicating the API.

To work around this and keep things running fast, we are creating the computation in the render method directly, and
doing a number of checks later in `useEffect` to make sure we keep that computation fresh and everything up to date,
while also making sure to clean things up if we detect the render has been tossed. For the most part, this should all be
transparent.

The important thing to understand is that your reactive function can be initially called more than once for a single
render, because sometimes the work will be tossed. Additionally, `useTracker` will not call your reactive function
reactively until the render is committed (until `useEffect` runs). If you have a particularly fast changing data source,
this is worth understanding. With this very short possible suspension, there are checks in place to make sure the
eventual result is always up to date with the current state of the reactive function. Once the render is "committed",
and the component mounted, the computation is kept running, and everything will run as expected.

## Suspendable version of hooks

### `useTracker`

This is a version of `useTracker` that can be used with React Suspense.

For its first argument, a key is necessary, witch is used to identify the computation and to avoid recreating it when the
component is re-rendered.

Its second argument is a function that can be async and reactive,
this argument works similar to the original `useTracker` that does not suspend.

For its _optional_ third argument, the dependency array, works similar to the `useTracker` that does not suspend,
you pass in an array of variables that this tracking function depends upon.

For its _optional_ fourth argument, the options object, works similar to the `useTracker` that does not suspend,
you pass in a function for when should skip the update.

```jsx
import { useTracker } from "meteor/react-meteor-data/suspense";
import { useSubscribe } from "meteor/react-meteor-data/suspense";

function Tasks() {
  // this component will suspend
  useSubscribe("tasks");
  const { username } = useTracker("user", () => Meteor.user()); // Meteor.user() is async meteor 3.0
  const tasksByUser = useTracker(
    "tasksByUser",
    () =>
      TasksCollection.find(
        { username },
        { sort: { createdAt: -1 } }
      ).fetchAsync() // async call
  );

  // render the tasks
}
```

### Maintaining the reactive context

To maintain a reactive context using the new Meteor Async methods, we are using the new `Tracker.withComputation` API to maintain the reactive context of an
async call, this is needed because otherwise it would be only called once, and the computation would never run again,
this way, every time we have a new Link being added, this useTracker is ran.

```jsx
// needs Tracker.withComputation because otherwise it would be only called once, and the computation would never run again
const docs = useTracker("name", async (c) => {
  const placeholders = await fetch(
    "https://jsonplaceholder.typicode.com/todos"
  ).then((x) => x.json());
  console.log(placeholders);
  return await Tracker.withComputation(c, () =>
    LinksCollection.find().fetchAsync()
  );
});
```

A rule of thumb is that if you are using a reactive function for example `find` + `fetchAsync`, it is nice to wrap it
inside `Tracker.withComputation` to make sure that the computation is kept alive, if you are just calling that function
that is not necessary, like the one bellow, will be always reactive.

```jsx
const docs = useTracker("name", () => LinksCollection.find().fetchAsync());
```

### `useSubscribe`

This is a version of `useSubscribe` that can be used with React Suspense.
It is similar to `useSubscribe`, it throws a promise and suspends the rendering until the promise is resolved.
It does not return a Meteor Handle to control the subscription

```jsx
import { useTracker } from "meteor/react-meteor-data/suspense";
import { useSubscribe } from "meteor/react-meteor-data/suspense";

function Tasks() {
  // this component will suspend
  useSubscribe("tasks");
  const { username } = useTracker("user", () => Meteor.user()); // Meteor.user() is async meteor 3.0
  const tasksByUser = useTracker(
    "tasksByUser",
    () =>
      TasksCollection.find(
        { username },
        { sort: { createdAt: -1 } }
      ).fetchAsync() // async call
  );

  // render the tasks
}
```

### `useFind`

This is a version of `useFind` that can be used with React Suspense.
It has a few differences from the `useFind` without suspense, it throws a promise and suspends the rendering until the promise is resolved.
It returns the result and it is reactive.
You should pass as the first parameter the collection where is being searched upon and as the second parameter an array with the arguments,
the same arguments that you would pass to the `find` method of the collection, third parameter is optional, and it is dependency array object.
It's meant for the SSR, you don't have to use it if you're not interested in SSR.

```jsx
import { useFind } from "meteor/react-meteor-data/suspense";
import { useSubscribe } from "meteor/react-meteor-data/suspense";

function Tasks() {
  // this component will suspend
  useSubscribe("tasks");
  const tasksByUser = useFind(TasksCollection, [
    {},
    { sort: { createdAt: -1 } },
  ]);

  // render the tasks
}
```

## Version compatibility notes

- `react-meteor-data` v2.x :

  - `useTracker` hook + `withTracker` HOC
  - Requires React `^16.8`.
  - Implementation is compatible with "React Suspense", concurrent mode and error boundaries.
  - The `withTracker` HOC is strictly backwards-compatible with the one provided in v1.x, the major version number is only motivated by the bump of React version requirement. Provided a compatible React version, existing Meteor apps leveraging the `withTracker` HOC can freely upgrade from v1.x to v2.x, and gain compatibility with future React versions.
  - The previously deprecated `createContainer` has been removed.

- `react-meteor-data` v0.x :
  - `withTracker` HOC (+ `createContainer`, kept for backwards compatibility with early v0.x releases)
  - Requires React `^15.3` or `^16.0`.
  - Implementation relies on React lifecycle methods (`componentWillMount` / `componentWillUpdate`) that are [marked for deprecation in future React versions](https://reactjs.org/blog/2018/03/29/react-v-16-3.html#component-lifecycle-changes) ("React Suspense").

---

---
url: /api/ReactiveDict.md
---
# Reactive Dict

A ReactiveDict stores an arbitrary set of key-value pairs. Use it to manage
internal state in your components, ie. like the currently selected item in a list.
Each key is individully reactive such that calling `set` for a key will
invalidate any Computations that called `get` with that key, according to the
usual contract for reactive data sources.

That means if you call [`ReactiveDict#get`](#ReactiveDict-get)`('currentList')`
from inside a Blaze template helper, the template will automatically be rerendered
whenever [`ReactiveDict#set`](#ReactiveDict-set)`('currentList', x)` is called.

To use `ReactiveDict`, add the `reactive-dict` package to your project by running
in your terminal:

```bash
meteor add reactive-dict
```


<ApiBox name="ReactiveDict" />

If you provide a name to its constructor, its contents will be saved across Hot
Code Push client code updates.

<ApiBox name="ReactiveDict#set" instanceName="reactiveDict" hasCustomExample/>

Example:

```js
import { ReactiveDict } from "meteor/reactive-dict";
import { Tracker } from "meteor/tracker";
import { Meteor } from "meteor/meteor";

const state = new ReactiveDict();
state.set("currentRoomId", "random");

Tracker.autorun(() => {
  Meteor.subscribe("chatHistory", { room: state.get("currentRoomId") });
});

// Causes the function passed to `Tracker.autorun` to be rerun, so that the
// 'chatHistory' subscription is moved to the room 'general'.
state.set("currentRoomId", "general");
```

`ReactiveDict.set` can also be called with an object of keys and values, which is
equivalent to calling `ReactiveDict.set` individually on each key/value pair.

```js
import { ReactiveDict } from "meteor/reactive-dict";
const state = new ReactiveDict();
state.set({
  a: "foo",
  b: "bar",
});
```

<ApiBox name="ReactiveDict#setDefault" instanceName="reactiveDict" />

This is useful in initialization code, to avoid re-initializing your state
every time a new version of your app is loaded.

<ApiBox name="ReactiveDict#get" instanceName="reactiveDict" />

Example in Blaze:

::: code-group

```html [main.html]
<template name="main">
  <p>We've always been at war with {{theEnemy}}.</p>
  <button class="change-enemy">Change Enemy</button>
</template>
```

```js [main.js]
Template.main.onCreated(function () {
  this.state = new ReactiveDict();
  this.state.set("enemy", "Eastasia");
});
Template.main.helpers({
  theEnemy() {
    const inst = Template.instance();
    return inst.state.get("enemy");
  },
});
Template.main.events({
  "click .change-enemy"(event, inst) {
    inst.state.set("enemy", "Eurasia");
  },
});

// Clicking the button will change the page to say "We've always been at war with Eurasia"
```
:::

<ApiBox name="ReactiveDict#delete" instanceName="reactiveDict" />

<ApiBox name="ReactiveDict#equals" instanceName="reactiveDict" />

If value is a scalar, then these two expressions do the same thing:

```js
import { ReactiveDict } from "meteor/reactive-dict";
const state = new ReactiveDict();
// ...
state.get("key") === value;
state.equals("key", value);
```

However, the second is recommended, as it triggers fewer invalidations
(template redraws), making your program more efficient.

<ApiBox name="ReactiveDict#all" instanceName="reactiveDict" />

<ApiBox name="ReactiveDict#clear" instanceName="reactiveDict" />

<ApiBox name="ReactiveDict#destroy" instanceName="reactiveDict" />

---

---
url: /api/ReactiveVar.md
---
# ReactiveVar

To use `ReactiveVar`, add the `reactive-var` package to your project by running
in your terminal:

```bash
meteor add reactive-var
```

<ApiBox name="ReactiveVar" />


A ReactiveVar holds a single value that can be get and set, such that calling
`set` will invalidate any Computations that called `get`, according to the
usual contract for reactive data sources.

A ReactiveVar is similar to a Session variable, with a few differences:

- ReactiveVars don't have global names, like the "foo" in `Session.get('foo')`.
  Instead, they may be created and used locally, for example attached to a
  template instance, as in: `this.foo.get()`.

- ReactiveVars are not automatically migrated across hot code pushes,
  whereas Session state is.

- ReactiveVars can hold any value, while Session variables are limited to
  JSON or EJSON.

An important property of ReactiveVars &mdash; which is sometimes a
reason for using one &mdash; is that setting the value to the same
value as before has no effect; it does not trigger any invalidations.
So if one autorun sets a ReactiveVar, and another autorun gets the
ReactiveVar, a re-run of the first autorun won't necessarily trigger
the second. By default, only primitive values are compared this way,
while calling `set` on an argument that is an _object_ (not a
primitive) always counts as a change. You can configure this behavior
using the `equalsFunc` argument.

<ApiBox name="ReactiveVar#get" instanceName="reactiveVar" />

<ApiBox name="ReactiveVar#set" instanceName="reactiveVar" />

---

---
url: /about/roadmap.md
---
# Roadmap

Describes the high-level features and actions for the Meteor project in the near-to-medium term future.

## Introduction

**Last updated: June 16, 2025.**

The description of many items includes sentences and ideas from Meteor community members.

Contributors are encouraged to focus their efforts on work that aligns with the roadmap then we can work together in these areas.

> As with any roadmap, this is a living document that will evolve as priorities and dependencies shift.

> If you have new feature requests or ideas, you should open a new [discussion](https://github.com/meteor/meteor/discussions/new).

## Current project: Bundle optimization

> We need to improve the bundle size and performance of Meteor apps. We should consider tree-shaking, code-splitting,
> and other optimizations to make our apps leaner and faster.
> To achieve that we plan to integrate or have an easy way to integrate with modern bundlers like RSPack, ESBuild, or Rollup.

**Discussion links:**

- [GitHub discussion](https://github.com/meteor/meteor/discussions/11587)
- [forums discussion](https://forums.meteor.com/t/join-the-effort-to-speed-up-meteor-bundler/63406/17)

### Implementation plan:

#### Phase 1: Profiling

**Target Release:** 3.2 ✅

**Goal:** Add a command([meteor profile](/cli/#meteorprofile)) to measure if our changes are actually making our builds faster and smaller.


#### Phase 2: External Transpiler Integration

**Target Release:** 3.3 ✅

**Goal:** For this phase we want:
 - Improve our current bundler performance, via optimizations so that any meteor user can get benefits from it; And an external bundler could get
   the same benefits.
 - To have an external transpiler working with Meteor and producing a bundle that is smaller or faster than the current Meteor bundle.


#### Phase 3: HMR Improvements

**Target Release:** 3.3 ✅

**Goal:** Improve the HMR performance, so that it is faster and more reliable on what needs to be changed.

#### Phase 4: Bundler Improvements & feedback

**Target Release:** 3.3.x ⏳

**Goal:** Improve the build size and make meteor use less resources for building, decreasing even more build and rebuild time.
- Expanding compatibility and updates based on the feedback from the community, so that we can have a better experience with our new build tools, in this case SWC

#### Phase 5: External Bundler integration

**Target Release:** 3.4 ⏳

**Goal:**  And an external bundler (like RSPack, ESBuild, or Rollup) working with Meteor and producing a bundle that is smaller or faster than the current Meteor bundle.
- This will also allow Meteor to have features like tree-shaking, code-splitting, and other optimizations that will make our apps leaner and faster.

#### Phase 6: Build Process Optimization

**Target Release:** 3.4.x ⏳

**Goal:** Improve the build size and make meteor use less resources for building, decreasing even more build and rebuild time.
- Expanding compatibility and updates based on the feedback from the community, so that we can have a better experience with our new build tools


#### Documentation Strategy

We plan to document the changes in the Meteor documentation, including:
- How to use the new features
- How to integrate with the new bundler
- How the meteor bundler pipeline works for future contributors
- Examples and guides on how to integrate with the new bundler

## Next releases

- Support package.json exports fields ([Discussion](https://github.com/meteor/meteor/discussions/11727))
- Tree-shaking

  > Tree-shaking and exports fields may be implemented by integrating with more modern build tools.

- Capacitor support

  > Capacitor is a modern alternative to Cordova; we should provide an easy way to build mobile apps using Capacitor.

- MongoDB Change Streams support ([Discussion](https://github.com/meteor/meteor/discussions/11842))

  > Change Streams is the official way to listen to changes in MongoDB. We should provide a way to use it seamlessly in Meteor. It has been planned for a long time, and now we’re in a position to do it.

- Improve TypeScript support for Meteor and packages ([Discussion](https://github.com/meteor/meteor/discussions/12080))

  > Should be an ongoing effort to improve the TypeScript support in Meteor and packages. We should provide a better experience for TypeScript users, including better type definitions and support for TypeScript features.

- Improve release CI/CD speed and reliability (optimized build times will help)
  > Our CI/CD takes too long to run, causing long queues and delays in our release process and feedback loop; we need to improve that.

### Candidate items

We need to discuss further to decide whether to proceed with these implementations.

- Performance improvements (Async Hooks/Async Local Storage optimization)
- HTTP/3 Support
- Improve DDP Client
- Improve Passwordless package ([Discussion](https://github.com/meteor/meteor/discussions/12075))
- Integrate with Tauri, it might replace Cordova and Electron in a single tool
- Bring Redis-oplog to core ([Repository](https://github.com/Meteor-Community-Packages/redis-oplog))
- Better file upload support via DDP ([Discussion](https://github.com/meteor/meteor/discussions/11523))
- Improve usage in Windows environments

### Finished items

- Change how Meteor executes Async code ([Discussion](https://github.com/meteor/meteor/discussions/11505))
  - Provide new async APIs where Fibers are required
    - Mongo package with Async API ([PR](https://github.com/meteor/meteor/pull/12028))
    - Provide async versions for Accounts and core packages
    - Adapt Meteor Promise implementation
- Enable Top-Level Await (TLA) on Meteor server-side ([PR](https://github.com/meteor/meteor/pull/12095))
- Support Top-Level Await (TLA) on Reify
- Remove Fibers dependency from Meteor Public APIs
- Remove Fibers entirely
- Update Cordova integration to Meteor 3.0
- Run Meteor on Node.js v20
- Change web engine from Connect to Express

---

For more completed items, refer to our [changelog](https://docs.meteor.com/history.html).

---

---
url: /packages/roles.md
---
# Roles

Authorization package for Meteor - compatible with built-in accounts package.

> Available since Meteor 3.1.0 (previously alanning:roles)

## Installation

To add roles to your application, run this command in your terminal:

```bash
meteor add roles
```

## Overview

The roles package lets you attach roles to users and then check against those roles when deciding whether to grant access to Meteor methods or publish data. The core concept is simple - you create role assignments for users and then verify those roles later. This package provides helper methods to make the process of adding, removing, and verifying roles easier.

## Concepts

### Roles vs Permissions

Although named "roles", you can define your **roles**, **scopes** or **permissions** however you like. They are essentially tags assigned to users that you can check later.

You can have traditional roles like `admin` or `webmaster`, or more granular permissions like `view-secrets`, `users.view`, or `users.manage`. Often, more granular permissions are better as they handle edge cases without creating many higher-level roles.

### Role Hierarchy

Roles can be organized in a hierarchy:

- Roles can have multiple parents and children (subroles)
- If a parent role is assigned to a user, all its descendant roles also apply
- This allows creating "super roles" that aggregate permissions

Example hierarchy setup:

```js
import { Roles } from "meteor/roles";

// Create base roles
await Roles.createRoleAsync("user");
await Roles.createRoleAsync("admin");

// Create permission roles
await Roles.createRoleAsync("USERS_VIEW");
await Roles.createRoleAsync("POST_EDIT");

// Set up hierarchy
await Roles.addRolesToParentAsync("USERS_VIEW", "admin");
await Roles.addRolesToParentAsync("POST_EDIT", "admin");
await Roles.addRolesToParentAsync("POST_EDIT", "user");
```

### Scopes

Scopes allow users to have independent sets of roles. Use cases include:

- Different communities within your app
- Multiple tenants in a multi-tenant application
- Different resource groups

Users can have both scoped roles and global roles:

- Global roles apply across all scopes
- Scoped roles only apply within their specific scope
- Scopes are independent of each other

Example using scopes:

```js
// Assign scoped roles
await Roles.addUsersToRolesAsync(userId, ["manage-team"], "team-a");
await Roles.addUsersToRolesAsync(userId, ["player"], "team-b");

// Check scoped roles
await Roles.userIsInRoleAsync(userId, "manage-team", "team-a"); // true
await Roles.userIsInRoleAsync(userId, "manage-team", "team-b"); // false

// Assign global role
await Roles.addUsersToRolesAsync(userId, "super-admin", null);

// Global roles work in all scopes
await Roles.userIsInRoleAsync(userId, ["manage-team", "super-admin"], "team-b"); // true
```

## Role Management

<ApiBox name="Roles.createRoleAsync" hasCustomExample/>

Example:

```js
import { Roles } from "meteor/roles";

// Create a new role
await Roles.createRoleAsync("admin");

// Create if doesn't exist
await Roles.createRoleAsync("editor", { unlessExists: true });
```

### Modifying Roles

<ApiBox name="Roles.addRolesToParentAsync" hasCustomExample />

Example:

```js
// Make 'editor' a child role of 'admin'
await Roles.addRolesToParentAsync("editor", "admin");

// Add multiple child roles
await Roles.addRolesToParentAsync(["editor", "moderator"], "admin");
```

<ApiBox name="Roles.removeRolesFromParentAsync" hasCustomExample />

Example:

```js
// Remove 'editor' as child role of 'admin'
await Roles.removeRolesFromParentAsync("editor", "admin");
```

<ApiBox name="Roles.deleteRoleAsync" hasCustomExample />

Example:

```js
// Delete role and all its assignments
await Roles.deleteRoleAsync("temp-role");
```

<ApiBox name="Roles.renameRoleAsync" hasCustomExample />

Example:

```js
// Rename an existing role
await Roles.renameRoleAsync("editor", "content-editor");
```

### Assigning Roles

<ApiBox name="Roles.addUsersToRolesAsync" hasCustomExample />

Example:

```js
// Add global roles
await Roles.addUsersToRolesAsync(userId, ["admin", "editor"]);

// Add scoped roles
await Roles.addUsersToRolesAsync(userId, ["manager"], "department-a");

// Add roles to multiple users
await Roles.addUsersToRolesAsync([user1Id, user2Id], ["user"]);
```

<ApiBox name="Roles.setUserRolesAsync" hasCustomExample />

Example:

```js
// Replace user's global roles
await Roles.setUserRolesAsync(userId, ["editor"]);

// Replace scoped roles
await Roles.setUserRolesAsync(userId, ["viewer"], "project-x");

// Clear all roles in scope
await Roles.setUserRolesAsync(userId, [], "project-x");
```

<ApiBox name="Roles.removeUsersFromRolesAsync" hasCustomExample />

Example:

```js
// Remove global roles
await Roles.removeUsersFromRolesAsync(userId, ["admin"]);

// Remove scoped roles
await Roles.removeUsersFromRolesAsync(userId, ["manager"], "department-a");

// Remove roles from multiple users
await Roles.removeUsersFromRolesAsync([user1Id, user2Id], ["temp-role"]);
```

<ApiBox name="Roles.renameScopeAsync" hasCustomExample />

Example:

```js
// Rename a scope
await Roles.renameScopeAsync("department-1", "marketing");
```

<ApiBox name="Roles.removeScopeAsync" hasCustomExample />

Example:

```js
// Remove a scope and all its role assignments
await Roles.removeScopeAsync("old-department");
```

<ApiBox name="Roles.getAllRoles" hasCustomExample />

Example:

```js
// Get all roles sorted by name
const roles = Roles.getAllRoles({ sort: { _id: 1 } });

// Get roles with custom query
const customRoles = Roles.getAllRoles({
  fields: { _id: 1, children: 1 },
  sort: { _id: -1 },
});
```

<ApiBox name="Roles.getUsersInRoleAsync" hasCustomExample />

Example:

```js
// returns a cursor of all admin users
const adminUsersCursor = await Roles.getUsersInRoleAsync("admin");

// Find all admin users
const adminUsers = await (await Roles.getUsersInRoleAsync("admin")).fetchAsync();

// Find users with specific roles in a scope
const scopedUsers = await (await Roles.getUsersInRoleAsync(
  ["editor", "writer"],
  "blog"
)).fetchAsync();

// Find users with custom options
const users = await (await Roles.getUsersInRoleAsync("manager", {
  scope: "department-a",
  queryOptions: {
    sort: { createdAt: -1 },
    limit: 10,
  },
})).fetchAsync();
```

## Checking Roles

<ApiBox name="Roles.userIsInRoleAsync" hasCustomExample />

Example:

```js
// Check global role
const isAdmin = await Roles.userIsInRoleAsync(userId, "admin");

// Check any of multiple roles
const canEdit = await Roles.userIsInRoleAsync(userId, ["editor", "admin"]);

// Check scoped role
const isManager = await Roles.userIsInRoleAsync(
  userId,
  "manager",
  "department-a"
);

// Check role in any scope
const hasRole = await Roles.userIsInRoleAsync(userId, "viewer", {
  anyScope: true,
});
```

<ApiBox name="Roles.getRolesForUserAsync"  hasCustomExample />

Example:

```js
// Get user's global roles
const globalRoles = await Roles.getRolesForUserAsync(userId);

// Get scoped roles
const deptRoles = await Roles.getRolesForUserAsync(userId, "department-a");

// Get all roles including inherited
const allRoles = await Roles.getRolesForUserAsync(userId, {
  anyScope: true,
  fullObjects: true,
});
```

<ApiBox name="Roles.isParentOfAsync" hasCustomExample />

Example:

```js
// Check if admin is a parent of editor
const isParent = await Roles.isParentOfAsync("admin", "editor");

// Can be used to check inheritance chains
const hasPermission = await Roles.isParentOfAsync("super-admin", "post-edit");
```

<ApiBox name="Roles.getScopesForUserAsync" hasCustomExample />

Example:

```js
// Get all scopes for user
const allScopes = await Roles.getScopesForUserAsync(userId);

// Get scopes where user has specific roles
const editorScopes = await Roles.getScopesForUserAsync(userId, ["editor"]);
```

## Publishing Roles

Role assignments need to be published to be available on the client. Example publication:

```js
// Publish user's own roles
Meteor.publish(null, function () {
  if (this.userId) {
    return Meteor.roleAssignment.find({ "user._id": this.userId });
  }
  this.ready();
});

// Publish roles for specific scope
Meteor.publish("scopeRoles", function (scope) {
  if (this.userId) {
    return Meteor.roleAssignment.find({ scope: scope });
  }
  this.ready();
});
```

## Client only APIs

On the client alongside the async methods, you can use the `sync` versions of the functions:

- `Roles.userIsInRole(userId, roles, scope)`
- `Roles.getRolesForUser(userId, scope)`
- `Roles.getScopesForUser(userId)`
- `Roles.isParentOf(parent, child)`
- `Roles.getUsersInRole(role, scope)`
- `Roles.getAllRoles(options)`
- `Roles.createRole(role, options)`
- `Roles.addUsersToRoles(userId, roles, scope)`
- `Roles.setUserRoles(userId, roles, scope)`
- `Roles.removeUsersFromRoles(userId, roles, scope)`
- `Roles.addRolesToParent(child, parent)`
- `Roles.removeRolesFromParent(child, parent)`
- `Roles.deleteRole(role)`
- `Roles.renameRole(oldRole, newRole)`
- `Roles.renameScope(oldScope, newScope)`
- `Roles.removeScope(scope)`

## Using with Templates

The roles package automatically provides an `isInRole` helper for templates:

```handlebars
{{#if isInRole "admin"}}
  <div class="admin-panel">
    <!-- Admin only content -->
  </div>
{{/if}}

{{#if isInRole "editor,writer" "blog"}}
  <div class="editor-tools">
    <!-- Blog editor tools -->
  </div>
{{/if}}
```

## Migration to Core Version

If you are currently using the `alanning:roles` package, follow these steps to migrate to the core version:

1. Make sure you are on version 3.6 of `alanning:roles` first
2. Run any pending migrations from previous versions
3. Switch all server-side role operations to use the async versions of the functions:
   - createRoleAsync
   - deleteRoleAsync
   - addUsersToRolesAsync
   - setUserRolesAsync
   - removeUsersFromRolesAsync
   - etc.
4. Remove `alanning:roles` package:
   ```bash
   meteor remove alanning:roles
   ```
5. Add the core roles package:
   ```bash
   meteor add roles
   ```
6. Update imports to use the new package:
   ```js
   import { Roles } from "meteor/roles";
   ```

The sync versions of these functions are still available on the client.

## Security Considerations

1. Client-side role checks are for convenience only - always verify permissions on the server
2. Publish only the role data that users need
3. Use scopes to properly isolate role assignments
4. Validate role names and scopes to prevent injection attacks
5. Consider using more granular permissions over broad role assignments

## Example Usage

### Method Security

```js
// server/methods.js
Meteor.methods({
  deletePost: async function (postId) {
    check(postId, String);

    const canDelete = await Roles.userIsInRoleAsync(
      this.userId,
      ["admin", "moderator"],
      "posts"
    );

    if (!canDelete) {
      throw new Meteor.Error("unauthorized", "Not authorized to delete posts");
    }

    Posts.remove(postId);
  },
});
```

### Publication Security

```js
// server/publications.js
Meteor.publish("secretDocuments", async function (scope) {
  check(scope, String);

  const canView = await Roles.userIsInRoleAsync(
    this.userId,
    ["view-secrets", "admin"],
    scope
  );

  if (canView) {
    return SecretDocs.find({ scope: scope });
  }

  this.ready();
});
```

### User Management

```js
// server/users.js
Meteor.methods({
  promoteToEditor: async function (userId, scope) {
    check(userId, String);
    check(scope, String);

    const canPromote = await Roles.userIsInRoleAsync(
      this.userId,
      "admin",
      scope
    );

    if (!canPromote) {
      throw new Meteor.Error("unauthorized");
    }

    await Roles.addUsersToRolesAsync(userId, ["editor"], scope);
  },
});
```

---

---
url: /api-examples.md
---

# Runtime API Examples

This page demonstrates usage of some of the runtime APIs provided by VitePress.

The main `useData()` API can be used to access site, theme, and page data for the current page. It works in both `.md` and `.vue` files:

```md
<script setup>
import { useData } from 'vitepress'

const { theme, page, frontmatter } = useData()
</script>

## Results

### Theme Data
<pre>{{ theme }}</pre>

### Page Data
<pre>{{ page }}</pre>

### Page Frontmatter
<pre>{{ frontmatter }}</pre>
```

<script setup>
import { useData } from 'vitepress'

const { site, theme, page, frontmatter } = useData()
</script>

## Results

### Theme Data
<pre>{{ theme }}</pre>

### Page Data
<pre>{{ page }}</pre>

### Page Frontmatter
<pre>{{ frontmatter }}</pre>

## More

Check out the documentation for the [full list of runtime APIs](https://vitepress.dev/reference/runtime-api#usedata).

---

---
url: /packages/server-render.md
---
# Server Rendering

This package implements generic support for server-side rendering in
Meteor apps, by providing a mechanism for injecting fragments of HTML into
the `<head>` and/or `<body>` of the application's initial HTML response.

## Usage

This package exports a function named `onPageLoad` which takes a callback
function that will be called at page load (on the client) or whenever a
new request happens (on the server).

The callback receives a `sink` object, which is an instance of either
`ClientSink` or `ServerSink` depending on the environment. Both types of
`sink` have the same methods, though the server version accepts only HTML
strings as content, whereas the client version also accepts DOM nodes.

The current interface of `{Client,Server}Sink` objects is as follows:

```js
class Sink {
  // Appends content to the <head>.
  appendToHead(content)

  // Appends content to the <body>.
  appendToBody(content)

  // Appends content to the identified element.
  appendToElementById(id, content)

  // Replaces the content of the identified element.
  renderIntoElementById(id, content)

  // Redirects request to new location.
  redirect(location, code)


  // server only methods

  // sets the status code of the response.
  setStatusCode(code)

  // sets a header of the response.
  setHeader(key, value)

  // gets request headers
  getHeaders()

  // gets request cookies
  getCookies()
}
```

The `sink` object may also expose additional properties depending on the
environment. For example, on the server, `sink.request` provides access to
the current `request` object, and `sink.arch` identifies the target
architecture of the pending HTTP response (e.g. "web.browser").

Here is a basic example of `onPageLoad` usage on the server:

::: code-group

```js [server.js]
import from "react";
import { renderToString } from "react-dom/server";
import { onPageLoad } from "meteor/server-render";

import App from "/imports/Server.js";

onPageLoad(sink => {
  sink.renderIntoElementById("app", renderToString(
    <App location={sink.request.url} />
  ));
});
```

Likewise on the client:

```js [client.js]
import React from "react";
import ReactDOM from "react-dom";
import { onPageLoad } from "meteor/server-render";

onPageLoad(async (sink) => {
  const App = (await import("/imports/Client.js")).default;
  ReactDOM.hydrate(<App />, document.getElementById("app"));
});
```

:::

Note that the `onPageLoad` callback function is allowed to return a
`Promise` if it needs to do any asynchronous work, and thus may be
implemented by an `async` function (as in the client case above).

Note also that the client example does not end up calling any methods of
the `sink` object, because `ReactDOM.hydrate` has its own similar API. In
fact, you are not even required to use the `onPageLoad` API on the client,
if you have your own ideas about how the client should do its rendering.

Here is a more complicated example of `onPageLoad` usage on the server,
involving the [`styled-components`](https://www.styled-components.com/docs/advanced#server-side-rendering) npm package:

```js
import React from "react";
import { onPageLoad } from "meteor/server-render";
import { renderToString } from "react-dom/server";
import { ServerStyleSheet } from "styled-components";
import App from "/imports/Server";

onPageLoad((sink) => {
  const sheet = new ServerStyleSheet();
  const html = renderToString(
    sheet.collectStyles(<App location={sink.request.url} />)
  );

  sink.renderIntoElementById("app", html);
  sink.appendToHead(sheet.getStyleTags());
});
```

In this example, the callback not only renders the `<App />` element into
the element with `id="app"`, but also appends any `<style>` tag(s)
generated during rendering to the `<head>` of the response document.

Although these examples have all involved React, the `onPageLoad` API is
designed to be generically useful for any kind of server-side rendering.

## Streaming HTML

React 16 introduced [`renderToNodeStream`](https://reactjs.org/docs/react-dom-server.html#rendertonodestream), which enables the reading of rendered HTML in chunks. This reduces the [TTFB](https://en.wikipedia.org/wiki/Time_to_first_byte) (time to first byte).

Here is a `renderToNodeStream` example using [styled-components](https://www.styled-components.com). Note the use of `sheet.interleaveWithNodeStream` instead of `sink.appendToHead(sheet.getStyleTags());`:

```js
import React from "react";
import { onPageLoad } from "meteor/server-render";
import { renderToNodeStream } from "react-dom/server";
import { ServerStyleSheet } from "styled-components";
import App from "/imports/Server";

onPageLoad((sink) => {
  const sheet = new ServerStyleSheet();
  const appJSX = sheet.collectStyles(<App location={sink.request.url} />);
  const htmlStream = sheet.interleaveWithNodeStream(renderToNodeStream(appJSX));
  sink.renderIntoElementById("app", htmlStream);
});
```

## Getting data from the request

In some cases you want to customize meta tags or something else in your response based in the requested URL, for example, if your are loading a page with a specific product in your app maybe you want to include an image and a description for [social previews](https://www.contentkingapp.com/academy/open-graph/).

You can extract information from the request using the `sink` object.

```js
import { onPageLoad } from "meteor/server-render";

const getBaseUrlFromHeaders = (headers) => {
  const protocol = headers["x-forwarded-proto"];
  const { host } = headers;
  // we need to have '//' to findOneByHost work as expected
  return `${protocol ? `${protocol}:` : ""}//${host}`;
};

const getContext = (sink) => {
  // more details about this implementation here
  // https://github.com/meteor/meteor/issues/9765
  const { headers, url, browser } = sink.request;
  // no useful data will be found for galaxybot requests
  if (browser && browser.name === "galaxybot") {
    return null;
  }

  // when we are running inside cordova we don't want to resolve meta tags
  if (url && url.pathname && url.pathname.includes("cordova/")) {
    return null;
  }

  const baseUrl = getBaseUrlFromHeaders(headers);
  const fullUrl = `${baseUrl}${url.pathname || ""}`;

  return { baseUrl, fullUrl };
};

onPageLoad((sink) => {
  const { baseUrl, fullUrl } = getContext(sink);

  // product URL contains /product on it
  const urlParseArray = fullUrl.split("/");

  const productPosition = urlParseArray.indexOf("product");
  const productId =
    productPosition !== -1 &&
    urlParseArray[productPosition + 1].replace("?", "");
  const product = productId && ProductsCollection.findOne(productId);

  const productTitle = product && `Buy now ${product.name}, ${product.price}`;
  if (productTitle) {
    sink.appendToHead(`<title>${productTitle}</title>\n`);
    sink.appendToHead(`<meta property="og:title" content="${productTitle}">\n`);
    if (product.imageUrl) {
      sink.appendToHead(
        `<meta property="og:image" content="${product.imageUrl}">\n`
      );
    }
  }
});
```

---

---
url: /api/session.md
---
# Session

Documentation of Meteor's client-side session API.


`Session` provides a global object on the client that you can use to
store an arbitrary set of key-value pairs. Use it to store things like
the currently selected item in a list.

What's special about `Session` is that it's reactive. If
you call [`Session.get`](#Session-get)`('currentList')`
from inside a template, the template will automatically be rerendered
whenever [`Session.set`](#Session-set)`('currentList', x)` is called.

To add `Session` to your application, run this command in your terminal:

```bash
meteor add session
```

<ApiBox name="Session.set" hasCustomExample/>


```js
import { Session } from 'meteor/session';
import { Tracker } from 'meteor/tracker';
import { Meteor } from 'meteor/meteor';

Tracker.autorun(() => {
  Meteor.subscribe('chatHistory', { room: Session.get('currentRoomId') });
});

// Causes the function passed to `Tracker.autorun` to be rerun, so that the
// 'chatHistory' subscription is moved to the room 'home'.
Session.set('currentRoomId', 'home');
```


`Session.set` can also be called with an object of keys and values, which is
equivalent to calling `Session.set` individually on each key/value pair.

```js
Session.set({
  a: 'foo',
  b: 'bar'
});
```


<ApiBox name="Session.setDefault"/>

This is useful in initialization code, to avoid re-initializing a session
variable every time a new version of your app is loaded.


<ApiBox name="Session.get" hasCustomExample/>

This example in Blaze.js
::: code-group

```html [main.html]
<template name="main">
  <p>We've always been at war with {{theEnemy}}.</p>
</template>
```

```js [main.js]
Template.main.helpers({
  theEnemy() {
    return Session.get('enemy');
  }
});

Session.set('enemy', 'Eastasia');
// Page will say "We've always been at war with Eastasia"

Session.set('enemy', 'Eurasia');
// Page will change to say "We've always been at war with Eurasia"
```
:::


<ApiBox name="Session.equals"/>


If value is a scalar, then these two expressions do the same thing:

```js
Session.get('key') === value
Session.equals('key', value)
```

...but the second one is always better. It triggers fewer invalidations
(template redraws), making your program more efficient.

This example in Blaze.js:

::: code-group

```html [main.html]

<template name="postsView">
  {{#each posts}}
    {{> postItem}}
  {{/each}}
</template>

<template name="postItem">
  <div class="{{postClass}}">{{title}}</div>
</template>
```

```js [main.js]

Template.postsView.helpers({
  posts() {
    return Posts.find();
  }
});

Template.postItem.helpers({
  postClass() {
    return Session.equals('selectedPost', this._id)
      ? 'selected'
      : '';
  }
});

Template.postItem.events({
  'click'() {
    Session.set('selectedPost', this._id);
  }
});
```

Using Session.equals here means that when the user clicks
on an item and changes the selection, only the newly selected
and the newly unselected items are re-rendered.

If Session.get had been used instead of Session.equals, then
when the selection changed, all the items would be re-rendered.

For object and array session values, you cannot use `Session.equals`; instead,
you need to use the `underscore` package and write
`_.isEqual(Session.get(key), value)`.

---

---
url: /community-packages/soft-delete.md
---
# Soft-delete

- `Who maintains the package` – [Jam](https://github.com/jamauro)

[[toc]]

## What is this package?

Soft Delete is an easy way to add soft deletes to your Meteor app. Its key features are:

* Zero config needed (though you can customize)
* Isomorphic so that it works with Optimistic UI
* Automatically overrides `removeAsync` to make it a soft delete
* Automatically adds the soft delete flag on `insertAsync` and to the filter for your queries, e.g. `.find`, so you don't need to make any changes to them
* Recover soft deleted docs with `recoverAsync` collection method
* Explicitly soft delete with `softRemoveAsync` collection method (optional)
* Optionally add a `deletedAt` timestamp
* Optionally exclude specific collections
* Compatible with Meteor `2.8.1+` and `3.0+`

> **Note:** Alternative to soft deletion is to archive documents in your collection. You can use [`jam:archive`](./archive.md) package for that. Be sure to compare those two approaches to pick the solution best suited for your application.

## How to download it?

Add the package to your app
```bash
meteor add jam:soft-delete
```
### Sources

* [GitHub repository](https://github.com/jamauro/soft-delete)

## How to use it?

### Deleting permanently
By default, this package overrides the `removeAsync` collection method so that it soft deletes the document(s) with a boolean flag rather that removing them from the database. To delete permanently, pass in the option `soft: false`, e.g.:
```js
Collection.removeAsync(/* your filter */, { soft: false })
```

If you prefer, you can prevent overriding the `removeAsync` by setting `overrideRemove: false`. See [Configuring](#configuring-optional) for more details.

### Explicitly soft deleting
If you prefer, you can explicity use `softRemoveAsync`, e.g.:
```js
Collection.softRemoveAsync(/* your filter */)
```

### Recovering a document
To recover a soft deleted document, use `recoverAsync`, e.g.:
```js
Collection.recoverAsync(/* your filter */)
```

## Configuring (optional)
If you like the defaults, then you won't need to configure anything. But there is some flexibility in how you use this package.

Here are the global defaults:
```js
const config = {
  deleted: 'deleted', // the field name used for the boolean flag. you can update to your preference, e.g. 'isDeleted'
  deletedAt: '', // add the name of the field you'd like to use for a deletedAt timestamp, e.g. 'deletedAt', if you want to include it on your docs
  autoFilter: true, // automatically adds the { [deleted]: false } filter to your queries
  overrideRemove: true, // overrides the Collection.removeAsync method to make it a soft delete instead
  exclude: ['roles', 'role-assignment'] // exclude specific collections from using soft delete. defaults to excluding the collections created the meteor roles package
};
```

To change the global defaults, use:
```js
// put this in a file that's imported on both the client and server
import { SoftDelete } from 'meteor/jam:soft-delete';

SoftDelete.configure({
  // ... change the defaults here ... //
});
```

---

---
url: /packages/standard-minifier-css.md
---
# Standard Minifier CSS

This package is the default css minifier in Meteor apps. In addition to minifying the css code in production builds, it also runs any PostCSS plugins configured for the app.

## Post CSS

This package can optionally run [PostCSS](https://postcss.org/) plugins on the css files in your app. To enable:

1. Install npm peer dependencies:

```sh
meteor npm install -D postcss postcss-load-config
```

2. Add PostCSS Config. Create a `postcss.config.js` file and add a config:

```js
module.exports = {
  plugins: {
    autoprefixer: {},
  }
};
```

> The example config enables the `autoprefixer` postcss plugin. You can install the plugin by running `meteor npm install -D autoprefixer`.

Learn more about [configuring postcss](https://github.com/postcss/postcss-load-config#packagejson) or find a list of [available plugins](https://postcss.org/docs/postcss-plugins).

After making changes to the PostCSS Config, `meteor` must be restarted for it to use the new config.

### Exclude Meteor Packages

In addition to the css files in your app, PostCSS will also process the css files added from Meteor packages. In case you do not want these files to be processed, or they are not compatible with your PostCSS config, you can have PostCSS ignore them by using the `excludedMeteorPackages` option:

```js
module.exports = {
  plugins: {
    autoprefixer: {},
  },
  excludedMeteorPackages: [
    'github-config-ui',
    'constellation:console'
  ]
};
```

### Tailwind CSS

Tailwind CSS is fully supported. Since HMR applies updates to js files earlier than the css is updated, there can be a delay when using a Tailwind CSS class the first time before the styles are applied.


### Debbuging

_Since Meteor.js 2.11.0 in this [PR](https://github.com/meteor/meteor/pull/12478) we have a debbug mode for the minifier_

#### How standard-minifier-css becomes verbose

- Either of the common debugging commandline arguments
  - `--verbose`
  - `--debug`
- Environment variable
  - `DEBUG_CSS`

Side notes:
`DEBUG_CSS=false` or `DEBUG_CSS=0` will prevent it from being verbose regardless of `--verbose` or `--debug` commandline arguments, because `DEBUG_CSS` is specific.

---

---
url: /api/templates.md
---

# Templates
Documentation of Meteor's client-side session API.

This documentation has moved to the [Blaze Community Site](http://blazejs.org/api/templates).

---

---
url: /api/top-level-await.md
---
# Top Level Await

[Top-level await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await#top_level_await) (TLA) allows you to use `await` in the top-level of a module or file instead of only in async functions. One way to view it is as if every file runs inside an `async` function. 

Here is an example of using top-level await on the server. When this file is loaded, the `await` will cause the module to wait for the count before the code in the rest of the module is run.

```js
const Links = new Mongo.Collection('links');

// Async code using top-level await.
// The module waits for this to finish before continuing
const count = await Links.find().countAsync();

if (count === 0) {
  await Links.insertAsync({ url: 'https://meteor.com' });
}
```

Before Meteor 3, async code using fibers could run at the top level of a module. Top-level await allows similar code to work without fibers. This article will cover a few differences.

Meteor's implementation of top-level await tries to closely follow the specification. However, there are currently some differences in how Meteor handles circular dependencies.

## Using Top Level Await

Top-level await can be used in any app or package that uses the `ecmascript`, `typescript`, or `coffeescript` packages, or that uses any other build plugin that compiles top-level await using reify.
Generally, if you can use ECMAScript modules, then you can also use top-level await.

There are some extra considerations when using top-level await in packages. They are covered later in this article.

Top-level await is only enabled by default on the server. You can enable it for the client by setting the env var `METEOR_ENABLE_CLIENT_TOP_LEVEL_AWAIT` to `true`. There are a couple known issues with using TLA on the client:

1. It breaks any files in `/client/compatibility` since it now wraps those files in a function
2. Hot module replacement has not been updated to work with TLA

## Async Modules

With top-level await, some modules are considered async, which affects how they behave. There are two ways a module can become an async module:
1. It uses top-level await
2. It imports a module that is async

For example, this module (`setup.js`) would be async because it uses top-level await:

```js
await setupLanguages();
```

This module (`main.js`) would be sync:

```js
console.log('in main.js');
```

However, if it imports `setup.js` which does use top-level await, then `main.js` also becomes async.

```js
import './setup.js';

console.log('in main.js');
```

## Require

When using `require` to load an async module, instead of directly returning a module's exports, it will return a promise that resolves to the module's exports.

```js
// resolves to the exports of init.js
const promise = require('./init.js');
```

If you are using `require`, this does mean you need to be careful when adding or removing top-level await in a file since you also have to update where the module is required.
Since a module becomes async if it depends on an async module, this could affect more than just the individual modules using top-level await.

When possible, you can use ECMAScript import syntax or dynamic imports instead so you don't have to worry about which modules are sync or async.

## Nested Imports

Nested imports refer to using `import ...` outside of the root of a module, for example in an if block or a function.

```js
if (Meteor.isClient) {
  import './init-client.js';
}

export function showNotification(message) {
  import show from './notifications.js';

  show(message);
}
```

This feature is unique to Meteor, so the top-level await specification wasn't written to work with nested imports. Using nested imports to import a sync module continues to work, but it will throw an error if used to import an async module. You can use `require` or dynamic imports for async modules in these situations.

## Using in Packages

Top-level await is only supported starting in Meteor 3.  Published build plugins are able to use top-level await in older Meteor versions since the runtime is bundled when they are published, though in development they require Meteor 3.

If you want to ensure your package only runs in versions of Meteor that support top-level await, you can have your package use `isobuild:top-level-await`:

```js
Package.onUse(function (api) {
  // Do not allow this package to be used in pre-Meteor 3 apps.
  api.use("isobuild:top-level-await@3.0.0");
});
```

When importing a package that does not have a lazy main module, it will work the same whether a package uses top-level await or not. This is true even when using `require`. This allows packages to add or remove top-level await without it being a breaking change.

There are a couple of cases where adding or removing top-level await from a module in a package could be considered a breaking change:

1. If specific modules are require'd from a package. For example: `require('meteor/zodern:aurorae/svelte.js')`. When importing a specific module from a package, `require` changes its behavior based on if the module is async or not.
2. If a package that has lazy main modules is require'd. Unlike normal packages, `require` will return a promise if the lazy main module is an async module. Changing if the lazy main module is async or not should be considered a breaking change for the package.

## Module and Package Execution Order

Normally, modules are run one at a time. This was even true when using async code with fibers in the root of a module. However, top-level await is different - it allows siblings (modules that do not depend on each other) to sometimes run in parallel. This can allow the app to load faster, which is especially important on the client. However, this could cause code to run in an unexpected order if you are used to how Meteor works with fibers.

This also applies to packages. Packages that do not directly or indirectly depend on each other can load in parallel if they use top-level await.

Modules that are eagerly evaluated (added in packages with `api.addFiles`, or outside of `imports` in apps that do not have a main module) and not directly imported continue to run one at a time, even if they use top-level await since it is common for these modules to implicitly depend on the previous modules.

---

---
url: /troubleshooting/mongodb-connection.md
---
# Topology Closed Error

One possible scenario we've seen is that after migrating to Meteor 3, some apps become partially unresponsive and throw `MongoTopologyClosedError: Topology is closed` errors on startup.

In this case, you might consider increasing the server selection timeout for your MongoDB instance, like this:

```json
{
  "packages": {
    "mongo": {
      "options": {
        "serverSelectionTimeoutMS": 120000
      }
    }
  }
}
```

---

---
url: /api/Tracker.md
---
# Tracker

Meteor has a simple dependency tracking system which allows it to
automatically rerun templates and other computations whenever
[`Session`](./session.md) variables, database queries, and other data
sources change.

Unlike most other systems, you don't have to manually declare these
dependencies & it "just works". The mechanism is simple and
efficient. When you call a function that supports reactive updates
(such as a database query), it automatically saves the current
Computation object, if any (representing, for example, the current
template being rendered).  Later, when the data changes, the function
can "invalidate" the Computation, causing it to rerun (rerendering the
template).

Applications will find [`Tracker.autorun`](#Tracker-autorun) useful, while more
advanced facilities such as `Tracker.Dependency` and `onInvalidate`
callbacks are intended primarily for package authors implementing new
reactive data sources.

<ApiBox name="Tracker.autorun" hasCustomExample/>

`Tracker.autorun` allows you to run a function that depends on reactive data
sources, in such a way that if there are changes to the data later,
the function will be rerun.

For example, you can monitor a cursor (which is a reactive data
source) and aggregate it into a session variable:

```js
Tracker.autorun(() => {
  const oldest = _.max(Monkeys.find().fetch(), (monkey) => {
    return monkey.age;
  });

  if (oldest) {
    Session.set('oldest', oldest.name);
  }
});
```

Or you can wait for a session variable to have a certain value, and do
something the first time it does, calling `stop` on the computation to
prevent further rerunning:

```js
Tracker.autorun((computation) => {
  if (!Session.equals('shouldAlert', true)) {
    return;
  }

  computation.stop();
  alert('Oh no!');
});
```

The function is invoked immediately, at which point it may alert and
stop right away if `shouldAlert` is already true.  If not, the
function is run again when `shouldAlert` becomes true.

A change to a data dependency does not cause an immediate rerun, but
rather "invalidates" the computation, causing it to rerun the next
time a flush occurs.  A flush will occur automatically as soon as
the system is idle if there are invalidated computations.  You can
also use [`Tracker.flush`](#Tracker-flush) to cause an immediate flush of
all pending reruns.

If you nest calls to `Tracker.autorun`, then when the outer call stops or
reruns, the inner call will stop automatically.  Subscriptions and
observers are also automatically stopped when used as part of a
computation that is rerun, allowing new ones to be established.  See
[`Meteor.subscribe`](./meteor.md#Meteor-subscribe) for more information about
subscriptions and reactivity.

If the initial run of an autorun throws an exception, the computation
is automatically stopped and won't be rerun.

### Tracker.autorun and async callbacks
`Tracker.autorun` can accept an `async` callback function.
 To preserve reactivity for the reactive variables inside the async callback function, you must use a `Tracker.withComputation` call as described below:

<ApiBox name="Tracker.withComputation" />

```javascript
Tracker.autorun(async function example1(computation) {
  // Code before the first await will stay reactive.
  reactiveVar1.get(); // This will trigger a rerun.

  let links = await LinksCollection.find({}).fetchAsync(); // First async call will stay reactive.

  // Code after the first await looses Tracker.currentComputation: no reactivity.
  reactiveVar2.get(); // This won't trigger a rerun.

  // You can bring back reactivity with the Tracker.withCompuation wrapper:
  let users = await Tracker.withComputation(computation, () => Meteor.users.find({}).fetchAsync());

  // Code below will again not be reactive, so you will need another Tracker.withComputation.
  const value = Tracker.withComputation(computation, () => reactiveVar3.get()); // This will trigger a rerun.
});
```

As a rule of thumb, you are okay with wrapping all reactive statements inside a `Tracker.withComputation` to preserve current computation.
But it comes at a performance cost - it should be used only where needed.

Reason behind is, that an await implicitly *"moves"* the code below in a Promise resolved function. When this function runs (after it has been fetched from the micro task queue), `Tracker.withComputation` preserves the reference to the computation of the `Tracker.autorun`.

The `react-meteor-data` package uses `Tracker.withComputation` to make the `useTracker` accept async callbacks.
More can be seen [here](https://github.com/meteor/react-packages/tree/master/packages/react-meteor-data#maintaining-the-reactive-context)

### Using async callbacks in versions of Meteor prior to 2.10
`Tracker.autorun` can accept an `async` callback function.
However, the async call back function will only be dependent on reactive functions called prior to any called functions that return a promise.

Example 1 - autorun `example1()` **is not** dependent on reactive changes to the `Meteor.users` collection.  Because it is dependent on nothing reactive it will run only once:
```javascript
  Tracker.autorun(async function example1() {
    let asyncData = await asyncDataFunction();
    let users = Meteor.users.find({}).fetch();
  });
```

However, simply changing the order so there are no `async` calls prior to the reactive call to `Meteor.users.find`, will make the async autorun `example2()` dependent on reactive changes to the `Meteor.users` collection.

Example 2 -  autorun `example2()` **is** dependent on reactive changes to the Meteor.users collection.  Changes to the `Meteor.users` collection will cause a rerun of `example2()`:
```javascript
  Tracker.autorun(async function example2()  {
    let users = Meteor.users.find({}).fetch();
    let asyncData = await asyncDataFunction();
  });
```
<ApiBox name="Tracker.flush" />

Normally, when you make changes (like writing to the database),
their impact (like updating the DOM) is delayed until the system is
idle. This keeps things predictable &mdash; you can know that the DOM
won't go changing out from under your code as it runs. It's also one
of the things that makes Meteor fast.

`Tracker.flush` forces all of the pending reactive updates to complete.
For example, if an event handler changes a Session
variable that will cause part of the user interface to rerender, the
handler can call `flush` to perform the rerender immediately and then
access the resulting DOM.

An automatic flush occurs whenever the system is idle which performs
exactly the same work as `Tracker.flush`.  The flushing process consists
of rerunning any invalidated computations.  If additional
invalidations happen while flushing, they are processed as part of the
same flush until there is no more work to be done.  Callbacks
registered with [`Tracker.afterFlush`](#Tracker-afterFlush) are called
after processing outstanding invalidations.

It is illegal to call `flush` from inside a `flush` or from a running
computation.

The [Tracker manual](https://github.com/meteor/docs/blob/master/long-form/tracker-manual.md#the-flush-cycle)
describes the motivation for the flush cycle and the guarantees made by
`Tracker.flush` and `Tracker.afterFlush`.

<ApiBox name="Tracker.nonreactive" />

Calls `func` with `Tracker.currentComputation` temporarily set to `null`
and returns `func`'s own return value.  If `func` accesses reactive data
sources, these data sources will never cause a rerun of the enclosing
computation.

<ApiBox name="Tracker.active" />

This value is useful for data source implementations to determine
whether they are being accessed reactively or not.

<ApiBox name="Tracker.inFlush" />

This value indicates, whether a flush is in progress or not.

<ApiBox name="Tracker.currentComputation" />

It's very rare to need to access `currentComputation` directly.  The
current computation is used implicitly by
[`Tracker.active`](#Tracker-active) (which tests whether there is one),
[`dependency.depend()`](#Tracker-Dependency-depend) (which registers that it depends on a
dependency), and [`Tracker.onInvalidate`](#Tracker-onInvalidate) (which
registers a callback with it).

<ApiBox name="Tracker.onInvalidate" />

See [`computation.onInvalidate`](#Tracker-Computation-onInvalidate) for more
details.

<ApiBox name="Tracker.afterFlush" />

Functions scheduled by multiple calls to `afterFlush` are guaranteed
to run in the order that `afterFlush` was called.  Functions are
guaranteed to be called at a time when there are no invalidated
computations that need rerunning.  This means that if an `afterFlush`
function invalidates a computation, that computation will be rerun
before any other `afterFlush` functions are called.


## Tracker.Computation {#tracker_computation}

A Computation object represents code that is repeatedly rerun in
response to reactive data changes.  Computations don't have return
values; they just perform actions, such as rerendering a template on
the screen.  Computations are created using [`Tracker.autorun`](#Tracker-autorun).
Use [`stop`](#Tracker-Computation-stop) to prevent further rerunning of a
computation.

Each time a computation runs, it may access various reactive data
sources that serve as inputs to the computation, which are called its
dependencies.  At some future time, one of these dependencies may
trigger the computation to be rerun by invalidating it.  When this
happens, the dependencies are cleared, and the computation is
scheduled to be rerun at flush time.

The *current computation*
([`Tracker.currentComputation`](#Tracker-currentComputation)) is the
computation that is currently being run or rerun (computed), and the
one that gains a dependency when a reactive data source is accessed.
Data sources are responsible for tracking these dependencies using
[`Tracker.Dependency`](#Tracker-Dependency) objects.

Invalidating a computation sets its `invalidated` property to true
and immediately calls all of the computation's `onInvalidate`
callbacks.  When a flush occurs, if the computation has been invalidated
and not stopped, then the computation is rerun by setting the
`invalidated` property to `false` and calling the original function
that was passed to `Tracker.autorun`.  A flush will occur when the current
code finishes running, or sooner if `Tracker.flush` is called.

Stopping a computation invalidates it (if it is valid) for the purpose
of calling callbacks, but ensures that it will never be rerun.

Example:

```js
// If we're in a computation, then perform some clean-up when the current
// computation is invalidated (rerun or stopped).
if (Tracker.active) {
  Tracker.onInvalidate(() => {
    x.destroy();
    y.finalize();
  });
}
```

<ApiBox name="Tracker.Computation#stop" instanceName="computation"/>

Stopping a computation is irreversible and guarantees that it will
never be rerun.  You can stop a computation at any time, including
from the computation's own run function.  Stopping a computation that
is already stopped has no effect.

Stopping a computation causes its `onInvalidate` callbacks to run
immediately if it is not currently invalidated, as well as its
`stop` callbacks.

Nested computations are stopped automatically when their enclosing
computation is rerun.

<ApiBox name="Tracker.Computation#invalidate"instanceName="computation" />

Invalidating a computation marks it to be rerun at
[flush time](#Tracker-flush), at
which point the computation becomes valid again.  It is rare to
invalidate a computation manually, because reactive data sources
invalidate their calling computations when they change.  Reactive data
sources in turn perform this invalidation using one or more
[`Tracker.Dependency`](#Tracker-Dependency) objects.

Invalidating a computation immediately calls all `onInvalidate`
callbacks registered on it.  Invalidating a computation that is
currently invalidated or is stopped has no effect.  A computation can
invalidate itself, but if it continues to do so indefinitely, the
result will be an infinite loop.

<ApiBox name="Tracker.Computation#onInvalidate" instanceName="computation" />

`onInvalidate` registers a one-time callback that either fires
immediately or as soon as the computation is next invalidated or
stopped.  It is used by reactive data sources to clean up resources or
break dependencies when a computation is rerun or stopped.

To get a callback after a computation has been recomputed, you can
call [`Tracker.afterFlush`](#Tracker-afterFlush) from `onInvalidate`.

<ApiBox name="Tracker.Computation#onStop" instanceName="computation"/>

<ApiBox name="Tracker.Computation#stopped" instanceName="computation"/>

<ApiBox name="Tracker.Computation#invalidated"instanceName="computation"/>

This property is initially false.  It is set to true by `stop()` and
`invalidate()`.  It is reset to false when the computation is
recomputed at flush time.

<ApiBox name="Tracker.Computation#firstRun" instanceName="computation"/>

This property is a convenience to support the common pattern where a
computation has logic specific to the first run.

<ApiBox name="Tracker.Computation#firstRunPromise" instanceName="computation" />

`Computation.firstRunPromise` will be set to the result of the call of the autorun function after the initial computation has been completed. If the autorun function is an async function, it'll then contain its promise, thus making the completion of the execution await-able. That allows us to manually synchronize autoruns like this:

```js

await Tracker.autorun(async () => {
  await Meteor.userAsync();
  (...more async code...)
}).firstRunPromise;

await Tracker.autorun(async () => {
  await asyncSomeOrOther();
  (...more async code...)
}).firstRunPromise;

```

For a better developer experience `firstRunPromise` is automatically appended to your async `autorun` calls so you don't have to write them yourself. Meaning this also works:

```js

await Tracker.autorun(async () => {
  await Meteor.userAsync();
  (...more async code...)
});

await Tracker.autorun(async () => {
  await asyncSomeOrOther();
  (...more async code...)
});

```


## Tracker.Dependency {#Tracker-Dependency}

A Dependency represents an atomic unit of reactive data that a
computation might depend on.  Reactive data sources such as Session or
Minimongo internally create different Dependency objects for different
pieces of data, each of which may be depended on by multiple
computations.  When the data changes, the computations are
invalidated.

Dependencies don't store data, they just track the set of computations to
invalidate if something changes.  Typically, a data value will be
accompanied by a Dependency object that tracks the computations that depend
on it, as in this example:

```js
let weather = 'sunny';
const weatherDep = new Tracker.Dependency();

function getWeather() {
  weatherDep.depend();
  return weather;
}

function setWeather(newWeather) {
  weather = newWeather;

  // Note: We could add logic here to only call `changed` if the new value is
  // different from the old value.
  weatherDep.changed();
}
```

This example implements a weather data source with a simple getter and
setter.  The getter records that the current computation depends on
the `weatherDep` dependency using `depend()`, while the setter
signals the dependency to invalidate all dependent computations by
calling `changed()`.

The reason Dependencies do not store data themselves is that it can be
useful to associate multiple Dependencies with the same piece of data.
For example, one Dependency might represent the result of a database
query, while another might represent just the number of documents in
the result.  A Dependency could represent whether the weather is sunny
or not, or whether the temperature is above freezing.
[`Session.equals`](./session.md#Session-equals) is implemented this way for
efficiency.  When you call `Session.equals('weather', 'sunny')`, the
current computation is made to depend on an internal Dependency that
does not change if the weather goes from, say, `rainy` to `cloudy`.

Conceptually, the only two things a Dependency can do are gain a
dependent and change.

A Dependency's dependent computations are always valid (they have
`invalidated === false`).  If a dependent is invalidated at any time,
either by the Dependency itself or some other way, it is immediately
removed.

See the [Tracker manual](https://github.com/meteor/docs/blob/master/long-form/tracker-manual.md#creating-a-reactive-value-using-trackerdependency)
to learn how to create a reactive data source using `Tracker.Dependency`.

<ApiBox name="Tracker.Dependency#changed" instanceName="dependency"/>

<ApiBox name="Tracker.Dependency#depend" instanceName="dependency"/>

`dependency.depend()` is used in reactive data source implementations to record
the fact that `dependency` is being accessed from the current computation.

<ApiBox name="Tracker.Dependency#hasDependents" instanceName="dependency"/>

For reactive data sources that create many internal Dependencies,
this function is useful to determine whether a particular Dependency is
still tracking any dependency relationships or if it can be cleaned up
to save memory.

---

---
url: /about/modern-build-stack/transpiler-swc.md
---
# Transpiler: SWC

:::info
Starting with Meteor 3.3
:::

> The transpiler converts modern JS syntax in all app code to a cross-browser compatible version.

Meteor has long used Babel, a mature and still widely adopted transpiler. However, it lags behind newer tools like SWC in terms of speed. SWC and others are not only faster but are growing in use and features, reaching parity with Babel.

Since transpilation is one of the slowest steps in development, Meteor now gives you the option to use SWC for your apps.

## Enable SWC

Add this to your app's `package.json`:

```json
"meteor": {
  "modern": true
}
```

When starting your app for web or native, SWC will handle all files: your app, npm packages, and Atmosphere packages. This also applies to production builds.

By default, `"modern": true` enables all build stack upgrades. To opt out of SWC transpiler, set `"transpiler": false` in your `package.json`.

```json
"meteor": {
  "modern": {
    "transpiler": false
  }
}
```

## Verbose transpilation process

To analyze and improve transpilation, you can enable verbose output. Add this to `package.json`:

```json
"meteor": {
  "modern": {
    "transpiler": {
      "verbose": true
    }
  }
}
```

This shows each file being processed, its context, cache usage, and whether it fell back to Babel due to incompatibilities.

## Adapt your code to benefit from SWC

If all your code uses SWC, you're good and can turn off verbosity. But if you [see logs like](https://forums.meteor.com/uploads/default/original/3X/e/1/e1a2c285284f82ab736bcada647d88bd4fa8d3ec.png):

``` shell
[Transpiler] Used Babel for <file>     (<context>)     Fallback
  <more-details>
```

This means SWC encountered syntax incompatibilities on the files. There are a few things you can do.

First, check the fallback details to **fix the syntax**. They might explain why SWC failed.

- A common cause is [**nested import statements** inside functions](#nested-imports). Move them to the top level. These work in Babel due to a Meteor-specific plugin, which SWC doesn’t support.
- Other issues may come from features tied to Babel plugins. You’ll need to find SWC equivalents. See the [SWC plugin list](https://plugins.swc.rs/versions/range/271).

Second, **ignore the fallback** if those files run fine with Babel. SWC will still speed up other files. Meteor will keep using Babel for incompatible files on future builds.

Third, **exclude files or contexts from SWC**. Even though it falls back automatically, you can skip the overhead of trying SWC on known-incompatible files.

For example, if you're using `babel-plugin-react-compiler`, which [SWC doesn't support yet](https://react.dev/blog/2025/04/21/react-compiler-rc), you can exclude your app code adding this to `package.json`:

```json
"meteor": {
  "modern": {
    "transpiler": {
      "excludeApp": true
    }
  }
}
```

Or exclude only specific files like `.jsx`:

```json
"meteor": {
  "modern": {
    "transpiler": {
      "excludeApp": ["\\.jsx"]
    }
  }
}
```

You can also use `excludePackages`, `excludeNodeModules`, and `excludeLegacy` for finer control. See the [`modern.transpiler` config docs](#config-api) for more.

When no plugin exists, these settings let you still get most of SWC’s speed benefits by limiting fallback use.

Most apps will benefit just by enabling `modern: true`. Most Meteor packages should work right away, except ones using nested imports. Node modules will mostly work too, since they follow common standards. Most app code should also work unless it depends on Babel-specific behavior.

> Remember to turn off verbosity when you're done with optimizations.

## Externalize SWC Helpers

By default, SWC inlines transformation helpers (e.g. _extends, _objectSpread) into every file that uses them. While this ensures compatibility out of the box, it can lead to duplicated code across your bundles increasing bundle size.

To centralize these helpers and keep your client builds lean, you can add the `@swc/helpers` in your app project.

``` bash
meteor npm install --save @swc/helpers
```

> This package is installed by default for new apps.

Meteor’s build tool comes pre-configured to externalize SWC helpers for you, no extra setup or .swcrc tweaks are needed. As soon as you install @swc/helpers, Meteor’s SWC pipeline will automatically emit imports for shared helper functions rather than inlining them, ensuring your app ships each helper just once.

## Custom .swcrc

You can use `.swcrc` config in the root of your project to describe specific [SWC plugins](https://github.com/swc-project/plugins) there, that will be applied to compile the entire files of your project.

You can also configure other options using the `.swcrc` format. For custom SWC configs, see the [SWC configuration API](https://swc.rs/docs/configuration/compilation).

Use `swc.config.js` in your project root for dynamic configuration. Meteor will import and apply the SWC config automatically. This lets you choose a config based on environment variables or other runtime factors.

You can also review these migration topics that use custom `.swcrc` configs:

- [Import Aliases](#import-aliases)
- [JSX Syntax in JS files](#jsx-syntax-in-js-files)
- [React Runtime](#react-runtime)
- [Transform Imports](#transform-imports)
- [Private Properties](#private-properties)

:::warning
The standard name for the SWC configuration file is [`.swcrc`](https://swc.rs/docs/configuration/compilation).

Using as an extension, such as `config.swcrc`, won’t work.
:::

## Config API

- `modern.transpiler: [true|false]` - Default: `true`
  Enables or disables the use of the modern transpiler (SWC). If disabled, Babel will be used directly instead.

- `modern.transpiler.excludeApp: [true|false] or [string[]]`
  If true, the app’s own code (outside of Meteor core and packages) will continue using Babel.
  Otherwise, a list of file paths or regex-like patterns within the app to exclude from SWC transpilation.

- `modern.transpiler.excludeNodeModules: [true|false] or [string[]]`
  If true, the app’s node_modules will continue using Babel.
  Otherwise, a list of NPM packages names, file paths or regex-like patterns within the node_modules folder to exclude from SWC transpilation.

- `modern.transpiler.excludePackages: [true|false] or [string[]]`
  If true, the Meteor’s packages will continue using Babel.
  Otherwise, a list of package names, file paths or regex-like patterns within the package to exclude from SWC transpilation.

- `modern.transpiler.excludeLegacy: [true|false]`
  If true, the Meteor’s bundle for legacy browsers will continue using Babel.

- `modern.transpiler.verbose: [true|false]`
  If true, the transpilation process for files is shown when running the app. This helps understand which transpiler is used for each file, what fallbacks are applied, and gives a chance to either exclude files to always use Babel or migrate fully to SWC.

## Migration Topics

### Nested Imports

Nested imports are a Meteor-specific feature in its bundler, unlike standard bundlers. Meteor introduced them during a time when bundling standards were still evolving and experimented with its own approach. This feature comes from the [`reify` module](https://github.com/benjamn/reify/tree/main) and works with Babel transpilation. SWC doesn't support them since they were never standardized.

Example with a nested import:

``` javascript
if (condition) {
  import { a as b } from "./c";
  console.log(b);
}
```

Without a nested import (moved to top):

``` javascript
import { a as b } from "./c";

if (condition) {
  console.log(b);
}
```

For background, see: [Why nested import](https://github.com/benjamn/reify/blob/main/WHY_NEST_IMPORTS.md).

With `"modern.transpiler": true`, if SWC finds one, it silently falls back to Babel (only shows in `"verbose": true`). Nested imports isn’t standard, most modern projects use other deferred loading methods. You might want to move imports to the top or use require instead, letting SWC handle the file and speeding up builds. Still, this decision is up to the devs, some Meteor devs use them for valid reasons.

### Import Aliases

Meteor Babel lets you define aliases for import paths with [babel-plugin-module-resolver](https://www.npmjs.com/package/babel-plugin-module-resolver).

To use the same aliases in SWC, add them to your [.swcrc](#custom-swcrc):

```json
{
  "jsc": {
    "baseUrl": "./",
    "paths": {
      "@ui/*": ["ui/*"]
    }
  }
}
```

This enables you to use `@ui/components` instead of `./ui/components` in your imports.

You can use `swc.config.js` to define different aliases based on an environment variable.

``` js
var mode = process.env.MODE_ENV;

var userAliases = {
  "@ui/*": ["user/*"],
};

var adminAliases = {
  "@ui/*": ["admin/*"],
};

module.exports = {
    jsc: {
        baseUrl: "./",
        paths: mode === "USER" ? userAliases : adminAliases,
    },
};
```

:::warning
SWC only resolves aliases to imports, not `require` calls.
:::

- Imports

Binding imports inject a module to use.

``` javascript
// Binding imports
import Button from "@ui/button";
import { Button } from "@ui/button";
```

Side-effect imports run the module’s code.

``` javascript
// Side effect import
import "@ui/button";
```

- Require calls

Can import values or run the module’s code.

``` javascript
const { Button } = require("@ui/button");

require("@ui/button");
```

SWC resolve aliases for imports correctly, but require calls won’t. For require calls, use an import or a relative path.

SWC has no [module-resolver plugin like Babel’s](https://www.npmjs.com/package/babel-plugin-module-resolver) yet, which could affect require calls in the future.

### JSX Syntax in JS files

When migrating your app to use SWC, Meteor SWC falls back to Babel if you include JSX in `.js` files, since JSX is only recognized in `.jsx` files.

To enable JSX in `.js` files, create a [`.swcrc`](#custom-swcrc) file with this config:

``` json
{
  "jsc": {
    "parser": {
      "syntax": "ecmascript",
      "jsx": true
    }
  }
}
```

> For TypeScript, set "syntax": "typescript" and "tsx": true instead.

This overrides Meteor’s internal SWC config so SWC handles `.js` and `.ts` files with React components instead of falling back to Babel.

### React Runtime

Meteor Babel lets you skip importing React in your files by using the [`@babel/plugin-transform-react-jsx`](https://www.npmjs.com/package/@babel/plugin-transform-react-jsx) runtime config.

To use the same config in SWC, add it to your [`.swcrc`](#custom-swcrc):

```json
{
  "jsc": {
    "transform": {
      "react": {
        "runtime": "automatic"
      }
    }
  }
}
```

### Transform Imports

You might have used Meteor Babel with the  [`babel-plugin-transform-imports`](https://www.npmjs.com/package/babel-plugin-transform-imports) plugin to rewrite imports in your app.

SWC offers a similar plugin: [`@swc/plugin-transform-imports`](https://www.npmjs.com/package/@swc/plugin-transform-imports).

To switch to SWC, install the plugin: 

```bash
meteor npm install -D @swc/plugin-transform-imports
```

and add it to your [`.swcrc`](#custom-swcrc):

```json
{
  "jsc": {
    "experimental": {
      "plugins": [
        [
          "@swc/plugin-transform-imports",
          {
            "lodash": {
              "transform": "lodash/{{member}}",
              "preventFullImport": true
            }
          }
        ]
      ]
    }
  }
}
```

This tells SWC to replace, for example,

``` javascript
import { map } from "lodash"
```

with

``` javascript
import map from "lodash/map"
```

avoiding full-package imports and reducing bundle size.

You can use advanced import transformations. [See the test suite for examples.](https://github.com/swc-project/plugins/blob/main/packages/transform-imports/__tests__/wasm.test.ts#L12-L63)


### Private Properties

SWC supports many of the most modern JS systax features, including private class properties, which Meteor Babel doesn’t.

Just by enabling SWC, Meteor will parse properly code like:

``` javascript
class ClassWithPrivate {
  #privateField;
  #privateFieldWithInitializer = 42;
  
  #privateMethod() {}
  
  static #privateStaticField;
  static #privateStaticFieldWithInitializer = 42;

  static #privateStaticMethod() {}
}
```

You can opt-out of [private properties in SWC options with "privateMethod" setting](https://swc.rs/docs/configuration/compilation#ecmascript) with the [`.swcrc`](#custom-swcrc) file.

## Troubleshotting

If you run into issues, try `meteor reset` or delete the `.meteor/local` folder in the project root.

For help or to report issues, post on [GitHub](https://github.com/meteor/meteor/issues) or the [Meteor forums](https://forums.meteor.com). We’re focused on making Meteor faster and your feedback helps.

You can compare performance before and after enabling `modern` by running [`meteor profile`](../../cli/index.md#meteorprofile). Share your results to show progress to others.

> **[Check out modern bundler options](bundler.md) to improve performance and access newer build features.**

---

---
url: /api/index.md
---
<ApiMap />


---

---
url: /generators/meteor-versions/README.md
---
## Meteor version generator for docs

This is a generator for the meteor versions for the docs, this is used to generate the links in the docs
to the correct version of the meteor release and docs version.


## Why?

This is a way to ensure that the links in the docs are always pointing to the correct version of the docs and release.
In an automated way.


## How to use

To use this generator you must run the following command:

```bash
node script.js
```

and it will check in the `changelog` dir for every version and generate a `versions.generated.json` file that will be used by the docs to generate the links to the correct version of the docs.


---

---
url: /generators/changelog/versions/3.3.0.md
---
## v3.3.0, 2025-06-11

### Highlights

- Support SWC transpiler and minifier for faster dev and builds [PR#13657](https://github.com/meteor/meteor/pull/13657),  [PR#13715](https://github.com/meteor/meteor/pull/13715)
- Switch to `@parcel/watcher` for improved native file watching [PR#13699](https://github.com/meteor/meteor/pull/13699), [#13707](https://github.com/meteor/meteor/pull/13707)
- Default to modern architecture, skip legacy processing [PR#13665](https://github.com/meteor/meteor/pull/13665), [PR#13698](https://github.com/meteor/meteor/pull/13698)
- Optimize SQLite for faster startup and better performance [PR#13702](https://github.com/meteor/meteor/pull/13702)
- Support CPU profiling in Meteor 3 bundler [PR#13650](https://github.com/meteor/meteor/pull/13650)
- Improve `meteor profile`: show rebuild steps and total, support `--build` [PR#16](https://github.com/meteor/performance/pull/16), [PR#13694](https://github.com/meteor/meteor/pull/13694)
- Improve `useFind` and `useSubscribe` React hooks
- Add `replaceEmailAsync` helper to Accounts [PR#13677](https://github.com/meteor/meteor/pull/13677)
- Fix user agent detection and oplog collection filtering
- Refine type definitions for Meteor methods and SSR's ServerSink
- Allow opting out of usage stats with `DO_NOT_TRACK`
- Update Node to 22.16.0 and Express to 5.1.0

All Merged PRs@[GitHub PRs 3.3](https://github.com/meteor/meteor/pulls?q=is%3Apr+is%3Amerged+base%3Arelease-3.3)

React Packages Changelog: [react-meteor-data@4.0.0](https://github.com/meteor/react-packages/tree/master/packages/react-meteor-data/CHANGELOG.md#v400-2025-06-11)

#### Breaking Changes

- File watching strategy switched to `@parcel/watcher`
    - Most setups should be fine, but if issues appear, like when using WSL with host, volumes, or remote setups—switch to polling.
    - Set `METEOR_WATCH_FORCE_POLLING=true` to enable polling.
    - Set `METEOR_WATCH_POLLING_INTERVAL_MS=1000` to adjust the interval.

- `react-meteor-data@4.0.0`
  - Independent from the core, only applies if upgraded manually.
  - useFind describes no deps by default [PR#431](https://github.com/meteor/react-packages/pull/431)

####  Internal API changes

- `express@5.1.0` - Depends on Meteor’s `webapp` package.
  - Deprecates non-native promise usage [#154](https://github.com/pillarjs/router/pull/154)
  - Use `async/await` or `Promise.resolve` when defining endpoints to avoid deprecation warnings.

#### Migration Steps

Please run the following command to update your project:

```bash
meteor update --release 3.3
```

To apply react-meteor-data changes:

```bash
meteor add react-meteor-data@4.0.0
```

**Add this to your `package.json` to enable the new modern build stack:**

```json
"meteor": {
  "modern": true
}
```

> These settings are on by default for new apps.

On activate `modern` your app will be updated to use SWC transpiler. It will automatically fallback to Babel if your code can't be transpiled wit SWC.

Check the docs for help with the SWC migration, especially if your project uses many Babel plugins.

[Modern Transpiler: SWC docs](https://docs.meteor.com/about/modern-build-stack/transpiler-swc.html)

If you find any issues, please report them to the [Meteor issues tracker](https://github.com/meteor/meteor).

#### Bumped Meteor Packages

- accounts-base@3.1.1
- accounts-password@3.2.0
- autoupdate@2.0.1
- babel-compiler@7.12.0
- boilerplate-generator@2.0.1
- ddp-client@3.1.1
- ecmascript@0.16.11
- ejson@1.1.5
- meteor@2.1.1
- minifier-js@3.0.2
- modern-browsers@0.2.2
- mongo@2.1.2
- server-render@0.4.3
- socket-stream-client@0.6.1
- standard-minifier-js@3.1.0
- typescript@5.6.4
- webapp@2.0.7
- meteor-tool@3.3.0

#### Bumped NPM Packages

- meteor-node-stubs@1.2.17

#### Special thanks to

✨✨✨

- [@nachocodoner](https://github.com/nachocodoner)  
- [@italojs](https://github.com/italojs)
- [@Grubba27](https://github.com/Grubba27)  
- [@zodern](https://github.com/zodern)
- [@9Morello](https://github.com/9Morello)
- [@welkinwong](https://github.com/welkinwong)
- [@Poyoman39](https://github.com/Poyoman39)
- [@PedroMarianoAlmeida](https://github.com/PedroMarianoAlmeida)
- [@harryadel](https://github.com/harryadel)
- [@ericm546](https://github.com/ericm546)
- [@StorytellerCZ](https://github.com/StorytellerCZ)

✨✨✨ 

---

---
url: /generators/changelog/versions/3.3.2.md
---
## v3.3.2, 01-09-2025

### Highlights

- Async-compatible account URLs and email-sending coverage [#13740](https://github.com/meteor/meteor/pull/13740)
- Move `findUserByEmail` method from `accounts-password` to `accounts-base` [#13859](https://github.com/meteor/meteor/pull/13859)
- Return `insertedId` on client `upsert` to match Meteor 2.x behavior [#13891](https://github.com/meteor/meteor/pull/13891)
- Unrecognized operator bug fixed [#13895](https://github.com/meteor/meteor/pull/13895)
- Security fix for `sha.js` [#13908](https://github.com/meteor/meteor/pull/13908)


All Merged PRs@[GitHub PRs 3.3.2](https://github.com/meteor/meteor/pulls?q=is%3Apr+is%3Amerged+base%3Arelease-3.3.2)

#### Breaking Changes

N/A

##### Cordova Upgrade

- Enable modern browser support for Cordova unless explicitly disabled [#13896](https://github.com/meteor/meteor/pull/13896)

####  Internal API changes

- lodash.template dependency was removed [#13898](https://github.com/meteor/meteor/pull/13898)

#### Migration Steps

Please run the following command to update your project:

```bash
meteor update --release 3.3.2
```

---

If you find any issues, please report them to the [Meteor issues tracker](https://github.com/meteor/meteor).

#### Bumped Meteor Packages

- accounts-base@3.1.2
- accounts-password@3.2.1
- accounts-passwordless@3.0.2
- meteor-node-stubs@1.2.24
- babel-compiler@7.12.2
- boilerplate-generator@2.0.2
- ecmascript@0.16.13
- minifier@3.0.4
- minimongo@2.0.4
- mongo@2.1.4
- coffeescript-compiler@2.4.3
- npm-mongo@6.16.1
- shell-server@0.6.2
- typescript@5.6.6

#### Bumped NPM Packages

- meteor-node-stubs@1.2.23

#### Special thanks to

✨✨✨

- [@italojs](https://github.com/italojs)
- [@nachocodoner](https://github.com/nachocodoner)
- [@graemian](https://github.com/graemian)
- [@Grubba27](https://github.com/Grubba27)
- [@copleykj](https://github.com/copleykj)

✨✨✨

---

---
url: /generators/changelog/versions/3.3.1.md
---
## v3.3.1, 05-08-2025

### Highlights

- **MongoDB Driver Upgrades**
  - Upgraded core MongoDB driver to `6.16.0` to address latest issues reported [#13710](https://github.com/meteor/meteor/pull/13710)
  - Introduced `npm-mongo-legacy` to maintain compatibility with MongoDB 3.6 via `mongodb@6.9.0` [#13736](https://github.com/meteor/meteor/pull/13736)
  - Mitigated a cursor leak issue by synchronizing `next()` and `close()` operations [#13786](https://github.com/meteor/meteor/pull/13786)

- **Improved SWC integration**
  - Fixed edge cases in config cache invalidation [#13809](https://github.com/meteor/meteor/pull/13809)
  - Ensured `@swc/helpers` is consistently used for better bundle size and performance [#13820](https://github.com/meteor/meteor/pull/13820)
  - Updated to SWC `1.12.14` [#13851](https://github.com/meteor/meteor/pull/13851)

- **Tooling and Build System**
  - Fixed regression affecting rebuild behavior [#13810](https://github.com/meteor/meteor/pull/13810)
  - Addressed issues getting performance profiles in mounted volumes [#13827](https://github.com/meteor/meteor/pull/13827)
  - Fallback to Babel parser when Acorn fails to parse source code [#13844](https://github.com/meteor/meteor/pull/13844)

- **Mobile Support**
  - Upgraded Cordova platform to version 14 [#13837](https://github.com/meteor/meteor/pull/13837)

- **Developer Experience**
  - Added TypeScript types for `isModern` and `getMinimumBrowserVersions` functions [#13704](https://github.com/meteor/meteor/pull/13704)
  - Enhanced CLI help output and documented admin commands [#13826](https://github.com/meteor/meteor/pull/13826)

- **Vite Tooling**
  - Updated official Meteor + Vite skeletons [#13835](https://github.com/meteor/meteor/pull/13835)

- **Runtime & Dependencies**
  - Updated to Node.js `22.18.0` and NPM `10.9.3` [#13877](https://github.com/meteor/meteor/pull/13877)
  - Bumped `meteor-node-stubs` to `1.2.21` [#13825](https://github.com/meteor/meteor/pull/13825)

All Merged PRs@[GitHub PRs 3.3.1](https://github.com/meteor/meteor/pulls?q=is%3Apr+is%3Amerged+base%3Arelease-3.3.1)

#### Breaking Changes

##### MongoDB Driver Upgrades

If you're using MongoDB 3.6 or earlier, install the new legacy package:

```bash
meteor add npm-mongo-legacy
```
This will pin the MongoDB driver to 6.9.0 for compatibility.

If you’re on MongoDB 4+, the default [MongoDB driver 6.16.0](https://github.com/mongodb/node-mongodb-native/releases/tag/v6.16.0) is applied automatically.

Please migrate your database as soon as possible to MongoDB 5 onward, as [MongoDB driver 6.17.0](https://github.com/mongodb/node-mongodb-native/releases/tag/v6.17.0) will drop MongoDB 4 support. We’ll keep offering `npm-mongo-legacy` so you can keep getting Meteor updates with your existing MongoDB legacy version.

##### Cordova Upgrade

The Cordova platform has been upgraded to version 14. Refer to the [Cordova Changelog](https://cordova.apache.org/announcements/2025/03/26/cordova-android-14.0.0.html) for more details on the changes and migration steps.

####  Internal API changes

N/A

#### Migration Steps

Please run the following command to update your project:

```bash
meteor update --release 3.3.1
```

---

While this is a patch release, Meteor 3.3, a recent minor update, introduced a modern build stack that’s now the default for new apps. Here’s how you can migrate to it.

**Add this to your `package.json` to enable the new modern build stack:**

```json
"meteor": {
  "modern": true
}
```

Check the docs for help with the SWC migration, especially if your project uses many Babel plugins.

[Modern Transpiler: SWC docs](https://docs.meteor.com/about/modern-build-stack/transpiler-swc.html)

If you find any issues, please report them to the [Meteor issues tracker](https://github.com/meteor/meteor).

#### Bumped Meteor Packages

- babel-compiler@7.12.1
- callback-hook@1.6.1
- ecmascript@0.16.12
- minifier-js@3.0.3
- minimongo@2.0.3
- modern-browsers@0.2.3
- mongo@2.1.3
- npm-mongo-legacy@6.9.0
- npm-mongo@6.16.0
- standard-minifier-js@3.1.1
- tinytest@1.3.2
- typescript@5.6.5
- meteor-tool@3.3.1

#### Bumped NPM Packages

- meteor-node-stubs@1.2.21

#### Special thanks to

✨✨✨

- [@nachocodoner](https://github.com/nachocodoner)
- [@italojs](https://github.com/italojs)
- [@StorytellerCZ](https://github.com/StorytellerCZ)
- [@JorgenVatle](https://github.com/JorgenVatle)
- [@welkinwong](https://github.com/welkinwong)
- [@Saksham-Goel1107](https://github.com/Saksham-Goel1107)

✨✨✨ 

---

---
url: /generators/changelog/versions/3.2.2.md
---
## v3.2.2, 2025-05-02

### Highlights

- Improved parsing of `x-forwarded-for` headers in Session._clientAddress:
  - Changed header splitting method to handle comma-separated values more reliably
  - Added explicit trimming of IP addresses with map function
  - Modified validation check to require exact match for httpForwardedCount


#### Breaking Changes

N/A

####  Internal API changes

N/A

#### Migration Steps

Please run the following command to update your project:

```bash

meteor update --release 3.2.2

```

#### Bumped Meteor Packages

- ddp-server@3.1.1

#### Bumped NPM Packages


#### Special thanks to

✨✨✨

- [@italojs](https://github.com/italojs)
- [@ShiyuBanzhou](https://github.com/ShiyuBanzhou)


✨✨✨

---

---
url: /generators/changelog/versions/3.2.0.md
---
## v3.2.0, 2025-03-18

### Highlights

- Upgrade to Node 22.14.0 & Mongo 7.0.16.
- Implement `meteor profile` command to show performance metrics of Meteor apps.
- Fix Meteor profiler to handle promises and display metrics correctly.
- Support for argon2 to improve password security over bcrypt. [PR #13554](https://github.com/meteor/meteor/pull/13554)
- Improve and fix package resolution logic. [PR #13604](https://github.com/meteor/meteor/pull/13604)
- Fix rare oplog issue that could cause data loss for clients. [PR #13603](https://github.com/meteor/meteor/pull/13603) 

All detailed PRs can be found here: https://github.com/meteor/meteor/pulls?q=is%3Apr+is%3Amerged+base%3Arelease-3.2

#### Breaking Changes

N/A

####  Internal API changes

N/A

#### Migration Steps

Please run the following command to update your project:

```bash

meteor update --release 3.2

```

#### Bumped Meteor Packages

- accounts-base@3.1.0
- accounts-password@3.1.0
- ecmascript-runtime-client@0.12.3
- facebook-oauth@1.11.6
- fetch@0.1.6
- logging@1.3.6
- logic-solver@3.1.0
- minifier-css@2.0.1
- meteor-tool@3.2.0
- modern-browsers@0.2.1
- mongo@2.1.1
- oauth@3.0.2
- test-helpers@2.0.3

#### Bumped NPM Packages

- meteor-node-stubs@1.2.13

#### Special thanks to

✨✨✨

- [@nachocodoner](https://github.com/nachocodoner)
- [@Grubba27](https://github.com/Grubba27)
- [@vparpoil](https://github.com/vparpoil)
- [@cunneen](https://github.com/cunneen)
- [@gbuerk](https://github.com/gbuerk)
- [@julio-rocketchat](https://github.com/julio-rocketchat)
- [@StorytellerCZ](https://github.com/StorytellerCZ)
- [@dr-dimitru](https://github.com/dr-dimitru)
- [@Seb-Dion](https://github.com/Seb-Dion)

✨✨✨

---

---
url: /generators/changelog/versions/3.1.2.md
---
## v3.1.2, 2025-02-06

### Highlights

- Node upgrade: v22.13.1
- Updated Meteor skeletons for Vue and Solid
- Improved browser detection and related documentation
- Security updates: nodemailer-openpgp and others in Meteor packages

#### Breaking Changes

N/A

####  Internal API changes

N/A

#### Migration Steps

Please run the following command to update your project:

```bash

meteor update --release 3.1.2

```

#### Bumped Meteor Packages

- email@3.1.2
- meteor-tool@3.1.2
- modern-browsers@0.2.0
- webapp@2.0.5

#### Bumped NPM Packages

N/A

#### Special thanks to

✨✨✨

- [@nachocodoner](https://github.com/nachocodoner)
- [@Grubba27](https://github.com/Grubba27)
- [@perbergland](https://github.com/perbergland)
- [@StorytellerCZ](https://github.com/StorytellerCZ)
- [@julio-rocketchat](https://github.com/julio-rocketchat)

✨✨✨

---

---
url: /generators/changelog/versions/3.1.1.md
---
## v3.1.1, 2025-01-15

### Highlights

- Node upgrade: v22.13.0
- Real-time Performance Boost: Refactored AsynchronousQueue for parallel processing and optimized MongoDB observers for faster initial document handling.
- Allow/Deny Rules Update: Deprecated async rules and updated documentation and types.
- Mongo Driver Downgrade: Reverted to a stable version to prevent issues in Meteor.
- Support for Meteor.deprecate: Added deprecation warnings with stack trace for outdated code usage.
- OAuth Fixes: Resolved issues with cancel popup event and callback.
- Windows Fixes: Fixed issues with running from folders with spaces and post-npm install build errors on Windows.
- Security Updates: Upgraded json5 and semver from babel compiler.

#### Breaking Changes

N/A

####  Internal API changes

N/A

#### Migration Steps

Please run the following command to update your project:

```bash

meteor update --release 3.1.1

```

#### Bumped Meteor Packages

- accounts-base@3.0.4
- accounts-oauth@1.4.6
- accounts-passwordless@3.0.1
- allow-deny@2.1.0
- babel-compiler@7.11.3
- ddp-client@3.1.0
- ddp-server@3.1.0
- meteor-tool@3.1.1
- facebook-oauth@1.11.5
- meteor@2.1.0
- meteor-tool@3.1.1
- mongo@2.1.0
- npm-mongo@6.10.2
- oauth@3.0.1
- roles@@1.0.1
- socket-stream-client@0.6.0

#### Bumped NPM Packages

N/A

#### Special thanks to

✨✨✨

- [@leonardoventurini](https://github.com/leonardoventurini)
- [@nachocodoner](https://github.com/nachocodoner)
- [@Grubba27](https://github.com/Grubba27)
- [@9Morello](https://github.com/9Morello)
- [@perbergland](https://github.com/perbergland)
- [@StorytellerCZ](https://github.com/StorytellerCZ)
- [@MrSpark2591](https://github.com/MrSpark2591)
- [@jstarpl](https://github.com/jstarpl)
- [@minhna](https://github.com/minhna)
- [@svolkomorov](https://github.com/svolkomorov)
- [@quyetdgroup](https://github.com/quyetdgroup)

✨✨✨

---

---
url: /generators/changelog/versions/3.1.0.md
---
## v3.1.0, 2024-11-20

### Highlights

- Upgrade to Node v22
- Upgrade Mongo Driver to v6
- Upgrade Express to v5
- HMR performance improvements
- Bring the `roles` package into the core
- Solve remaining issues with Top Level Await and Reify
- Refactor part of the real-time code in the `mongo` package into TypeScript
- Deprecate `underscore` and eliminate it from packages
- Fix Cordova dependency issues
- Simplify Meteor.EnvironmentVariable and make sure it works in all cases
- Stop using Rosetta for development MongoDB on Apple Silicon
- Test improvements
- Bump `http` package to 3.0.0

#### Breaking Changes

- Express is now at v5 and some it's APIs have changed.

####  Internal API changes

N/A

#### Migration Steps

Please run the following command to update your project:

```bash

meteor update --release 3.1

```

Make sure to migrate userland code to use the new Express APIs:

https://expressjs.com/en/guide/migrating-5.html

The MongoDB Node.js driver implemented a significant breaking change regarding operation handling. Applications leveraging `rawCollection()` or `rawDatabase()` methods must now utilize Promise-based syntax exclusively, as the callback-pattern API has been deprecated and removed. This modification affects all direct MongoDB operations previously using callback functions.


#### Bumped Meteor Packages

- accounts-password@3.0.3
- babel-compiler@7.11.2
- boilerplate-generator-tests@1.5.3
- ddp-client@3.0.3
- ddp-server@3.0.3
- http@3.0.0
- ecmascript@0.16.10
- email@3.1.1
- meteor-tool@3.1.0
- meteor@2.0.2
- minifier-js@3.0.1
- minimongo@2.0.2
- modules@0.20.3
- mongo@2.0.3
- coffeescript-compiler@2.4.2
- coffeescript@2.7.2
- mongo-decimal@0.2.0
- npm-mongo@6.10.0
- shell-server@0.6.1
- test-helpers@2.0.2
- test-in-console@2.0.1
- tinytest@1.3.1
- typescript@5.6.3
- url@1.3.5
- webapp@2.0.4


#### Bumped NPM Packages

- meteor-babel@7.20.1
- meteor-installer@3.1.0
- meteor-node-stubs@1.2.12


#### Special thanks to

✨✨✨

- [@denihs](https://github.com/denihs)
- [@nachocodoner](https://github.com/nachocodoner)
- [@leonardoventurini](https://github.com/leonardoventurini)
- [@StorytellerCZ](https://github.com/StorytellerCZ)
- [@zodern](https://github.com/zodern)
- [@harry97](https://github.com/harry97)
- [@permb](https://github.com/permb)
- [@9Morello](https://github.com/9Morello)
- [@wreiske](https://github.com/wreiske)
- [@MarcoTribuz](https://github.com/MarcoTribuz)
- [@MeteorCoder](https://forums.meteor.com/u/meteorcoder/summary)

✨✨✨

---

---
url: /generators/changelog/versions/3.0.4.md
---
## v3.0.4, 2024-10-15

### Highlights

- Node 20.18.0 & Typescript 5.6.2
- Updated webapp dependencies.
- DDP-server and DDP-client removed underscore
- Remove dependencies on Blaze packages when using static-html
- Fix Cordova on Windows
- Fix Cordova build on using plugins describing dependencies
- Various Windows specific fixes

#### Breaking Changes

N/A

####  Internal API changes

N/A

#### Migration Steps

Please run the following command to update your project:

```bash

meteor update --release 3.0.4

```

#### Meteor Version Release

* `Bumped packages`:
  - accounts-base@3.0.3                
  - babel-compiler@7.11.1              
  - caching-compiler@2.0.1             
  - check@1.4.4                        
  - ddp-client@3.0.2                   
  - ddp-server@3.0.2                   
  - ecmascript-runtime@0.8.3           
  - modules@0.20.2                     
  - static-html-tools@1.0.0            
  - static-html@1.4.0                  
  - url@1.3.4                          
  - webapp@2.0.3                       
  - meteor-tool@3.0.4

#### Special thanks to
N/A

---

---
url: /generators/changelog/versions/3.0.3.md
---
## v3.0.3, 2024-09-11

### Highlights

- Fixed `Meteor.userId` only being invoked with `bindEnvironment`.
- Updated to Node `20.17.x`.
- Fixed an issue where `meteor --open` opens the browser before the app is started.
- Investigated and addressed the error when installing the `jam:method` package.
- Improved the message for new available versions when running an app.
- Updated the documentation link inside `install.sh`.
- Resolved the issue where subscriptions stopped after a parameter change.
- Added MongoDB connection telemetry.
- Bumped the `email` package to prevent update errors.
- Cordova package updates

#### Breaking Changes

N/A

####  Internal API changes

- Some internal changes to how async contexts are handled, ensuring better performance and garbage collection.

#### Migration Steps

Please run the following command to update your project:

```bash

meteor update --release 3.0.3

```

If you've had your Meteor installation for over a year, we suggest reinstalling it to avoid any package installation issues. You can do this by running a few quick commands:

```bash
npx meteor uninstall // or rm -rf ~/.meteor
npx meteor
```



#### Meteor Version Release

* `Bumped packages`:
  - accounts-base@3.0.2
  - accounts-password@3.0.2
  - email@3.1.0
  - mongo@2.0.2


#### Special thanks to

- [@ayewo](https://github.com/ayewo).
- [@denihs](https://github.com/denihs).
- [@harryadel](https://github.com/harryadel).
- [@kbarr1212](https://github.com/kbarr1212).
- [@leonardoventurini](https://github.com/leonardoventurini).
- [@nachocodoner](https://github.com/nachocodoner).


---

---
url: /generators/changelog/versions/3.0.2.md
---
## v3.0.2, 2024-08-14

### Highlights

* Bump the patch for some packages, so we publish them using Meteor 3 tooling. [PR #13231]
* Fix subscription still resetting documents [PR #13236]
* Fix auth sub sending ready twice on load [PR #13247]
* Remove version constraints from http package in accounts-twitter [PR #13268]
* Deprecate Meteor.user() usage on server side [PR #13288]

#### Breaking Changes

N/A

####  Internal API changes

N/A

#### Migration Steps

Please run the following command to update your project:

```bash

meteor update --release 3.0.2

```


#### Meteor Version Release

* `Bumped packages`:
  - accounts-2fa@3.0.1
  - accounts-base@3.0.1
  - accounts-password@3.0.1
  - accounts-twitter@1.5.2
  - ddp-client@3.0.1
  - ddp-common@1.4.4
  - ddp-server@3.0.1
  - email@3.0.1
  - meteor@2.0.1
  - minimongo@2.0.1
  - mongo@2.0.1
  - npm-mongo@4.17.4
  - test-helpers@2.0.1
  - webapp@2.0.1



#### Special thanks to

- [@leonardoventurini](https://github.com/leonardoventurini).
- [@StorytellerCZ](https://github.com/StorytellerCZ).


For making this great framework even better!



---

---
url: /generators/changelog/versions/3.0.1.md
---
## v3.0.1, 2024-07-16

### Highlights

* Bump the patch for some packages, so we publish them using Meteor 3 tooling. [PR #13231]

#### Breaking Changes

N/A

####  Internal API changes

N/A

#### Migration Steps

Please run the following command to update your project:

```bash

meteor update --release 3.0.1

```


#### Meteor Version Release


* `Bumped packages`:
  - accounts-ui-unstyled@1.7.2
  - crosswalk@1.7.3
  - facebook-oauth@1.11.4
  - npm-mongo@4.17.3
  - package-version-parser@3.2.3
  - twitter-config-ui@1.0.2


#### Special thanks to

- [@denihs](https://github.com/denihs).


For making this great framework even better!



---

---
url: /generators/changelog/versions/3.0.0.md
---
## v3.0, 2024-07-15

### Highlights

#### Breaking Changes

- Meteor tool
  - 'meteor reset' command only affects the local project cache. Use `--db` option to also remove the local database.

- `accounts-2fa@3.0.0`:

  - Some methods are now async. See below:
  - `Accounts._is2faEnabledForUser`
  - `(Meteor Method) - generate2faActivationQrCode`
  - `(Meteor Method) - enableUser2fa`
  - `(Meteor Method) - disableUser2fa`
  - `(Meteor Method) - has2faEnabled`

- `accounts-base@3.0.0`:

  - `methods.removeOtherTokens` is now async
  - `Accounts.destroyToken` is now async
  - `Accounts.insertUserDoc` is now async
  - `Accounts.updateOrCreateUserFromExternalService` is now async
  - `Accounts.expirePasswordToken` is now async
  - `Accounts.setupUsersCollection` is now async
  - `Meteor.user` is now async in server

- `accounts-facebook@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `accounts-github@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `accounts-google@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `accounts-meetup@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `accounts-meteor-developer@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `accounts-oauth@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `accounts-password@3.0.0`:

  - Some server methods are now async:
  - `Accounts.sendResetPasswordEmail`
  - `Accounts.sendEnrollmentEmail`
  - `Accounts.sendVerificationEmail`
  - `Accounts.addEmail`
  - `Accounts.removeEmail`
  - `Accounts.replaceEmailAsync`
  - `Accounts.verifyEmail`
  - `Accounts.createUserVerifyingEmail`
  - `Accounts.createUser`
  - `Accounts.generateVerificationToken`
  - `Accounts.generateResetToken`
  - `Accounts.forgotPassword`
  - `Accounts.setPassword` -- no longer exists, you should use Accounts.setPasswordAsync [PR](https://github.com/meteor/meteor/pull/13030)
  - `Accounts.changePassword`
  - `Accounts.setUsername`
  - `Accounts.findUserByEmail`
  - `Accounts.findUserByUsername`

- `accounts-passwordless@3.0.0`:

  - `Accounts.sendLoginTokenEmail` is now async.

- `accounts-twitter@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `accounts-ui-unstyled@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `accounts-ui@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `accounts-weibo@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `allow-deny@2.0.0`:

  - Updated to accept async functions.

- `appcache@2.0.0`:

  - Updated internal api to use `handlers`

- `audit-argument-checks@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `autopublish@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `autoupdate@2.0.0`:

  - Updated api to be async, with asyncronous queueing.

- `babel-compiler@8.0.0`:

  - Removed `Promise.await` default transform.
  - Added top-level-await to packages.

- `babel-runtime@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `base64@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `binary-heap@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- Build system:
  - removed `Assets.getText`
  - removed `Assets.getBinary`

- `blaze@3.0.0`:
  - Todo

- `boilerplate-generator-tests@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `boilerplate-generator@2.0.0`:

  - `toHTML` is no longer available (it was already deprecated). Use `toHTMLStream` instead.
  - Updated to use `handlers`

- `browser-policy-common@2.0.0`:

  - Updated to use `handlers`

- `browser-policy-content@2.0.0`:

  - Some methods are now async. See below:
    - `BrowserPolicy.content.setPolicy`
    - `BrowserPolicy.content.allowInlineScripts`
    - `BrowserPolicy.content.disallowInlineScripts`
    - `BrowserPolicy.content.disallowAll`
    - `BrowserPolicy.setDefaultPolicy`

- `browser-policy-framing@2.0.0`:
  - Package was bumped due to a dependency update. No code changes were made.

- `browser-policy@2.0.0`:
  Updated to use async methods from `browser-policy-common` and `browser-policy-content`.

- `caching-compiler@2.0.0`:

  - `afterLink` is now async.
  - Updated to use now async API.

- `callback-hook@2.0.0`:

  - Added `forEachAsync` method.

- `check@2.0.0`:

  - Removed `fibers` related tests.

- `constraint-solver@2.0.0`:

  - Some methods are now async. See below:

    - `ConstraintSolver.getVersionCostSteps`
    - `ConstraintSolver.analyze`
    - `ConstraintSolver.resolve`

  - Updated tests to be async.
  - Removed a few underscore usage.
  - Added updated to use async methods

- `context@1.0.0`:

  - Removed `fibers` from package.

- `core-runtime@2.0.0`:

  - Created package to load packages and the app.
  - This is the pakcages that sets up the Runtime.

- `crosswalk@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `ddp-client@3.0.0`:

  - Added `isAsyncCall` method to know if call is being made by a async method.
  - Removed `fibers` from package.
  - Updated tests to use async methods.

- `ddp-common@2.0.0`:

  - Added `.fence` option.

- `ddp-rate-limiter@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `ddp-server@3.0.0`:

  - Updated to use async methods.
  - Removed `fibers` from package.
  - Updated tests to use async methods.
  - Turned server implementation to async.

- `ddp@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `diff-sequence@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `disable-oplog@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `ecmascript-runtime-client@1.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `ecmascript-runtime-server@1.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `ecmascript-runtime@1.0.0`:

  - Added dependency to `@babel/runtime`.

- `ecmascript@1.0.0`:

  - Added dependency to `@babel/runtime`.
  - Moved runtime tests.

- `ejson@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `email@3.0.0`:

  - `Email.send` is no longer available. Use `Email.sendAsync` instead.
  - Updated types to reflext async methods and `Email.send` depracation.

- `es5-shim@5.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `facebook-config-ui@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `facebook-oauth@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `facts-base@2.0.0`:

  - turned unorderd deps on `ddp` to false.

- `facts-ui@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `fetch@1.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `force-ssl-common@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `force-ssl@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `geojson-utils@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `github-config-ui@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `github-oauth@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `google-config-ui@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `google-oauth@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `hot-code-push@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `http@`:
  - Updated handlers to use `handlers`
- `id-map@2.0.0`:

  - Added `forEachAsync` method.

- `insecure@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `inter-process-messaging@1.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `launch-screen@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `localstorage@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `logging@2.0.0`:

  - Added dependency to `@babel/runtime`.

- `logic-solver@3.0.0`:
  `Logic.disablingAssertions` is now async.
  `minMaxWS` is now async.

- `meetup-config-ui@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `meetup-oauth@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `meteor-base@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `meteor-developer-config-ui@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `meteor-developer-oauth@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `meteor-tool@3.0.0`:

  - Changes to how meteor apps are being created [PR](https://github.com/meteor/meteor/pull/12697)

- `meteor@2.0.0`:

  - Async local storage was added to help deal with async methods.
  - Added `promiseEmmiter` to help with async methods.
  - Removed `fibers` from package.
  - `Meteor.absoluteUrl` in localhost uses `127.0.1` by default.

- `minifier-css@2.0.0`:

  - `minifyCss` is now async.
  - Removed `fibers` from package.

- `minifier-js@3.0.0`:

  - `minifyJs` is now async.
  - `terserMinify` no longer takes callbacks
  - Removed `fibers` from package.

* `minimongo@2.0.0`:
  - `cursor.observe` now returns `isReady` and `isReadyPromise` wich indicates
    if the cursor is ready and if the callbacks are have been called.
    If you only use it in the `Client` or as a `LocalCollection` things have not
    changed.

- `mobile-experience@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `mobile-status-bar@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `modern-browsers@1.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `modules-runtime@1.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `modules@1.0.0`:

  - Updated `reify` version.

- `mongo-decimal@`:

  - Updated to use `async` methods.

- `mongo-dev-server@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `mongo-id@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `mongo-livedata@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `mongo@2.0.0`:

  - Updated to unify methods, `update`,`insert`,`remove`, `fetch` are now async, they are
    the same as their `*Async` counterpart.
  - `ensureIndex` and `createIndex` are now async.

- `npm-mongo@5.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `oauth-encryption@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `oauth@`:

  - `_endOfPopupResponseTemplate` and `_endOfRedirectResponseTemplate` are no longer a property but now a function that returns a promise of the same value as before
  - the following server methods are now async:
  - `OAuth._renderOauthResults`
  - `OAuth._endOfLoginResponse`
  - `OAuth.renderEndOfLoginResponse`
  - `OAuth._storePendingCredential`
  - `OAuth._retrievePendingCredential`
  - `ensureConfigured`
  - `_cleanStaleResults`

- `oauth@3.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `oauth1@`:

  - the following server methods are now async:
  - `OAuth._storeRequestToken`
  - `OAuth._retrieveRequestToken`

- `oauth1@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `oauth2@`:

  - `OAuth._requestHandlers['2']` is now async.

- `oauth2@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `ordered-dict@2.0.0`:

  - Added `forEachAsync` method.

- `package-stats-opt-out@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `package-version-parser@4.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `promise@1.0.0`:

  - Removed `fibers` usage

- `random@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `rate-limit@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `reactive-dict@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `reactive-var@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `reload-safetybelt@2.0.0`:

  - Added `ecmascript` package to `package.js`

- `reload@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `retry@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `routepolicy@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `server-render@1.0.0`:

  - Updated usage with `getBoilerplate` that are now `async`.

- `service-configuration@2.0.0`:

  - Updated to use `createIndexAsync`.

- `session@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `sha@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `shell-server@1.0.0`:

  - Updated to handle promises results.

- `socket-stream-client@1.0.0`:

  - Updated tests to handle `async` code.

- `spiderable@`:

  - Updated handlers to use `handlers` that are now using express
  - removed `fibers` usage if flag is set to `true`

- `standard-minifier-css@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `standard-minifier-js@3.0.0`:

  - `processFilesForBundle` is now `async`.

- `standard-minifiers@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `static-html@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `test-helpers@2.0.0`:

  - Updated to use `async` methods.
  - Removed `fibers` usage.
  - Added possibliy to use `async` tests.

- `test-in-browser@2.0.0`:

  - Updated css to be in dark mode.

- `test-in-console@2.0.0`:

  - Updated log identation.

- `test-server-tests-in-console-once@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `tinytest-harness@1.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `tinytest@2.0.0`:

  - Added `test name` to logs.
  - Removed `fibers` usage.

- `twitter-config-ui@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `twitter-oauth@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `typescript@5.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `underscore-tests@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `underscore@2.0.0`:

  - Removed dependency in meteor package.

- `url@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `webapp-hashing@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `webapp@2.0.0`:

  - These methods are now async:

    - `WebAppInternals.reloadClientPrograms()`
    - `WebAppInternals.pauseClient()`
    - `WebAppInternals.generateClientProgram()`
    - `WebAppInternals.generateBoilerplate()`
    - `WebAppInternals.setInlineScriptsAllowed()`
    - `WebAppInternals.enableSubresourceIntegrity()`
    - `WebAppInternals.setBundledJsCssUrlRewriteHook()`
    - `WebAppInternals.setBundledJsCssPrefix()`
    - `WebAppInternals.getBoilerplate`

  - Changed engine from connect to express and changed api naming to match express. See below:
  - `WebApp.connectHandlers.use(middleware)` is now `WebApp.handlers.use(middleware)`
  - `WebApp.rawConnectHandlers.use(middleware)` is now `WebApp.rawHandlers.use(middleware)`
  - `WebApp.connectApp` is now `WebApp.expressApp`
  - `WebApp.addRuntimeConfigHook` accepts async callbacks

- `weibo-config-ui@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

- `weibo-oauth@2.0.0`:

  - Package was bumped due to a dependency update. No code changes were made.

#### New Public API


- `Build system` [PR](https://github.com/meteor/meteor/pull/13030):
  - Assets.getTextAsync
  - Assets.getBinaryAsync

- `accounts-base`: (2.9+)

  - `Meteor.userAsync()`

- `callback-hook`:forEachAsync

  - `forEachAsync`

- `ddp-server`: (2.8+)

  - `Meteor.callAsync()`

- `minifier-css`: (2.9+)

  - `CssTools.minifyCssAsync()`

- `mongo`:

  - `Mongo.Collection`: (2.8+)
    - `createCappedCollectionAsync`
    - `createIndexAsync`
    - `dropCollectionAsync`
    - `dropIndexAsync`
    - `findOneAsync`
    - `insertAsync`
    - `removeAsync`
    - `updateAsync`
    - `upsertAsync`
  - `Collection.Cursor`: (2.8+)
    - `countAsync`
    - `fetchAsync`
    - `forEachAsync`
    - `mapAsync`
    - `[Symbol.asyncIterator]` so this code should work:
      ```js
      for await (const document of collection.find(query, options)) /* ... */
      ```

#### Internal API changes

`accounts-base`:

- `_attemptLogin`
- `_loginMethod`
- `_runLoginHandlers`

* Upgraded `node-gyp` to v9.4.0
* Upgraded `node-pre-gyp` to `@mapbox/node-pre-gyp` v1.0.11

#### New Internal API

`accounts-password`:

- `Accounts._checkPasswordAsync`

#### Special thanks to

- [@StorytellerCZ](https://github.com/sponsors/StorytellerCZ/)

For making this great framework even better!

---

---
url: /generators/changelog/README.md
---
## Changelog Generator

This is a generator for the changelog, you must create a file with the name of
the version that you are generating the changelog for. The script will take care of the rest.

In this file you should follow the EXAMPLE.md file that is within this directory.

The script will generate a file called `history.gen.md` that will be used by the
`changelog.md` file to generate the changelog page.

To get which branches were merged into release you can search in the GitHub
repo by using this query:

```
    is:pr base:<release-branch-name> is:merged
```

or in GH Cli:

```bash
  gh pr list --state merged --base <release-branch-name>
```

note that it may not be as useful as the first one, since it will not show the
Authors and other related information.

## Why?

Computers with lower memory/ IDEs with high memory usage can have problems with
the changelog file(~10k lines). This is a way to reduce the memory usage of the changelog, also creating a more
organized changelog, since all the files will be reflecting at least one version.

## Update ordering.

If you want to make sure that the changelog is correctly ordered, take a look at the `order-packages.js` file.
to use it, run the command below:

```bash
node order-packages.js versions/3.0.md
```

or

```bash
node order-packages.js versions/<your-version>.md
```

it will update the file with the correct ordering(this will override the file).

---

---
url: /index.md
---


---

---
url: /packages/3.writing-atmosphere-packages.md
---
## Writing Atmosphere packages

To get started writing a package, use the Meteor command line tool:

```bash
meteor create --package my-package
```
> It is required that your `my-package` name take the form of `username:my-package`, where `username` is your Meteor Developer username, if you plan to publish your package to Atmosphere.

If you run this inside an app, it will place the newly generated package in that app's `packages/` directory. Outside an app, it will just create a standalone package directory. The command also generates some boilerplate files for you:

```txt
my-package
├── README.md
├── package.js
├── my-package-tests.js
└── my-package.js
```

The `package.js` file is the main file in every Meteor package. This is a JavaScript file that defines the metadata, files loaded, architectures, npm packages, and Cordova packages for your Meteor package.

In this tutorial, we will go over some important points for building packages, but we won't explain every part of the `package.js` API. To learn about all of the options, [read about the `package.js` API in the Meteor docs.](https://docs.meteor.com/api/package.html)

> Don't forget to run [`meteor add [my-package]`](https://docs.meteor.com/cli/#meteor-add) once you have finished developing your package in order to use it; this applies if the package is a local package for internal use only or if you have published the package to Atmosphere.

### Adding files and assets

The main function of an Atmosphere package is to contain source code (JS, CSS, and any transpiled languages) and assets (images, fonts, and more) that will be shared across different applications.

### Adding JavaScript

To add JavaScript files to a package, specify an entrypoint with [`api.mainModule()`](https://docs.meteor.com/packages/modules.html#modular-package-structure) in the package's `onUse` block (this will already have been done by `meteor create --package` above):

```js
Package.onUse(function(api) {
  api.mainModule('my-package.js');
});
```

From that entrypoint, you can `import` other files within your package, [just as you would in an application](https://docs.meteor.com/packages/modules.html).

If you want to include different files on the client and server, you can specify multiple entry points using the second argument to the function:

```js
Package.onUse(function(api) {
  api.mainModule('my-package-client.js', 'client');
  api.mainModule('my-package-server.js', 'server');
});
```

You can also add any source file that would be compiled to a JS file (such as a CoffeeScript file) in a similar way, assuming you [depend](#dependencies) on an appropriate build plugin.

<h3 id="adding-css">Adding CSS</h3>

To include CSS files with your package you can use [`api.addFiles()`](https://docs.meteor.com/api/package.html#PackageAPI-addFiles):

```js
Package.onUse(function(api) {
  api.addFiles('my-package.css', 'client');
});
```

The CSS file will be automatically loaded into any app that uses your package.

### Adding Sass, Less, or Stylus mixins/variables

Just like packages can export JavaScript code, they can export reusable bits of CSS pre-processor code. You can also have a package that doesn't actually include any CSS, but just exports different bits of reusable mixins and variables. To get more details see Meteor [build tool CSS pre-processors](https://guide.meteor.com/build-tool.html#css):

```js
Package.onUse(function(api) {
  api.addFiles('my-package.scss', 'client');
});
```

This Sass file will be eagerly evaluated and its compiled form will be added to the CSS of the app immediately.

```js
Package.onUse(function(api) {
  api.addFiles([
    'stylesheets/_util.scss',
    'stylesheets/_variables.scss'
  ], 'client', {isImport: true});
});
```

These two Sass files will be lazily evaluated and only included in the CSS of the app if imported from some other file.

### Adding other assets

You can include other assets, such as fonts, icons or images, to your package using [`api.addAssets`](https://docs.meteor.com/api/package.html#PackageAPI-addAssets):

```js
Package.onUse(function(api) {
  api.addAssets([
    'font/OpenSans-Regular-webfont.eot',
    'font/OpenSans-Regular-webfont.svg',
    'font/OpenSans-Regular-webfont.ttf',
    'font/OpenSans-Regular-webfont.woff',
  ], 'client');
});
```

You can then access these files from the client from a URL `/packages/username_my-package/font/OpenSans-Regular-webfont.eot` or from the server using the [Assets API](https://docs.meteor.com/api/assets.html#Assets-getTextAsync).

### Exporting

While some packages exist just to provide side effects to the app, most packages provide a reusable bit of code that can be used by the consumer with `import`. To export a symbol from your package, use the ES2015 `export` syntax in your `mainModule`:

```js
// in my-package.js:
export const myName = 'my-package';
```

Now users of your package can import the symbol with:

```js
import { myName } from 'meteor/username:my-package';
```

### Dependencies

Chances are your package will want to make use of other packages.  To ensure they are available, you can declare dependencies. Atmosphere packages can depend both on other Atmosphere packages, as well as packages from npm.

#### Atmosphere dependencies

To depend on another Atmosphere package, use [`api.use`](https://docs.meteor.com/api/package.html#PackageAPI-use):

```js
Package.onUse(function(api) {
  // This package depends on 1.2.0 or above of validated-method
  api.use('mdg:validated-method@1.2.0');
});
```

One important feature of the Atmosphere package system is that it is single-loading: no two packages in the same app can have dependencies on conflicting versions of a single package. Read more about that in the section about version constraints below.

#### Depending on Meteor version

Note that the Meteor release version number is mostly a marketing artifact - the core Meteor packages themselves typically don't share this version number. This means packages can only depend on specific versions of the packages inside a Meteor release, but can't depend on a specific release itself. We have a helpful shorthand api called [`api.versionsFrom`](https://docs.meteor.com/api/package.html#PackageAPI-versionsFrom) that handles this for you by automatically filling in package version numbers from a particular release:

```js
// Use versions of core packages from Meteor 1.2.1
api.versionsFrom('1.2.1');

api.use([
  // Don't need to specify version because of versionsFrom above
  'ecmascript',
  'check',

  // Still need to specify versions of non-core packages
  'mdg:validated-method@1.2.0',
  'mdg:validation-error@0.1.0'
]);
```

The above code snippet is equivalent to the code below, which specifies all of the version numbers individually:

```js
api.use([
  'ecmascript@0.1.6',
  'check@1.1.0',
  'mdg:validated-method@1.2.0',
  'mdg:validation-error@0.1.0'
]);
```

Additionally, you can call `api.versionsFrom(<release>)` multiple times, or with
an array (eg `api.versionsFrom([<release1>, <release2>])`. Meteor will interpret
this to mean that the package will work with packages from all the listed releases.

```js
api.versionsFrom('1.2.1');
api.versionsFrom('1.4');
api.versionsFrom('1.8');

// or

api.versionsFrom(['1.2.1', '1.4', '1.8']);
```

This usually isn't necessary, but can help in cases where you support more than
one major version of a core package.


#### Semantic versioning and version constraints

Meteor's package system relies heavily on [Semantic Versioning](http://semver.org/), or SemVer. When one package declares a dependency on another, it always comes with a version constraint. These version constraints are then solved by Meteor's industrial-grade Version Solver to arrive at a set of package versions that meet all of the requirements, or display a helpful error if there is no solution.

The mental model here is:

1. **The major version must always match exactly.** If package `a` depends on `b@2.0.0`, the constraint will only be satisfied if the version of package `b` starts with a `2`. This means that you can never have two different major versions of a package in the same app.
2. **The minor and patch version numbers must be greater or equal to the requested version.** If the dependency requests version `2.1.3`, then `2.1.4` and `2.2.0` will work, but `2.0.4` and `2.1.2` will not.

The constraint solver is necessary because Meteor's package system is **single-loading** - that is, you can never have two different versions of the same package loaded side-by-side in the same app. This is particularly useful for packages that include a lot of client-side code, or packages that expect to be singletons.

Note that the version solver also has a concept of "gravity" - when many solutions are possible for a certain set of dependencies, it always selects the oldest possible version. This is helpful if you are trying to develop a package to ship to lots of users, since it ensures your package will be compatible with the lowest common denominator of a dependency. If your package needs a newer version than is currently being selected for a certain dependency, you need to update your `package.js` to have a newer version constraint.

If your package supports multiple major versions of a dependency, you can supply
both versions to `api.use` like so:

```js
api.use('blaze@1.0.0 || 2.0.0');
```

Meteor will use whichever major version is compatible with your other packages,
or the most recent of the options given.

#### npm dependencies

Meteor packages can include [npm packages](https://www.npmjs.com/) to use JavaScript code from outside the Meteor package ecosystem or to include JavaScript code with native dependencies. Use [Npm.depends](https://docs.meteor.com/api/package.html#Npm-require) at the top level of your `package.js` file. For example, here's how you would include the `github` npm package:

```js
Npm.depends({
  github: '0.2.4'
});
```

If you want to use a local npm package, for example during development, you can give a directory instead of a version number:

```js
Npm.depends({
  my-package: 'file:///home/user/npms/my-package'
});
```

You can import the dependency from within you package code in the same way that you would inside an application:

```js
import github from 'github';
```

#### Peer npm dependencies

`Npm.depends()` is fairly rigid (you can only depend on an exact version), and will typically result in multiple versions of a package being installed if many different Atmosphere packages depend on the same npm package. This makes it less than ideal to use on the client, where it's impractical to ship multiple copies of the same package code to the browser. Client-side packages are also often written with the assumption that only a single copy will be loaded. For example, React will complain if it is included more than once in an application bundle.

To avoid this problem as a package author, you can request that users of your package have installed the npm package you want to use at the application level. This is similar to a [peer dependency](https://nodejs.org/en/blog/npm/peer-dependencies/) of an npm package (although with less support in the tool). You can use the [`tmeasday:check-npm-versions`](https://atmospherejs.com/tmeasday/check-npm-versions) package to ensure that they've done this, and to warn them if not.

For instance, if you are writing a React package, you should not directly depend on [`react`](https://www.npmjs.com/package/react), but instead use `check-npm-versions` to check the user has installed it:

```js
import { checkNpmVersions } from 'meteor/tmeasday:check-npm-versions';

checkNpmVersions({
  'react': '0.14.x'
}, 'my:awesome-package');

// If you are using the dependency in the same file, you'll need to use require, otherwise
// you can continue to `import` in another file.
const React = require('react');
```

> Note that `checkNpmVersions` will only output a warning if the user has installed a incompatible version of the npm package. So your `require` call may not give you what you expect. This is consistent with npm's handling of [peer dependencies](http://blog.npmjs.org/post/110924823920/npm-weekly-5).

### Cordova plugins

Atmosphere packages can include [Cordova plugins](http://cordova.apache.org/plugins/) to ship native code for the Meteor mobile app container. This way, you can interact with the native camera interface, use the gyroscope, save files locally, and more.

Include Cordova plugins in your Meteor package by using [Cordova.depends](https://docs.meteor.com/api/package.html#PackageCordova-depends).

Read more about using Cordova in the [mobile guide](https://guide.meteor.com/mobile.html).

### Testing packages

Meteor has a test mode for packages called `meteor test-packages`. If you are in a package's directory, you can run

```bash
meteor test-packages ./ --driver-package meteortesting:mocha
```

This will run a special app containing only a "test" version of your package and start a Mocha [test driver package](https://guide.meteor.com/testing#driver-packages).

When your package starts in test mode, rather than loading the `onUse` block, Meteor loads the `onTest` block:

```js
Package.onTest(function(api) {
  // You almost definitely want to depend on the package itself,
  // this is what you are testing!
  api.use('my-package');

  // You should also include any packages you need to use in the test code
  api.use(['ecmascript', 'random', 'meteortesting:mocha']);

  // Finally add an entry point for tests
  api.mainModule('my-package-tests.js');
});
```

From within your test entry point, you can import other files as you would in the package proper.

You can read more about testing in Meteor in the [Testing article](https://guide.meteor.com/testing).

### Publishing your package

To publish your package to Atmosphere, run [`meteor publish`](https://docs.meteor.com/cli/#meteorpublish) from the package directory. To publish a package the package name must follow the format of `username:my-package` and the package must contain a [SemVer version number](#semantic-versionning-and-version-constraints).

> Note that if you have a local `node_modules` directory in your package, remove it before running `meteor publish`. While local `node_modules` directories are allowed in Meteor packages, their paths can collide with the paths of `Npm.depends` dependencies when published.



## Cache format

If you've ever looked inside Meteor's package cache at `~/.meteor/packages`, you know that the on-disk format of a built Meteor package is completely different from the way the source code looks when you're developing the package. The idea is that the target format of a package can remain consistent even if the API for development changes.

## Local packages

As an alternative to publishing your package on Atmosphere, if you want to keep your package private, you can place it in your Meteor app in the `packages/` directory, for instance `packages/foo/`, and then add it to your app with `meteor add foo`.

Using `git submodules` to handle private packages is a common pattern.

### Overriding published packages with a local version

If you need to modify an Atmosphere package to do something that the published version doesn't do, you can edit a local version of the package on your computer.

A Meteor app can load Atmosphere packages in one of three ways, and it looks for a matching package name in the following order:

1. Package source code in the `packages/` directory inside your app.
2. Package source code in directories indicated by setting a `METEOR_PACKAGE_DIRS` environment variable before running any `meteor` command. You can add multiple directories by separating the paths with a `:` on OSX or Linux, or a `;` on Windows. For example: `METEOR_PACKAGE_DIRS=../first/directory:../second/directory`, or on Windows: `set PACKAGE_DIRS=..\first\directory;..\second\directory`.
> Note: Prior to Meteor 1.4.2, `METEOR_PACKAGE_DIRS` was `PACKAGE_DIRS`.  For compatibility reasons, developers should use `METEOR_PACKAGE_DIRS` going forward.
3. Pre-built package from Atmosphere. The package is cached in `~/.meteor/packages` on Mac/Linux or `%LOCALAPPDATA%\.meteor\packages` on Windows, and only loaded into your app as it is built.

You can use (1) or (2) to override the version from Atmosphere. You can even do this to load patched versions of Meteor core packages - just copy the code of the package from [Meteor's GitHub repository](https://github.com/meteor/meteor/tree/devel/packages), and edit away.

---

---
url: /packages/2.using-atmosphere-packages.md
---
### Package naming

All packages on Atmosphere have a name of the form `prefix:package-name`. The prefix is the Meteor Developer username of the organization or user that published the package. Meteor uses such a convention for package naming to make sure that it's clear who has published a certain package, and to avoid an ad-hoc namespacing convention. Meteor platform packages do not have any `prefix:` or may use `mdg:`.

### Installing Atmosphere Packages

To install an Atmosphere package, you use `meteor add` inside your app directory:

```bash
meteor add ostrio:flow-router-extra
```

This will add the newest version of the desired package that is compatible with the other packages in your app and your Meteor app version. If you want to specify a particular version, you can specify it by adding a suffix to the package name like: `meteor add ostrio:flow-router-extra@3.12.0`.

Regardless of how you add the package to your app, its actual version will be tracked in the file at `.meteor/versions`. This means that anybody collaborating with you on the same app is guaranteed to have the same package versions as you. If you want to update to a newer version of a package after installing it, use `meteor update`. You can run `meteor update` without any arguments to update all packages and Meteor itself to their latest versions, or pass a specific package to update just that one, for example `meteor update ostrio:flow-router-extra`.

If your app is running when you add a new package, Meteor will automatically download it and restart your app for you.

> The actual files for a given version of an Atmosphere package are stored in your local `~/.meteor/packages` directory.

To see all the Atmosphere packages installed run:

```bash
meteor list
```

To remove an unwanted Atmosphere package run:

```bash
meteor remove ostrio:flow-router-extra
```

You can get more details on all the package commands in the [Meteor Command line documentation](https://docs.meteor.com/cli/#meteorhelp).

### Using Atmosphere Packages inside your app

To use an Atmosphere Package in your app you can import it with the `meteor/` prefix:

```js
import { Mongo } from "meteor/mongo";
```

Typically a package will export one or more symbols, which you'll need to reference with the destructuring syntax. You can find these exported symbols by either looking in that package's `package.js` file for [`api.export`](http://docs.meteor.com/api/package.html#PackageAPI-export) calls or by looking in that package's main JavaScript file for ES2015 `export ` calls like `export const packageName = 'package-name';`.

Sometimes a package will have no exports and have side effects when included in your app. In such cases you don't need to import the package at all after installing.

> For backwards compatibility with Meteor 1.2 and early releases, Meteor by default makes available directly to your app all symbols referenced in `api.export` in any packages you have installed. However, it is recommended that you import these symbols first before using them.

#### Importing styles from Atmosphere packages

Using any of Meteor's supported CSS pre-processors you can import other style files using the `{package-name}` syntax as long as those files are designated to be lazily evaluated as "import" files. To get more details on how to determine this see [CSS source versus import](https://guide.meteor.com/build-tool#css-source-vs-import) files.

```less
@import '{prefix:package-name}/buttons/styles.import.less';
```

> CSS files in an Atmosphere package are declared with `api.addFiles`, and therefore will be eagerly evaluated by default, and then bundled with all the other CSS in your app.

#### Peer npm dependencies

Atmosphere packages can ship with contained [npm dependencies](#npm-dependencies), in which case you don't need to do anything to make them work. However, some Atmosphere packages will expect that you have installed certain "peer" npm dependencies in your application.

Typically the package will warn you if you have not done so. For example, if you install the [`react-meteor-data`](https://atmospherejs.com/meteor/react-meteor-data) package into your app, you'll also need to install the [`react`](https://www.npmjs.com/package/react) and the [`react-addons-pure-render-mixin`](https://www.npmjs.com/package/react-addons-pure-render-mixin) packages:

```bash
meteor npm install --save react react-addons-pure-render-mixin
meteor add react-meteor-data
```

### Atmosphere package namespacing

Each Atmosphere package that you use in your app exists in its own separate namespace, meaning that it sees only its own global variables and any variables provided by the packages that it specifically uses. When a top-level variable is defined in a package, it is either declared with local scope or package scope.

```js
/**
 * local scope - this variable is not visible outside of the block it is
 * declared in and other packages and your app won't see it
 */
const alicePerson = {name: "alice"};

/**
 * package scope - this variable is visible to every file inside of the
 * package where it is declared and to your app
 */
bobPerson = {name: "bob"};
```

Notice that this is just the normal JavaScript syntax for declaring a variable that is local or global. Meteor scans your source code for global variable assignments and generates a wrapper that makes sure that your globals don't escape their appropriate namespace.

In addition to local scope and package scope, there are also package exports. A package export is a "pseudo global" variable that a package makes available for you to use when you install that package. For example, the `email` package exports the `Email` variable. If your app uses the `email` package (and _only_ if it uses the `email` package!) then your app can access the `Email` symbol and you can call `Email.send`. Most packages have only one export, but some packages might have two or three (for example, a package that provides several classes that work together).

> It is recommended that you use the `ecmascript` package and first call `import { Email } from 'meteor/email';` before calling `Email.send` in your app. It is also recommended that package developers now use ES2015 `export` from their main JavaScript file instead of `api.export`.

Your app sees only the exports of the packages that you use directly. If you use package A, and package A uses package B, then you only see package A's exports. Package B's exports don't "leak" into your namespace just because you used package A. Each app or package only sees their own globals plus the APIs of the packages that they specifically use and depend upon.

---

---
url: /packages/1.when-to-use-meteor-packages.md
---
## Using Atmosphere packages
### When to use Atmosphere packages

Atmosphere packages are packages written specifically for Meteor and have several advantages over npm when used with Meteor. In particular, Atmosphere packages can:

- Depend on core Meteor packages, such as `ddp`, `mongo` or `accounts`
- Explicitly include non-javascript files including CSS, Less or static assets
- Have a well defined way to ship different code for client and server, enabling different behavior in each context
- Get direct access to Meteor's [package namespacing](#atmosphere-package-namespacing) and package global exports without having to explicitly use ES2015 `import`
- Enforce exact version dependencies between packages using Meteor's [constraint resolver](#semantic-versionning-and-version-constraints)
- Include [build plugins](https://docs.meteor.com/api/package.html#build-plugin-api) for Meteor's build system
- Include pre-built binary code for different server architectures, such as Linux or Windows

If your package depends on another Atmosphere package, or needs to take advantage of Meteor's [build system](https://docs.meteor.com/about/modern-build-stack.html#modern-build-stack), writing an Atmosphere package might be the best option for now.

---

---
url: /tutorials/react/1.creating-the-app.md
---
## 1: Creating the app

### 1.1: Install Meteor {#install-meteor}

First, we need to install Meteor.

If you don't have Meteor installed, you can install it by running:

```shell
npx meteor
```

### 1.2: Create Meteor Project {#create-meteor-project}

The easiest way to setup Meteor with React is by using the command `meteor create` with the option `--react` and your project name (you can also omit the `--react` option since it is the default):

```shell
meteor create simple-todos-react
```

Meteor will create all the necessary files for you.

The files located in the `client` directory are setting up your client side (web), you can see for example `client/main.jsx` where Meteor is rendering your App main component into the HTML.

Also, check the `server` directory where Meteor is setting up the server side (Node.js), you can see the `server/main.js` is initializing your MongoDB database with some data. You don't need to install MongoDB as Meteor provides an embedded version of it ready for you to use.

You can now run your Meteor app using:

```shell
meteor run
```

Don't worry, Meteor will keep your app in sync with all your changes from now on.

Your React code will be located inside the `imports/ui` directory, and `App.jsx` file is the root component of your React To-do app.

Take a quick look at all the files created by Meteor, you don't need to understand them now but it's good to know where they are.

### 1.3: Create Task Component {#create-task-component}

You will make your first change now. Create a new file called `Task.jsx` in your `ui` folder.

This file will export a React component called `Task` that will represent one task in your To-Do list.

::: code-group

```js [imports/ui/Task.jsx]
import React from "react";

export const Task = ({ task }) => {
  return <li>{task.text}</li>;
};
```

:::

As this component will be inside a list you are returning a `li` element.

### 1.4: Create Sample Tasks {#create-sample-tasks}

As you are not connecting to your server and your database yet let's define some sample data which will be used shortly to render a list of tasks. It will be an array, and you can call it `tasks`.

::: code-group

```js [imports/ui/App.jsx]
import React from 'react';

const tasks = [
  {_id: 1, text: 'First Task'},
  {_id: 2, text: 'Second Task'},
  {_id: 3, text: 'Third Task'},
];

export const App = () => ...
```

:::

You can put anything as your `text` property on each task. Be creative!

### 1.5: Render Sample Tasks {#render-sample-tasks}

Now we can implement some simple rendering logic with React. We can now use our previous `Task` component to render our list items.

In React you can use `{` `}` to write Javascript code between them.

See below that you will use a `.map` function from the `Array` object to iterate over your sample tasks.

::: code-group

```js [imports/ui/App.jsx]
import React from 'react';
import { Task } from './Task';

const tasks = ..;

export const App = () => (
  <div>
    <h1>Welcome to Meteor!</h1>

    <ul>
      { tasks.map(task => <Task key={ task._id } task={ task }/>) }
    </ul>
  </div>
);
```

:::

Remember to add the `key` property to your task, otherwise React will emit a warning because it will see many components of the same type as siblings. Without a key, it will be hard for React to re-render one of them if necessary.

> You can read more about React and Keys [here](https://reactjs.org/docs/lists-and-keys.html#keys).

Remove the `Hello` and `Info` from your `App` component, remember to also remove the imports for them at the top of the file. Remove the `Hello.jsx` and `Info.jsx` files as well.

### 1.6: Hot Module Replacement {#hot-module-replacement}

Meteor by default when using React is already adding for you a package called `hot-module-replacement`. This package updates the javascript modules in a running app that were modified during a rebuild. Reduces the feedback cycle while developing so you can view and test changes quicker (it even updates the app before the build has finished). You are also not going to lose the state, your app code will be updated and your state will be the same.

In the next step, we are going to work with our MongoDB database to store our tasks.

---

---
url: /tutorials/react/3.forms-and-events.md
---
## 3: Forms and Events

All apps need to allow the user to perform some sort of interaction with the data that is stored. In our case, the first type of interaction is to insert new tasks. Without it, our To-Do app wouldn't be very helpful.

One of the main ways in which a user can insert or edit data on a website is through forms. In most cases, it is a good idea to use the `<form>` tag since it gives semantic meaning to the elements inside it.

### 3.1: Create Task Form

First, we need to create a simple form component to encapsulate our logic. As you can see we set up the `useState` React Hook.

Please note the _array destructuring_ `[text, setText]`, where `text` is the stored value which we want to use, which in this case will be a _string_; and `setText` is a _function_ used to update that value.

Create a new file `TaskForm.jsx` in your `ui` folder.

::: code-group

```js [imports/ui/TaskForm.jsx]
import React, { useState } from "react";

export const TaskForm = () => {
  const [text, setText] = useState("");

  return (
    <form className="task-form">
      <input type="text" placeholder="Type to add new tasks" />

      <button type="submit">Add Task</button>
    </form>
  );
};
```

:::

### 3.2: Update the App component

Then we can simply add this to our `App` component above your list of tasks:

::: code-group

```js [imports/ui/App.jsx]
import React from "react";
import { useTracker, useSubscribe } from "meteor/react-meteor-data";
import { TasksCollection } from "/imports/api/TasksCollection";
import { Task } from "./Task";
import { TaskForm } from "./TaskForm";

export const App = () => {
  const isLoading = useSubscribe("tasks");
  const tasks = useTracker(() => TasksCollection.find({}).fetch());

  if (isLoading()) {
    return <div>Loading...</div>;
  }
  return (
    <div>
      <h1>Welcome to Meteor!</h1>

      <TaskForm />

      <ul>
        {tasks.map((task) => (
          <Task key={task._id} task={task} />
        ))}
      </ul>
    </div>
  );
};
```

:::

### 3.3: Update the Stylesheet

You also can style it as you wish. For now, we only need some margin at the top so the form doesn't seem off the mark. Add the CSS class `.task-form`, this needs to be the same name in your `className` attribute in the form component.

::: code-group

```css [client/main.css]
.task-form {
  margin-top: 1rem;
}
```

:::

### 3.4: Add Submit Handler

Now let's create a function to handle the form submit and insert a new task into the database. To do it, we will need to implement a Meteor Method.

Methods are essentially RPC calls to the server that let you perform operations on the server side securely. You can read more about Meteor Methods [here](https://guide.meteor.com/methods.html).

To create your methods, you can create a file called `tasksMethods.js`.

::: code-group

```javascript [imports/api/tasksMethods.js]
import { Meteor } from "meteor/meteor";
import { TasksCollection } from "./TasksCollection";

Meteor.methods({
  "tasks.insert"(doc) {
    return TasksCollection.insertAsync(doc);
  },
});
```

:::

Remember to import your method on the `main.js` server file and the `main.jsx` client file.

::: code-group

```javascript [server/main.js]
import { Meteor } from "meteor/meteor";
import { TasksCollection } from "../imports/api/tasksCollection";
import "../imports/api/TasksPublications";
import "../imports/api/tasksMethods"; // [!code highlight]
```

```javascript [client/main.jsx]
import React from "react";
import { createRoot } from "react-dom/client";
import { Meteor } from "meteor/meteor";
import { App } from "/imports/ui/App";

import "../imports/api/tasksMethods"; // [!code highlight]
```

:::

Now you can attach a submit handler to your form using the `onSubmit` event, and also plug your React Hook into the `onChange` event present in the input element.

As you can see you are using the `useState` React Hook to store the `value` of your `<input>` element. Note that you also need to set your `value` attribute to the `text` constant as well, this will allow the `input` element to stay in sync with our hook.

> In more complex applications you might want to implement some `debounce` or `throttle` logic if there are many calculations happening between potentially frequent events like `onChange`. There are libraries which will help you with this, like [Lodash](https://lodash.com/), for instance.

::: code-group

```js [imports/ui/TaskForm.jsx]
import React, { useState } from "react";
import { TasksCollection } from "/imports/api/TasksCollection";

export const TaskForm = () => {
  const [text, setText] = useState("");

  const handleSubmit = async (e) => {
    e.preventDefault();

    if (!text) return;

    await Meteor.callAsync("tasks.insert", {
      text: text.trim(),
      createdAt: new Date(),
    });

    setText("");
  };

  return (
    <form className="task-form" onSubmit={handleSubmit}>
      <input
        type="text"
        placeholder="Type to add new tasks"
        value={text}
        onChange={(e) => setText(e.target.value)}
      />

      <button type="submit">Add Task</button>
    </form>
  );
};
```

:::

Inside the function, we are adding a task to the `tasks` collection by calling `Meteor.callAsync()`. The first argument is the name of the method we want to call, and the second argument is the text of the task. We are also trimming the text to remove any extra spaces.

Also, insert a date `createdAt` in your `task` document so you know when each task was created.

### 3.5: Show Newest Tasks First

Now you just need to make a change that will make users happy: we need to show the newest tasks first. We can accomplish this quite quickly by sorting our [Mongo](https://guide.meteor.com/collections.html#mongo-collections) query.

::: code-group

```js [imports/ui/App.jsx]
..

export const App = () => {
  const tasks = useTracker(() => TasksCollection.find({}, { sort: { createdAt: -1 } }).fetch());
  ..
```

:::

Your app should look like this:

<img width="200px" src="/tutorials/react/assets/step03-form-new-task.png"/>

<img width="200px" src="/tutorials/react/assets/step03-new-task-on-list.png"/>

In the next step, we are going to update your tasks state and provide a way for users to remove tasks.

---

---
url: /tutorials/react/2.collections.md
---
## 2: Collections

Meteor already sets up MongoDB for you. In order to use our database, we need to create a _collection_, which is where we will store our _documents_, in our case our `tasks`.

> You can read more about collections [here](https://v3-docs.meteor.com/api/collections.html).

In this step, we will implement all the necessary code to have a basic collection for our tasks up and running using React hooks.

### 2.1: Create Tasks Collection {#create-tasks-collection}

We can create a new collection to store our tasks by creating a new file at `imports/api/TasksCollection.js` which instantiates a new Mongo collection and exports it.

::: code-group

```js [imports/api/TasksCollection.js]
import { Mongo } from "meteor/mongo";

export const TasksCollection = new Mongo.Collection("tasks");
```

:::

Notice that we stored the file in the `imports/api` directory, which is a place to store API-related code, like publications and methods. You can name this folder as you want, this is just a choice.

You can delete the `links.js` file in this folder as we are not going to use this collection.

> You can read more about app structure and imports/exports [here](http://guide.meteor.com/structure.html).

### 2.2: Initialize Tasks Collection {#initialize-tasks-collection}

For our collection to work, you need to import it in the server so it sets some plumbing up.

You can either use `import "/imports/api/TasksCollection"` or `import { TasksCollection } from "/imports/api/TasksCollection"` if you are going to use on the same file, but make sure it is imported.

Now it is easy to check if there is data or not in our collection, otherwise, we can insert some sample data easily as well.

You don't need to keep the old content of `server/main.js`.

::: code-group

```js [server/main.js]
import { Meteor } from "meteor/meteor";
import { TasksCollection } from "/imports/api/TasksCollection";

const insertTask = (taskText) =>
  TasksCollection.insertAsync({ text: taskText });

Meteor.startup(async () => {
  if ((await TasksCollection.find().countAsync()) === 0) {
    [
      "First Task",
      "Second Task",
      "Third Task",
      "Fourth Task",
      "Fifth Task",
      "Sixth Task",
      "Seventh Task",
    ].forEach(insertTask);
  }
});
```

:::

So you are importing the `TasksCollection` and adding a few tasks to it iterating over an array of strings and for each string calling a function to insert this string as our `text` field in our `task` document.

### 2.3: Render Tasks Collection {#render-tasks-collection}

Now comes the fun part, you will render the tasks using a React Function Component and a Hook called `useTracker` from a package called [react-meteor-data](https://atmospherejs.com/meteor/react-meteor-data).

> Meteor works with Meteor packages and NPM packages, usually, Meteor packages are using Meteor internals or other Meteor packages.

This package is already included in the React skeleton (`meteor create yourproject`) so you don't need to add it but you can always add Meteor packages running `meteor add package-name`:

```shell
meteor add react-meteor-data
```

Now you are ready to import code from this package, when importing code from a Meteor package the only difference from NPM modules is that you need to prepend `meteor/` in the from part of your import.

The `useTracker` function exported by `react-meteor-data` is a React Hook that allows you to have reactivity in your React components. Every time the data changes through reactivity your component will re-render. Cool, right?

> For more information about React Hooks read [here](https://reactjs.org/docs/hooks-faq.html).

::: code-group

```javascript [imports/ui/App.jsx]
import React from "react";
import { useTracker } from "meteor/react-meteor-data";
import { TasksCollection } from "/imports/api/TasksCollection";
import { Task } from "./Task";

export const App = () => {
  const tasks = useTracker(() => TasksCollection.find({}).fetch());

  return (
    <div>
      <h1>Welcome to Meteor!</h1>

      <ul>
        {tasks.map((task) => (
          <Task key={task._id} task={task} />
        ))}
      </ul>
    </div>
  );
};
```

:::

But wait! Something is missing. If you run your app now, you'll see that you don't render any tasks.

That's because we need to publish our data to the client.

First, create a publication for our tasks:

`imports/api/TasksPublications.js`

```javascript
import { Meteor } from "meteor/meteor";
import { TasksCollection } from "./TasksCollection";

Meteor.publish("tasks", () => {
  return TasksCollection.find();
});
```

Now, we need to import this file in our server:

::: code-group

```js [server/main.js]
...
import { TasksCollection } from '/imports/api/TasksCollection';

import "../imports/api/TasksPublications"; // [!code highlight]

const insertTask = taskText => TasksCollection.insertAsync({ text: taskText });
...
```

:::

The only thing left is subscribe to this publication:

`imports/ui/App.jsx`

```javascript
import React from 'react';
import { useTracker, useSubscribe } from 'meteor/react-meteor-data'; // [!code highlight]
import { TasksCollection } from '/imports/api/TasksCollection';
import { Task } from './Task';

export const App = () => {

  const isLoading = useSubscribe("tasks");  // [!code highlight]
  const tasks = useTracker(() => TasksCollection.find({}).fetch());

  if (isLoading()) {
    return <div>Loading...</div>;
  }
  ...
}
```

As you can see, when subscribing to a publication using `useSubscribe` you'll get a `isLoading` function, that you can use to render some loading component before the data is ready.

> For more information on Publications/Subscriptions, please check our [docs](https://v3-docs.meteor.com/api/meteor.html#pubsub).

See how your app should look like now:

<img width="200px" src="/tutorials/react/assets/collections-tasks-list.png"/>

You can change your data on MongoDB in the server and your app will react and re-render for you.

You can connect to your MongoDB running `meteor mongo` in the terminal from your app folder or using a Mongo UI client, like [NoSQLBooster](https://nosqlbooster.com/downloads). Your embedded MongoDB is running in port `3001`.

See how to connect:

<img width="500px" src="/tutorials/react/assets/collections-connect-db.png"/>

See your database:

<img width="500px" src="/tutorials/react/assets/collections-see-database.png"/>

You can double-click your collection to see the documents stored on it:

<img width="500px" src="/tutorials/react/assets/collections-documents.png"/>

In the next step, we are going to create tasks using a form.

---

---
url: /tutorials/react/9.next-steps.md
---
## 9: Next Steps

You have completed the tutorial!

By now, you should have a good understanding of working with Meteor and React.

::: info
You can find the final version of this app in our [GitHub repository](https://github.com/meteor/meteor3-react).
:::

Here are some options for what you can do next:

- Check out the complete [documentation](https://v3-docs.meteor.com/) to learn more about Meteor 3.
- Read the [Galaxy Guide](https://galaxy-support.meteor.com/en/article/deploy-to-galaxy-18gd6e2/) to learn more about deploying your app.
- Join our community on the [Meteor Forums](https://forums.meteor.com/) and the [Meteor Lounge on Discord](https://discord.gg/hZkTCaVjmT) to ask questions and share your experiences.

We can't wait to see what you build next!

---

---
url: /tutorials/react/8.deploying.md
---
## 8: Deploying

Deploying a Meteor application is similar to deploying any other Node.js app that uses websockets. You can find deployment options in [our guide](https://guide.meteor.com/deployment), including Meteor Up, Docker, and our recommended method, Galaxy.

In this tutorial, we will deploy our app on [Galaxy](https://www.meteor.com/hosting), which is our own cloud solution. Galaxy offers a free plan, so you can deploy and test your app. Pretty cool, right?


### 8.1: Create your account


You need a Meteor account to deploy your apps. If you don’t have one yet, you can [sign up here](https://cloud.meteor.com/?isSignUp=true).
With this account, you can access our package manager, [Atmosphere](https://atmospherejs.com/), [Forums](https://forums.meteor.com/) and more.



### 8.2: Set up MongoDB (Optional)


As your app uses MongoDB the first step is to set up a MongoDB database, Galaxy offers MongoDB hosting on a free plan for testing purposes, and you can also request for a production ready database that allows you to scale.

In any MongoDB provider you will have a MongoDB URL which you must use it. If you use the free option provided by Galaxy, the initial setup is done for you.

Galaxy MongoDB URL will be like this: `mongodb://username:<password>@org-dbname-01.mongodb.galaxy-cloud.io` .
> You can read more about Galaxy MongoDB [here](https://galaxy-support.meteor.com/en/article/mongodb-general-1syd5af/).

### 8.3: Set up settings


You need to create a setting file, it’s a JSON file that Meteor apps can read configurations from. Create this file in a new folder called `private` in the root of your project. It is important to notice that `private` is a special folder that is not going to be published to the client side of your app.

Make sure you replace `Your MongoDB URL` by your own MongoDB URL :)


::: code-group
```json [private/settings.json]
{
  "galaxy.meteor.com": {
    "env": {
      "MONGO_URL": "Your MongoDB URL"
    }
  }
}
```
:::

### 8.4: Deploy it


Now you are ready to deploy, run `meteor npm install` before deploying to make sure all your dependencies are installed.

You also need to choose a subdomain to publish your app. We are going to use the main domain `meteorapp.com` that is free and included on any Galaxy plan.

In this example we are going to use `react-meteor-3.meteorapp.com` but make sure you select a different one, otherwise you are going to receive an error.


> You can learn how to use custom domains on Galaxy [here](https://galaxy-support.meteor.com/en/article/domains-16cijgc/). Custom domains are available starting with the Essentials plan.

Run the deployment command:

```shell
meteor deploy react-meteor-3.meteorapp.com --free --mongo
```

> If you are not using the free hosting with MongoDB on Galaxy, then remove the `--mongo` flag from the deploy script and add `--settings private/settings.json` with the proper setting for your app.

Make sure you replace `react-meteor-3` by a custom name that you want as subdomain. You will see a log like this:

```shell
meteor deploy react-meteor-3.meteorapp.com --settings private/settings.json
Talking to Galaxy servers at https://us-east-1.galaxy-deploy.meteor.com
Preparing to build your app...                
Preparing to upload your app... 
Uploaded app bundle for new app at vue-tutorial.meteorapp.com.
Galaxy is building the app into a native image.
Waiting for deployment updates from Galaxy... 
Building app image...                         
Deploying app...                              
You have successfully deployed the first version of your app.
For details, visit https://galaxy.meteor.com/app/react-meteor-3.meteorapp.com
```


This process usually takes just a few minutes, but it depends on your internet speed as it’s going to send your app bundle to Galaxy servers.

> Galaxy builds a new Docker image that contains your app bundle and then deploy containers using it, [read more](https://galaxy-support.meteor.com/en/article/container-environment-lfd6kh/).
You can check your logs on Galaxy, including the part that Galaxy is building your Docker image and deploying it.

### 8.5: Access the app and enjoy


Now you should be able to access your Galaxy dashboard at `https://galaxy.meteor.com/app/react-meteor-3.meteorapp.com`.

You can also access your app on Galaxy 2.0 which is currently in beta at `https://galaxy-beta.meteor.com/<your-username>/us-east-1/apps/<your-app-name>.meteorapp.com`. Remember to use your own subdomain instead of `react-meteor-3`.

You can access the app at [react-meteor-3.meteorapp.com](https://react-meteor-3.meteorapp.com/)! Just use your subdomain to access yours!

> We deployed to Galaxy running in the US (us-east-1), we also have Galaxy running in other regions in the world, check the list [here](https://galaxy-support.meteor.com/en/article/regions-1vucejm/).
This is huge, you have your app running on Galaxy, ready to be used by anyone in the world!

---

---
url: /tutorials/react/7.adding-user-accounts.md
---
## 7: Adding User Accounts

### 7.1: Password Authentication

Meteor already comes with a basic authentication and account management system out of the box, so you only need to add the `accounts-password` to enable username and password authentication:

```shell
meteor add accounts-password
```

> There are many more authentication methods supported. You can read more about the accounts system [here](https://v3-docs.meteor.com/api/accounts.html).

We also recommend you to install `bcrypt` node module, otherwise, you are going to see a warning saying that you are using a pure-Javascript implementation of it.

```shell
meteor npm install --save bcrypt
```

> You should always use `meteor npm` instead of only `npm` so you always use the `npm` version pinned by Meteor, this helps you to avoid problems due to different versions of npm installing different modules.

### 7.2: Create User Account

Now you can create a default user for our app, we are going to use `meteorite` as username, we just create a new user on server startup if we didn't find it in the database.

::: code-group

```js [server/main.js]
import { Meteor } from 'meteor/meteor';
import { Accounts } from 'meteor/accounts-base';
import { TasksCollection } from '/imports/api/TasksCollection';

..

const SEED_USERNAME = 'meteorite';
const SEED_PASSWORD = 'password';

Meteor.startup(async () => {
  if (!(await Accounts.findUserByUsername(SEED_USERNAME))) {
    await Accounts.createUser({
      username: SEED_USERNAME,
      password: SEED_PASSWORD,
    });
  }
  ..
});
```

:::

You should not see anything different in your app UI yet.

### 7.3: Login Form

You need to provide a way for the users to input the credentials and authenticate, for that we need a form.

We can implement it using `useState` hook. Create a new file called `LoginForm.jsx` and add a form to it. You should use `Meteor.loginWithPassword(username, password);` to authenticate your user with the provided inputs.

::: code-group

```js [imports/ui/LoginForm.jsx]
import { Meteor } from "meteor/meteor";
import React, { useState } from "react";

export const LoginForm = () => {
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");

  const submit = (e) => {
    e.preventDefault();

    Meteor.loginWithPassword(username, password);
  };

  return (
    <form onSubmit={submit} className="login-form">
      <label htmlFor="username">Username</label>

      <input
        type="text"
        placeholder="Username"
        name="username"
        required
        onChange={(e) => setUsername(e.target.value)}
      />

      <label htmlFor="password">Password</label>

      <input
        type="password"
        placeholder="Password"
        name="password"
        required
        onChange={(e) => setPassword(e.target.value)}
      />

      <button type="submit">Log In</button>
    </form>
  );
};
```

:::

Ok, now you have a form, let's use it.

### 7.4: Require Authentication

Our app should only allow an authenticated user to access its task management features.

We can accomplish that by returning the `LoginForm` component when we don't have an authenticated user, otherwise we return the form, filter, and list component.

You should first wrap the 3 components (form, filter, and list) in a `<Fragment>`, Fragment is a special component in React that you can use to group components together without affecting your final DOM, it means without affecting your UI as it is not going to introduce other elements in the HTML.

> Read more about Fragments [here](https://react.dev/reference/react/Fragment)

So you can get your authenticated user or null from `Meteor.user()`, you should wrap it in a `useTracker` hook for it to be reactive. Then you can return the `Fragment` with Tasks and everything else or `LoginForm` based on the user being present or not in the session.

::: code-group

```js [imports/ui/App.jsx]
import { Meteor } from 'meteor/meteor';
import React, { useState, Fragment } from 'react';
import { useTracker } from 'meteor/react-meteor-data';
import { TasksCollection } from '/imports/api/TasksCollection';
import { Task } from './Task';
import { TaskForm } from './TaskForm';
import { LoginForm } from './LoginForm';

..
export const App = () => {
  const user = useTracker(() => Meteor.user());

  ..
  return (
      ..
      <div className="main">
        {user ? (
          <Fragment>
            <TaskForm />

            <div className="filter">
              <button onClick={() => setHideCompleted(!hideCompleted)}>
                {hideCompleted ? 'Show All' : 'Hide Completed'}
              </button>
            </div>

            <ul className="tasks">
              {tasks.map(task => (
                <Task
                  key={task._id}
                  task={task}
                  onCheckboxClick={handleToggleChecked}
                  onDeleteClick={handleDelete}
                />
              ))}
            </ul>
          </Fragment>
        ) : (
          <LoginForm />
        )}
      </div>
..
```

:::

### 7.5: Login Form style

Ok, let's style the login form now:

Wrap your pairs of label and input in `div`s so it will easier to control it on CSS. Do the same to the button tag.

::: code-group

```jsx [imports/ui/LoginForm.jsx]
<form onSubmit={submit} className="login-form">
  <div>
    <label htmlFor="username">Username</label>

    <input
      type="text"
      placeholder="Username"
      name="username"
      required
      onChange={(e) => setUsername(e.target.value)}
    />
  </div>

  <div>
    <label htmlFor="password">Password</label>

    <input
      type="password"
      placeholder="Password"
      name="password"
      required
      onChange={(e) => setPassword(e.target.value)}
    />
  </div>

  <div>
    <button type="submit">Log In</button>
  </div>
</form>
```

:::

And then update the CSS:

::: code-group

```css [client/main.css]
.login-form {
  display: flex;
  flex-direction: column;
  height: 100%;

  justify-content: center;
  align-items: center;
}

.login-form > div {
  margin: 8px;
}

.login-form > div > label {
  font-weight: bold;
}

.login-form > div > input {
  flex-grow: 1;
  box-sizing: border-box;
  padding: 10px 6px;
  background: transparent;
  border: 1px solid #aaa;
  width: 100%;
  font-size: 1em;
  margin-right: 16px;
  margin-top: 4px;
}

.login-form > div > input:focus {
  outline: 0;
}

.login-form > div > button {
  background-color: #62807e;
}
```

:::

Now your login form should be centralized and beautiful.

### 7.6: Server startup

Every task should have an owner from now on. So go to your database, as you learn before, and remove all the tasks from there:

`db.tasks.remove({});`

Change your `server/main.js` to add the seed tasks using your `meteorite` user as owner.

Make sure you restart the server after this change so `Meteor.startup` block will run again. This is probably going to happen automatically anyway as you are going to make changes in the server side code.

::: code-group

```js [server/main.js]
import { Meteor } from "meteor/meteor";
import { Accounts } from "meteor/accounts-base";
import { TasksCollection } from "/imports/api/TasksCollection";

const insertTask = (taskText, user) =>
  TasksCollection.insertAsync({
    text: taskText,
    userId: user._id,
    createdAt: new Date(),
  });

const SEED_USERNAME = "meteorite";
const SEED_PASSWORD = "password";

Meteor.startup(async () => {
  if (!(await Accounts.findUserByUsername(SEED_USERNAME))) {
    await Accounts.createUser({
      username: SEED_USERNAME,
      password: SEED_PASSWORD,
    });
  }

  const user = await Accounts.findUserByUsername(SEED_USERNAME);

  if ((await TasksCollection.find().countAsync()) === 0) {
    [
      "First Task",
      "Second Task",
      "Third Task",
      "Fourth Task",
      "Fifth Task",
      "Sixth Task",
      "Seventh Task",
    ].forEach((taskText) => insertTask(taskText, user));
  }
});
```

:::

See that we are using a new field called `userId` with our user `_id` field, we are also setting `createdAt` field.

### 7.7: Task owner

First, let's change our publication to publish the tasks only for the currently logged user. This is important for security, as you send only data that belongs to that user.

::: code-group

```js [/imports/api/TasksPublications.js]
Meteor.publish("tasks", function () {
  const userId = this.userId;
  if (!userId) {
    return this.ready();
  }
  return TasksCollection.find({ userId });
});
```

:::

Now let's check if we have a `user` before trying to fetch any data:

::: code-group

```js [imports/ui/App.jsx]
..
    const tasks = useTracker(() => {
      if (!user) {
        return [];
      }

      return TasksCollection.find(
        hideCompleted ? hideCompletedFilter : {},
        {
          sort: { createdAt: -1 },
        }
      ).fetch();
    });

    const pendingTasksCount = useTracker(() => {
      if (!user) {
        return 0;
      }
      ..
    });
..
```

:::

Also, update the `tasks.insert` method to include the field `userId` when creating a new task:

::: code-group

```js [imports/api/tasksMethods.js]
..
Meteor.methods({
  "tasks.insert"(doc) {
    return TasksCollection.insertAsync({
      ...doc,
      userId: this.userId,
    });
  },
..
```

:::

### 7.8: Log out

We also can better organize our tasks by showing the username of the owner below our app bar. You can include a new `div` right after our `Fragment` start tag.

On this, you can add an `onClick` handler to logout the user as well. It is very straightforward, just call `Meteor.logout()` on it.

::: code-group

```js [imports/ui/App.jsx]
..
  const logout = () => Meteor.logout();

  return (
..
    <Fragment>
      <div className="user" onClick={logout}>
        {user.username} 🚪
      </div>
..
```

:::

Remember to style your username as well.

::: code-group

```css [client/main.css]
.user {
  display: flex;

  align-self: flex-end;

  margin: 8px 16px 0;
  font-weight: bold;
  cursor: pointer;
}
```

:::

Phew! You have done quite a lot in this step. Authenticated the user, set the user in the tasks, and provided a way for the user to log out.

Your app should look like this:

<img width="200px" src="/tutorials/react/assets/step07-login.png"/>
<img width="200px" src="/tutorials/react/assets/step07-logout.png"/>

In the next step, we are going to learn how to deploy your app!

---

---
url: /tutorials/react/6.filter-tasks.md
---
## 6: Filter tasks

In this step, you will filter your tasks by status and show the number of pending tasks.

### 6.1: useState

First, you are going to add a button to show or hide the completed tasks from the list.

The `useState` function from React is the best way to keep the state of this button. It returns an array with two items, where the first element is the value of the state, and the second is a setter function that is how you are going to update your state. You can use _array destructuring_ to get these two back and already declare a variable for them.

Bear in mind that the names used for the constants do not belong to the React API, you can name them whatever you like.

Also, add a `button` below the task form that will display a different text based on the current state.

::: code-group

```js [imports/ui/App.jsx]
import React, { useState } from 'react';
..
export const App = () => {
  const [hideCompleted, setHideCompleted] = useState(false);

  ..
    <div className="main">
      <TaskForm />
       <div className="filter">
         <button onClick={() => setHideCompleted(!hideCompleted)}>
           {hideCompleted ? 'Show All' : 'Hide Completed'}
         </button>
       </div>
  ..
```

:::
You can read more about the `useState` hook [here](https://react.dev/reference/react/useState).

We recommend that you add your hooks always in the top of your components, so it will be easier to avoid some problems, like always running them in the same order.

### 6.2: Button style

You should add some style to your button so it does not look gray and without a good contrast. You can use the styles below as a reference:

::: code-group

```css [client/main.css]
.filter {
  display: flex;
  justify-content: center;
}

.filter > button {
  background-color: #62807e;
}
```

:::

### 6.3: Filter Tasks

Now, if the user wants to see only pending tasks you can add a filter to your selector in the Mini Mongo query, you want to get all the tasks that are not `isChecked` true.

::: code-group

```js [imports/ui/App.jsx]
..
  const hideCompletedFilter = { isChecked: { $ne: true } };

  const tasks = useTracker(() =>
    TasksCollection.find(hideCompleted ? hideCompletedFilter : {}, {
      sort: { createdAt: -1 },
    }).fetch()
  );
..
```

:::

### 6.4: Meteor Dev Tools Extension

You can install an extension to visualize the data in your Mini Mongo.

[Meteor DevTools Evolved](https://chrome.google.com/webstore/detail/meteor-devtools-evolved/ibniinmoafhgbifjojidlagmggecmpgf) will help you to debug your app as you can see what data is on Mini Mongo.

<img width="800px" src="/tutorials/react/assets/step06-extension.png"/>

You can also see all the messages that Meteor is sending and receiving from the server, this is useful for you to learn more about how Meteor works.

<img width="800px" src="/tutorials/react/assets/step06-ddp-messages.png"/>

Install it in your Google Chrome browser using this [link](https://chrome.google.com/webstore/detail/meteor-devtools-evolved/ibniinmoafhgbifjojidlagmggecmpgf).

### 6.5: Pending tasks

Update the App component in order to show the number of pending tasks in the app bar.

You should avoid adding zero to your app bar when there are no pending tasks.

::: code-group

```js [imports/ui/App.jsx]
..
  const pendingTasksCount = useTracker(() =>
    TasksCollection.find(hideCompletedFilter).count()
  );

  const pendingTasksTitle = `${
    pendingTasksCount ? ` (${pendingTasksCount})` : ''
  }`;
..

    <h1>
      📝️ To Do List
      {pendingTasksTitle}
    </h1>
..
```

:::
You could do both finds in the same `useTracker` and then return an object with both properties but to have a code that is easier to understand, we created two different trackers here.

Your app should look like this:

<img width="200px" src="/tutorials/react/assets/step06-all.png"/>
<img width="200px" src="/tutorials/react/assets/step06-filtered.png"/>

In the next step we are going to include user access in your app.

---

---
url: /tutorials/react/5.styles.md
---
## 5: Styles

### 5.1: CSS

Our user interface up until this point has looked quite ugly. Let's add some basic styling which will serve as the foundation for a more professional looking app.

Replace the content of our `client/main.css` file with the one below, the idea is to have an app bar at the top, and a scrollable content including:

- form to add new tasks;
- list of tasks.

::: code-group

```css [client/main.css]
body {
  font-family: sans-serif;
  background-color: #315481;
  background-image: linear-gradient(to bottom, #315481, #918e82 100%);
  background-attachment: fixed;

  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;

  padding: 0;
  margin: 0;

  font-size: 14px;
}

button {
  font-weight: bold;
  font-size: 1em;
  border: none;
  color: white;
  box-shadow: 0 3px 3px rgba(34, 25, 25, 0.4);
  padding: 5px;
  cursor: pointer;
}

button:focus {
  outline: 0;
}

.app {
  display: flex;
  flex-direction: column;
  height: 100vh;
}

.app-header {
  flex-grow: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.main {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
  overflow: auto;
  background: white;
}

.main::-webkit-scrollbar {
  width: 0;
  height: 0;
  background: inherit;
}

header {
  background: #d2edf4;
  background-image: linear-gradient(to bottom, #d0edf5, #e1e5f0 100%);
  padding: 20px 15px 15px 15px;
  position: relative;
  box-shadow: 0 3px 3px rgba(34, 25, 25, 0.4);
}

.app-bar {
  display: flex;
  justify-content: space-between;
}

.app-bar h1 {
  font-size: 1.5em;
  margin: 0;
  display: inline-block;
  margin-right: 1em;
}

.task-form {
  display: flex;
  margin: 16px;
}

.task-form > input {
  flex-grow: 1;
  box-sizing: border-box;
  padding: 10px 6px;
  background: transparent;
  border: 1px solid #aaa;
  width: 100%;
  font-size: 1em;
  margin-right: 16px;
}

.task-form > input:focus {
  outline: 0;
}

.task-form > button {
  min-width: 100px;
  height: 95%;
  background-color: #315481;
}

.tasks {
  list-style-type: none;
  padding-inline-start: 0;
  padding-left: 16px;
  padding-right: 16px;
  margin-block-start: 0;
  margin-block-end: 0;
}

.tasks > li {
  display: flex;
  padding: 16px;
  border-bottom: #eee solid 1px;
  align-items: center;
}

.tasks > li > span {
  flex-grow: 1;
}

.tasks > li > button {
  justify-self: flex-end;
  background-color: #ff3046;
}
```

:::

> If you want to learn more about this stylesheet check this article about [Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/), and also this free [video tutorial](https://flexbox.io/) about it from [Wes Bos](https://twitter.com/wesbos).
>
> Flexbox is an excellent tool to distribute and align elements in your UI.

### 5.2: Applying styles

Now you need to add some elements around your components. You are going to add a `className` to your main div in the `App`, also a `header` element with a few `divs` around your `h1`, and a main `div` around your form and list. Check below how it should be, pay attention to the name of the classes, they need to be the same as in the CSS file:

::: code-group

```js [imports/ui/App.jsx]
  ..
  return (
    <div className="app">
      <header>
        <div className="app-bar">
          <div className="app-header">
            <h1>Welcome to Meteor!</h1>
          </div>
        </div>
      </header>
      <div className="main">
        <TaskForm />

        <ul className="tasks">
          {tasks.map((task) => (
            <Task
              key={task._id}
              task={task}
              onCheckboxClick={handleToggleChecked}
              onDeleteClick={handleDelete}
            />
          ))}
        </ul>
      </div>
    </div>
  );
```

:::

> In React we use `className` instead of `class` as React uses Javascript to define the UI and `class` is a reserved word in Javascript.

Also, choose a better title for your app, Meteor is amazing but you don't want to see `Welcome to Meteor!` in your app top bar all the time.

You could choose something like:

::: code-group

```js [imports/ui/App.jsx]
  ..
  <h1>📝️ To Do List</h1>
  ..
```

:::

Your app should look like this:

<img width="200px" src="/tutorials/react/assets/step05-styles.png"/>

In the next step, we are going to make this task list more interactive, for example, providing a way to filter tasks.

---

---
url: /tutorials/react/4.update-and-remove.md
---
## 4: Update and Remove

Up until now, you have only inserted documents into our collection. Let's take a look at how you can update and remove them by interacting with the user interface.

### 4.1: Add Checkbox

First, you need to add a `checkbox` element to your `Task` component.

> Be sure to add the `readOnly` attribute since we are not using `onChange` to update the state.
>
> We also have to force our `checked` prop to a `boolean` since React understands that an `undefined` value as inexistent, therefore causing the component to switch from uncontrolled to a controlled one.
>
> You are also invited to experiment and see how the app behaves for learning purposes.

You also want to receive a callback, a function that will be called when the checkbox is clicked.

::: code-group

```js [imports/ui/Task.jsx]
import React from "react";

export const Task = ({ task, onCheckboxClick }) => {
  return (
    <li>
      <input
        type="checkbox"
        checked={!!task.isChecked}
        onClick={() => onCheckboxClick(task)}
        readOnly
      />
      <span>{task.text}</span>
    </li>
  );
};
```

:::

### 4.2: Toggle Checkbox

Now you can update your task document by toggling its `isChecked` field.

First, create a new method called `tasks.toggleChecked` to update the `isChecked` property.

::: code-group

```javascript [imports/api/tasksMethods.js]
import { Meteor } from "meteor/meteor";
import { TasksCollection } from "./TasksCollection";

Meteor.methods({
  ..
  "tasks.toggleChecked"({ _id, isChecked }) {
    return TasksCollection.updateAsync(_id, {
      $set: { isChecked: !isChecked },
    });
  },
});
```

:::

Now, create a function to change your document and pass it along to your `Task` component.

::: code-group

```js [imports/ui/App.jsx]
..

export const App = () => {
  const handleToggleChecked = ({ _id, isChecked }) =>
    Meteor.callAsync("tasks.toggleChecked", { _id, isChecked });
  ..
  <ul>
    { tasks.map(task => <Task key={ task._id } task={ task } onCheckboxClick={handleToggleChecked} />) }
  </ul>
  ..
```

:::

Your app should look like this:

<img width="200px" src="/tutorials/react/assets/step04-checkbox.png"/>

### 4.3: Remove tasks

You can remove tasks with just a few lines of code.

First, add a button after text in your `Task` component and receive a callback function.

::: code-group

```js [imports/ui/Task.jsx]
import React from 'react';

export const Task = ({ task, onCheckboxClick, onDeleteClick }) => {
  return (
..
      <span>{task.text}</span>
      <button onClick={ () => onDeleteClick(task) }>&times;</button>
..
```

:::

Now add the removal logic in the `App`, you need to have a function to delete the task and provide this function in your callback property in the `Task` component.

For that, let's create a new method called `tasks.delete`:

::: code-group

```javascript [imports/api/tasksMethods.js]
import { Meteor } from "meteor/meteor";
import { TasksCollection } from "./TasksCollection";

Meteor.methods({
  ..
  "tasks.delete"({ _id }) {
    return TasksCollection.removeAsync(_id);
  },
});
```

:::

Then, let's call this method inside a `handleDelete` function:

::: code-group

```js [imports/ui/App.jsx]
export const App = () => {
  ..
  const handleDelete = ({ _id }) =>// [!code highlight]
    Meteor.callAsync("tasks.delete", { _id });// [!code highlight]
  ..
  <ul>
    { tasks.map(task => <Task
      key={ task._id }
      task={ task }
      onCheckboxClick={handleToggleChecked}
      onDeleteClick={handleDelete} // [!code highlight]
    />) }
  </ul>
  ..
}
```

:::

Your app should look like this:

<img width="200px" src="/tutorials/react/assets/step04-delete-button.png"/>

In the next step, we are going to improve the look of your app using CSS with Flexbox.

---

---
url: /packages/url.md
---
# URL

`url` package provides polyfill for the [WHATWG url specification](https://url.spec.whatwg.org/) for legacy browsers or defaults to the global class which is available in modern browsers and Node. It is recommended that you use this package for compatibility with non-modern browsers.

For more information we recommend [reading the MDN articles](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) about it and looking over the [Node API documentation](https://nodejs.org/api/url.html#url_the_whatwg_url_api) for more details as this article covers only basic usage in Meteor.

## Usage

### Installation

To add this package to an existing app, run the following command from
your app directory:

```bash
meteor add url
```

To add the `url` package to an existing package, include the
statement `api.use('url');` in the `Package.onUse` callback in your
`package.js` file:

```js
Package.onUse((api) => {
  api.use("url");
});
```

After installing the package you can then import the `URL` and `URLSearchParams` from the package and use it as described at MDN and Node documentations.

### URL

```js
import { URL } from "meteor/url";

const url = new URL("https://www.meteor.com");
```

You can then use `URL` for example in a [fetch](/packages/fetch) call:

```js
import { URL } from 'meteor/url';
import { fetch } from 'meteor/fetch';

const url = new URL('https://www.example.com/api/reportVisit');

fetch(url, {
    method: 'POST',
    body: JSON.stringify({ siteId: 11 })
    ...
})

```

### URLSearchParams

```js
import { URLSearchParams } from "meteor/url";

const searchParams = new URLSearchParams({ query: "WHATWG", location: "MDN" });
```

You can then include `URLSearchParams` in the options for `URL` if you build them separately from when creating the `URL` class.

---

---
url: /cli/using-core-types.md
---

# Using Core Types

Using core types with zodern:types

For MeteorJS in its version 2.8.1 we have introduced to our core packages an integration with the [zodern:types](https://github.com/zodern/meteor-types) package. 
This package allows you to use the TypeScript types for the Meteor core packages in your TypeScript code or JavaScript code. 
in order to use the types you need to install the package by running the command:

```bash
meteor add zodern:types
```

And add the following line to your `tsconfig.json` file (if you do not have one, create one and add the code bellow):

```json
{
  "compilerOptions": {
    "preserveSymlinks": true,
    "paths": {
      "meteor/*": [
        "node_modules/@types/meteor/*",
        ".meteor/local/types/packages.d.ts"
      ]
    }
  }
}
```

then run the command:

```bash
meteor lint
```

this will create a file within your .meteor folder that will have your types for the core packages.
You can continue to use your code as you did before, but now you can use the types for the core packages even if you are in JavaScript.

for more information about the package please visit the [zodern:types](https://github.com/zodern/meteor-types).

---

---
url: /about/web-apps.md
---
# Web Apps

Meteor allows developers to build web applications using front-end frameworks like React, Vue, Blaze, Svelte, and Solid.
This section will help you quickly set up a new MeteorJS project using React.

## Step 1: Install Meteor

Ensure you have the latest official Meteor release installed. You can find installation instructions in our [docs](/about/install.html).

## Step 2: Create a New Project

To create a new project with Meteor and React, use the command:

```shell
meteor create myapp
```

This command sets up a Meteor project with React, allowing you to start developing right away.

You can also add the `--react` option to explicitly choose React, but it's already included by default.
If you prefer TypeScript, simply add the `--typescript` option. 

```shell
meteor create myapp --typescript
```

### Additional Options

Meteor offers flags to generate different types of apps, like choosing a different front-end framework or configurations during project setup.

Additional options are available in the [Meteor CLI](/cli/#meteor-create-app-name) section.

## Step 3: Run Your Project Locally

Navigate into your project directory and start the Meteor server:

```shell
cd myapp
meteor
```

With no arguments, `meteor` runs the project in the current directory in local development mode.
Your application will be running at `http://localhost:3000/`, ready for you to begin development.

## Getting Help

You can find help for using the Meteor command line. Just run `meteor help` to see a list of common commands.
If you want detailed help about a specific command, run `meteor help <command>`. For example, `meteor help create`.

## Next Steps

- Follow the [React](/tutorials/react/index.html) or [Vue](/tutorials/vue/meteorjs3-vue3-vue-meteor-tracker.html) tutorials. New tutorials are coming soon.
- Read about [Cordova for Mobile Apps](/about/cordova.html).
- Explore the [Meteor Guide](https://guide.meteor.com/).

---

---
url: /packages/webapp.md
---
# WebApp

The `webapp` package is what lets your Meteor app serve content to a web
browser. It is included in the `meteor-base` set of packages that is
automatically added when you run `meteor create`. You can easily build a
Meteor app without it - for example if you wanted to make a command-line
tool that still used the Meteor package system and DDP.

This package also allows you to add handlers for HTTP requests.
This lets other services access your app's data through an HTTP API, allowing
it to easily interoperate with tools and frameworks that don't yet support DDP.

`webapp` exposes the [express](https://github.com/expressjs/express) API for
handling requests through `WebApp.handlers`.
Here's an example that will let you handle a specific URL:

```js
// Listen to incoming HTTP requests (can only be used on the server).
WebApp.handlers.use("/hello", (req, res, next) => {
  res.writeHead(200);
  res.end(`Hello world from: ${Meteor.release}`);
});
```

<ApiBox name="WebApp.handlers"/>
<ApiBox name="expressHandlersCallback(req, res, next)" hasCustomExample/>

### Serving a Static Landing Page

One of the really cool things you can do with WebApp is serve static HTML for a landing page where TTFB (time to first byte) is of utmost importance.

The [Bundle Visualizer](https://docs.meteor.com/packages/bundle-visualizer.html) and [Dynamic Imports](https://docs.meteor.com/packages/dynamic-import.html) are great tools to help you minimize initial page load times. But sometimes you just need to skinny down your initial page load to bare metal.

The good news is that WebApp makes this is really easy to do.

Step one is to create a your static HTML file and place it in the _private_ folder at the root of your application.

Here's a sample _index.html_ you might use to get started:

::: code-group

```html [index.html]
<head>
    <title>Fast Landing Page</title>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0 user-scalable=no" />
    <link rel="stylesheet" href="path to your style sheet etc">
</head>

    <body>
        <!-- your content -->
    </body>

    <script>

    // any functions you need to support your landing page

    </script>

</html>
```

```javascript [index.js]
/* global WebApp Assets */
import crypto from "crypto";
import express from "express";

const router = express.Router();

router.get("/", async function (req, res, next) {
  const buf = await Assets.getTextAsync("index.html");

  if (buf.length > 0) {
    const eTag = crypto.createHash("md5").update(buf).digest("hex");

    if (req.headers["if-none-match"] === eTag) {
      res.writeHead(304, "Not Modified");
      return res.end();
    }

    res.writeHead(200, {
      ETag: eTag,
      "Content-Type": "text/html",
    });

    return res.end(buf);
  }

  return res.end("<html><body>Index page not found!</body></html>");
});

WebApp.handlers.use(router);

```

:::
There are a couple things to think about with this approach.

We're reading the contents of index.html using the [Assets](../api/assets.md) module that makes it really easy to read files out of the _private_ root folder.

We're using the [connect-route](https://www.npmjs.com/package/connect-route) NPM package to simplify WebApp route processing. But you can use any package you want to understand what is being requested.

And finally, if you decide to use this technique you'll want to make sure you understand how conflicting client side routing will affect user experience.

### Dynamic Runtime Configuration

In some cases it is valuable to be able to control the **meteor_runtime_config** variable that initializes Meteor at runtime.

#### Example

There are occasions when a single Meteor server would like to serve multiple cordova applications that each have a unique `ROOT_URL`. But there are 2 problems:

1. The Meteor server can only be configured to serve a single `ROOT_URL`.
2. The `cordova` applications are build time configured with a specific `ROOT_URL`.

These 2 conditions break `autoupdate` for the cordova applications. `cordova-plugin-meteor-webapp` will fail the update if the `ROOT_URL` from the server does not match the build time configured `ROOT_URL` of the cordova application.

To remedy this problem `webapp` has a hook for dynamically configuring `__meteor_runtime_config__` on the server.

#### Dynamic Runtime Configuration Hook

```js
WebApp.addRuntimeConfigHook(
  ({ arch, request, encodedCurrentConfig, updated }) => {
    // check the request to see if this is a request that requires
    // modifying the runtime configuration
    if (request.headers.domain === "calling.domain") {
      // make changes to the config for this domain
      // decode the current runtime config string into an object
      const config = WebApp.decodeRuntimeConfig(current);
      // make your changes
      config.newVar = "some value";
      config.oldVar = "new value";
      // encode the modified object to the runtime config string
      // and return it
      return WebApp.encodeRuntimeConfig(config);
    }
    // Not modifying other domains so return undefined
    return undefined;
  }
);
```

<ApiBox name="WebApp.addRuntimeConfigHook"/>
<ApiBox name="addRuntimeConfigHookCallback(options)" hasCustomExample/>

Additionally, 2 helper functions are available to decode the runtime config string and encode the runtime config object.

<ApiBox name="WebApp.decodeRuntimeConfig"/>
<ApiBox name="WebApp.encodeRuntimeConfig"/>

### Updated Runtime Configuration Hook

```js
const autoupdateCache;
// Get a notification when the runtime configuration is updated
// for each arch
WebApp.addUpdatedNotifyHook(({arch, manifest, runtimeConfig}) => {
  // Example, see if runtimeConfig.autoupdate has changed and if so
  // do something
  if(!_.isEqual(autoupdateCache, runtimeConfig.autoupdate)) {
    autoupdateCache = runtimeConfig.autoupdate;
    // do something...
  }
})
```

<ApiBox name="WebApp.addUpdatedNotifyHook"/>
<ApiBox name="addUpdatedNotifyHookCallback(options)" hasCustomExample/>
<ApiBox name="main"/>

---

---
url: /performance/websocket-compression.md
---
# Websocket Compression in Meteor

::: warning
Modifying websocket compression settings without understanding your application's DDP messaging patterns can negatively impact performance. Before changing these settings, you should:
- Use [Meteor DevTools Evolved](https://chromewebstore.google.com/detail/meteor-devtools-evolved/ibniinmoafhgbifjojidlagmggecmpgf) or your browser's Network tab to monitor WebSocket traffic
- Analyze your DDP message frequency and payload sizes  
- Test changes in a staging environment with realistic data and user load
:::

Meteor's stream server uses the permessage-deflate extension for websocket compression by default. While compression can help reduce bandwidth usage, it may impact performance in reactivity-intensive applications due to the computational overhead of compressing numerous DDP messages.

## Configuration

### Disabling Compression

You can disable websocket compression by setting the `SERVER_WEBSOCKET_COMPRESSION` environment variable to `false`:

```bash
SERVER_WEBSOCKET_COMPRESSION=false
```

### Custom Compression Settings

To customize compression settings, set `SERVER_WEBSOCKET_COMPRESSION` to a JSON string with your desired configuration:

```bash
# Example with custom settings
SERVER_WEBSOCKET_COMPRESSION='{"threshold": 2048, "level": 1}'
```

Available configuration options:

- `threshold`: Minimum message size (in bytes) before compression is applied (default: 1024)
- `level`: Compression level (0-9, where 0=none, 1=fastest, 9=best compression)
- `memLevel`: Memory level (1-9, lower uses less memory)
- `noContextTakeover`: When true, compressor resets for each message (default: true)
- `maxWindowBits`: Window size for compression (9-15, lower uses less memory)

## Configuration Examples

Here are recommended configurations for different types of applications:

### High-Frequency Updates / Real-Time Dashboard

For applications with frequent small updates (e.g., real-time dashboards, trading platforms):

```bash
# Disable compression for optimal performance with small, frequent updates
SERVER_WEBSOCKET_COMPRESSION=false
```

### Large Data Transfers

For applications transferring large datasets (e.g., file sharing, data visualization):

```bash
# Optimize for large data transfers
SERVER_WEBSOCKET_COMPRESSION='{"threshold": 1024, "level": 6, "memLevel": 8}'
```

### Memory-Constrained Environment

For deployments with limited memory resources:

```bash
# Minimize memory usage while maintaining compression
SERVER_WEBSOCKET_COMPRESSION='{"threshold": 2048, "level": 1, "memLevel": 1, "maxWindowBits": 9}'
```

### Balanced Configuration

For typical applications with mixed message sizes:

```bash
# Balance between compression and performance
SERVER_WEBSOCKET_COMPRESSION='{"threshold": 1536, "level": 3, "memLevel": 4}'
```

## Verifying Compression Status

You can check if compression is enabled through the Meteor shell:

```javascript
Meteor.server.stream_server.server.options.faye_server_options.extensions
```

Results interpretation:
- `[]` (empty array): Compression is disabled
- `[{}]` (array with object): Compression is enabled

## Performance Considerations

- For apps with high message throughput or frequent small updates, disabling compression may improve performance
- Large message payloads may benefit from compression, especially over slower network connections
- Consider monitoring CPU usage and response times when adjusting compression settings

## Default Configuration

When enabled, the default configuration uses:
- Compression threshold: 1024 bytes
- Compression level: Z_BEST_SPEED (fastest)
- Memory level: Z_MIN_MEMLEVEL (minimum memory usage)
- Context takeover: Disabled
- Window bits: Z_MIN_WINDOWBITS (minimum window size)

---

---
url: /troubleshooting/windows.md
---

# Windows

Trouble installing Meteor on Windows

## Can't start Mongo server {#cant-start-mongo-server}

If your embed MongoDB is not starting when you run `meteor` and you see messages like these:

```shell script
C:\Users\user\app> meteor
=> Started proxy.
Unexpected mongo exit code 3221225781. Restarting.
Unexpected mongo exit code 3221225781. Restarting.
Unexpected mongo exit code 3221225781. Restarting.
Can't start Mongo server.
```

You [probably](https://github.com/meteor/meteor/issues/10036#issuecomment-416485306) need to install `Visual C++ Redistributable for Visual Studio`, depending on your Windows and Meteor embbeded version of MongoDB the version of Visual Studio could be different. You can check the version that we are using in our Windows test environment [here](https://github.com/meteor/meteor/blob/devel/appveyor.yml#L10)

Starting from MongoDB 4.4.4 we started to use Visual Studio 2019.

Until MongoDB 4.2 [this](https://www.microsoft.com/en-us/download/confirmation.aspx?id=48145) was the usually the right version to be installed.

After installing `vc_redist.x64` you should be able to run Meteor and MongoDB server without problems.
